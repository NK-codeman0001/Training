---------------------------------------------------------------------
               			Active Record Associations
---------------------------------------------------------------------
In Rails, an association is a connection between two Active Record models. Why do we need associations between models? Because they make common operations simpler and easier in your code. 
___________________________________________________________________

############### The Types of Associations : The belongs_to Association ###############

-----
books
-----
Model: Book
belongs to author

id :integer
author_id :integer
published_at :datetime

=================

-------
authors
-------
Model: Author

id :integer
name :string

=============================
class Book < ApplicationRecord
belongs_to :author
end


(*)===> A belongs_to association sets up a connection with another model, such that each instance of the declaring model "belongs to" one instance of the other model. For example, if your application includes authors and books, and each book can be assigned to exactly one author, you'd declare the book model this way:

____________________________________________
class Book < ApplicationRecord
  belongs_to :author
end
____________________________________________

## belongs_to associations must use the singular term. 
If you used the pluralized form in the above example for the author association in the Book model and tried to create the instance by Book.create(authors: @author),
 you would be told that there was an "uninitialized constant Book::Authors". 
 This is because Rails automatically infers the class name from the association name. If the association name is wrongly pluralized, then the inferred class will be wrongly pluralized too.


(*)===> The corresponding migration might look like this:
____________________________________________
class CreateBooks < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
____________________________________________

## When used alone, belongs_to produces a one-directional one-to-one connection. Therefore each book in the above example "knows" its author, but the authors don't know about their books. To setup a bi-directional association - use belongs_to in combination with a has_one or has_many on the other model.


(*)===> belongs_to does not ensure reference consistency, so depending on the use case, you might also need to add a database-level foreign key constraint on the reference column, like this:
____________________________________________
create_table :books do |t|
  t.belongs_to :author, foreign_key: true
  # ...
end
____________________________________________

___________________________________________________________________

############### The Types of Associations : The has_one Association ###############
A has_one association indicates that one other model has a reference to this model. That model can be fetched through this association.

----------
supplierss
----------
Model: Supplier
has one account

id :integer
name :string

=============

---------
accountss
---------
Model: Account

id :integer
supplier_id :integer
account number :string

=================================

class Supplier < ApplicationRecord
has one :account
end


(*)===> if each supplier in your application has only one account, you'd declare the supplier model like this:
____________________________________________
class Supplier < ApplicationRecord
  has_one :account
end
____________________________________________

##The main difference from belongs_to is that the link column supplier_id is located in the other table



(*)===> The corresponding migration might look like this:
____________________________________________
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
____________________________________________


(*)===> Depending on the use case, you might also need to create a unique index and/or a foreign key constraint on the supplier column for the accounts table. 
In this case, the column definition might look like this:
____________________________________________
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
  # ...
end
____________________________________________

## This relation can be bi-directional when used in combination with belongs_to on the other model.
___________________________________________________________________

############### The Types of Associations :  The has_many Association ###############

A has_many association is similar to has_one, but indicates a one-to-many connection with another model. You'll often find this association on the "other side" of a belongs_to association. This association indicates that each instance of the model has zero or more instances of another model.

(*)===> For example, in an application containing authors and books, the author model could be declared like this:
____________________________________________
class Author < ApplicationRecord
  has_many :books
end
____________________________________________

## The name of the other model is pluralized when declaring a has_many association.


-------
authors
-------
Model: Author
has many :books

id :integer
name :string

==========

-----
books
-----
Model: Book

id :integer
author_id :integer
published_at :datetime

==============================

class Author< ApplicationRecord
has_many :books
end


(*)===> The corresponding migration might look like this:
____________________________________________
class CreateAuthors < ActiveRecord::Migration[7.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
____________________________________________


(*)===> Depending on the use case, it's usually a good idea to create a non-unique index and optionally a foreign key constraint on the author column for the books table:

____________________________________________
create_table :books do |t|
  t.belongs_to :author, index: true, foreign_key: true
  # ...
end
____________________________________________


___________________________________________________________________

############### The Types of Associations : The has_many :through Association ###############

A has_many :through association is often used to set up a many-to-many connection with another model. This association indicates that the declaring model can be matched with zero or more instances of another model by proceeding through a third model.



(*)===> For example, consider a medical practice where patients make appointments to see physicians. The relevant association declarations could look like this:
____________________________________________
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end

class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
____________________________________________

-----------
physicians
-----------
Model: Physician
han many :appointments
han many :patients, through: :apointments

id :integer
name :string

==================
------------
appointments
------------
Model: Appointment
belongs_to :physician
belongs_to :patient

id :integer
physician_id :integer
patient_id :integer
appointment_date :datetime

=================

---------
patients
---------
Model: Patient
has_many :acpointments
has_many :phsicans, through: :appointments

id :integer
name :string
===================

class Physician < ApplicationRecord
has_many :appointments
has_many :patients, :through =>:appointments
end

class Appointment < ApplicationRecord
belongs_to :physician
belongs_to :patient
end

class Patient < ApplicationRecord
has_many :appointments
has many :physicians, :through => :appointments
end


(*)===> The corresponding migration might look like this:
____________________________________________
class CreateAppointments < ActiveRecord::Migration[7.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
____________________________________________


(*)===> The collection of join models can be managed via the has_many association methods. For example, if you assign:

irb=> physician.patients = patients

## Then new join models are automatically created for the newly associated objects. 
If some that existed previously are now missing, then their join rows are automatically deleted.

____________________________________________
Automatic deletion of join models is direct, no destroy callbacks are triggered.
____________________________________________

## The has_many :through association is also useful for setting up "shortcuts" through nested has_many associations.


(*)===> For example, if a document has many sections, and a section has many paragraphs, you may sometimes want to get a simple collection of all paragraphs in the document. 

You could set that up this way:
____________________________________________
class Document < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end
____________________________________________


(*)===>  With through: :sections specified, Rails will now understand:

irb => @document.paragraphs

___________________________________________________________________

############### The Types of Associations : The has_one :through Association ###############

A has_one :through association sets up a one-to-one connection with another model. This association indicates that the declaring model can be matched with one instance of another model by proceeding through a third model.

(*)===> For example, if each supplier has one account, and each account is associated with one account history, then the supplier model could look like this:
____________________________________________
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end
____________________________________________

---------
suppliers
---------
Model: Supplier
has_one :account
has_one aocount_history, :through :account

id :integer
name :string
=============

---------
accounts
---------
Model: Account
belongs_to :supplier
has_one :account_history

id :integer
supplier_id :integer
account_number :string
==================

-----------------
account_histories
-----------------
Model: AccountHistory
belongs_to :account

id :integer
account_id :integer
credit_rating :integer
=====================


(*)===> The corresponding migration might look like this:
____________________________________________
class CreateAccountHistories < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
____________________________________________


___________________________________________________________________

############### The Types of Associations : The has_and_belongs_to_many Association ###############

(*)===> A has_and_belongs_to_many association creates a direct many-to-many connection with another model, with no intervening model. This association indicates that each instance of the declaring model refers to zero or more instances of another model.

For example, if your application includes assemblies and parts, with each assembly having many parts and each part appearing in many assemblies, you could declare the models this way:
____________________________________________
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
____________________________________________

-----------
assemblies
----------
Model: Assembly
has and belongs.to many parts

id :integer 
name :string 
============

----------------
assemblies_parts
----------------
assembly_id :integer
part id :integer
================

------
parts
------
Model: Part
has and belongs to_many :assemblies

id :integer
part_number :string
===================


(*)===> The corresponding migration might look like this:

____________________________________________
class CreateAssembliesAndParts < ActiveRecord::Migration[7.0]
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
____________________________________________


___________________________________________________________________

############### Choosing Between belongs_to and has_one ###############

If you want to set up a one-to-one relationship between two models, you'll need to add belongs_to to one, and has_one to the other.


(*)===> How do you know which is which?

The distinction is in where you place the foreign key
(it goes on the table for the class declaring the belongs_to association),

For example, it makes more sense to say that a supplier owns an account than that an account owns a supplier. 

This suggests that the correct relationships are like this:
____________________________________________
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
end
____________________________________________


(*)===> The corresponding migration might look like this:

____________________________________________
class CreateSuppliers < ActiveRecord::Migration[7.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      #t.bigint  :supplier_id
      t.references :supplier
      t.string  :account_number
      t.timestamps
    end

    add_index :accounts, :supplier_id
  end
end
____________________________________________

## Traditionally, in Rails, you would use the t.bigint method to specify the foreign key column's data type, and then explicitly name the column something like supplier_id. This made it clear that the column was a foreign key referencing the id column of the suppliers table.

Using t.bigint :supplier_id makes the foreign key naming obvious and explicit. 

In current versions of Rails, you can abstract away this implementation detail by using t.references :supplier instead.

___________________________________________________________________

############### Choosing Between has_many :through and has_and_belongs_to_many ###############

Rails offers two different ways to declare a many-to-many relationship between models.

(*)===> The first way is to use has_and_belongs_to_many, which allows you to make the association directly:
____________________________________________
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
____________________________________________


(*)===> The second way to declare a many-to-many relationship is to use has_many :through. This makes the association indirectly, through a join model:
____________________________________________
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end

class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
____________________________________________


## The simplest rule of thumb is that you should set up a has_many :through relationship if you need to work with the relationship model as an independent entity. 

## If you don't need to do anything with the relationship model, it may be simpler to set up a has_and_belongs_to_many relationship
(though you'll need to remember to create the joining table in the database).

## You should use has_many :through if you need validations, callbacks, or extra attributes on the join model.

___________________________________________________________________

############### Polymorphic Associations ###############

A slightly more advanced twist on associations is the polymorphic association. With polymorphic associations, a model can belong to more than one other model, on a single association.

(*)===> For example, you might have a picture model that belongs to either an employee model or a product model. 
Here's how this could be declared:
____________________________________________
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end

class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end

class Product < ApplicationRecord
  has_many :pictures, as: :imageable
end
____________________________________________

## You can think of a polymorphic belongs_to declaration as setting up an interface that any other model can use. 

## From an instance of the Employee model, you can retrieve a collection of pictures: @employee.pictures.

## Similarly, you can retrieve @product.pictures.

## If you have an instance of the Picture model, you can get to its parent via @picture.imageable. 


(*)===> To make this work, you need to declare both a foreign key column and a type column in the model that declares the polymorphic interface:
____________________________________________
class CreatePictures < ActiveRecord::Migration[7.0]
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end
____________________________________________

---------
employees
---------
Model: Employee
has manry pictures, as> imageable

id :integer
name :string
=========

--------
pictures
-------
Model: Picture
belongs to imageable, polymorphic => true

id :integer
name :string
imageable_id :integer
imageable_type :string
===========

--------
products
--------
Model: Product
has many :pictures, as = imageabie

id :integer
name :string
============

___________________________________________________________________

############### Self Joins ###############
In designing a data model, you will sometimes find a model that should have a relation to itself. For example, you may want to store all employees in a single database model, but be able to trace relationships such as between manager and subordinates. 


(*)===> This situation can be modeled with self-joining associations:
____________________________________________
class Employee < ApplicationRecord
  has_many :subordinates, class_name: "Employee",
                          foreign_key: "manager_id"

  belongs_to :manager, class_name: "Employee", optional: true
end
____________________________________________

## With this setup, you can retrieve @employee.subordinates and @employee.manager.


(*)===> In your migrations/schema, you will add a references column to the model itself.
____________________________________________
class CreateEmployees < ActiveRecord::Migration[7.0]
  def change
    create_table :employees do |t|
      t.references :manager, foreign_key: { to_table: :employees }
      t.timestamps
    end
  end
end
____________________________________________


___________________________________________________________________

############### Controlling caching ###############

(*)===> All of the association methods are built around caching, which keeps the result of the most recent query available for further operations.

 The cache is even shared across methods. For example:
____________________________________________
# retrieves books from the database
author.books.load

# uses the cached copy of books
author.books.size

# uses the cached copy of books
author.books.empty?
____________________________________________

(*)===> But what if you want to reload the cache, because data might have been changed by some other part of the application? 

Just call reload on the association:
____________________________________________
# retrieves books from the database
author.books.load

# uses the cached copy of books
author.books.size

# discards the cached copy of books and goes back to the database
author.books.reload.empty?
____________________________________________


___________________________________________________________________

############### Avoiding name collisions ###############
In Rails, when you create an association between two models, a method with that association's name is added to the model. However, if the association name conflicts with an existing method in ActiveRecord::Base, it can cause unexpected behavior and break your application.

For example, let's say you have a model called User, and you want to create an association to a model called Attribute. If you create an association called attributes, which is the plural form of the attribute model name, you will run into issues because attributes is already a method defined in ActiveRecord::Base.


(*)===> Here's an example of what can happen:
____________________________________________
class User < ActiveRecord::Base
  has_many :attributes
end

user = User.first
user.attributes # This will return an empty hash, not the associated records
____________________________________________
## In this case, calling user.attributes will return an empty hash instead of the associated records because attributes is being overridden by the association method.



(*)===> Another example is using the name connection for an association:
____________________________________________
class User < ActiveRecord::Base
  belongs_to :connection
end

user = User.first
user.connection # This will return a Connection object, not the associated record
____________________________________________
## In this case, calling user.connection will return a Connection object instead of the associated record because connection is being overridden by the association method.


(*)===> To avoid these issues, it's important to choose association names that don't conflict with any existing methods in ActiveRecord::Base. You can use singular or plural forms of model names, or add a prefix or suffix to the name to make it more descriptive and unique. For example, you could use user_attributes instead of attributes for the association name in the first example, or connected_user instead of connection in the second example.

___________________________________________________________________

############### Updating the schema ###############
ou are responsible for maintaining your database schema to match your associations. 
In practice, this means two things, depending on what sort of associations you are creating. 

For belongs_to associations you need to create foreign keys, and for has_and_belongs_to_many associations you need to create the appropriate join table.


(*)===> Creating Foreign Keys for belongs_to Associations

When you declare a belongs_to association, you need to create foreign keys as appropriate. For example, consider this model:
____________________________________________
class Book < ApplicationRecord
  belongs_to :author
end
____________________________________________


This declaration needs to be backed up by a corresponding foreign key column in the books table. For a brand new table, the migration might look something like this:
____________________________________________
class CreateBooks < ActiveRecord::Migration[7.0]
  def change
    create_table :books do |t|
      t.datetime   :published_at
      t.string     :book_number
      t.references :author
    end
  end
end
____________________________________________

Whereas for an existing table, it might look like this:
____________________________________________
class AddAuthorToBooks < ActiveRecord::Migration[7.0]
  def change
    add_reference :books, :author
  end
end
____________________________________________

## If you wish to enforce referential integrity at the database level, add the foreign_key: true option to the ‘reference’ column declarations above.



(*)===> Creating Join Tables for has_and_belongs_to_many Associations

If you create a has_and_belongs_to_many association, you need to explicitly create the joining table. Unless the name of the join table is explicitly specified by using the :join_table option, Active Record creates the name by using the lexical order of the class names. So a join between author and book models will give the default join table name of "authors_books" because "a" outranks "b" in lexical ordering.

## The precedence between model names is calculated using the <=> operator for String. This means that if the strings are of different lengths, and the strings are equal when compared up to the shortest length, then the longer string is considered of higher lexical precedence than the shorter one. For example, one would expect the tables "paper_boxes" and "papers" to generate a join table name of "papers_paper_boxes" because of the length of the name "paper_boxes", but it in fact generates a join table name of "paper_boxes_papers" (because the underscore '_' is lexicographically less than 's' in common encodings).


Whatever the name, you must manually generate the join table with an appropriate migration. For example, consider these associations:
____________________________________________
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
____________________________________________

You can use the method create_join_table
____________________________________________
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[7.0]
  def change
    create_join_table :assemblies, :parts do |t|
      t.index :assembly_id
      t.index :part_id
    end
  end
end
____________________________________________


___________________________________________________________________

############### Controlling association scope ###############

By default, associations look for objects only within the current module's scope. This can be important when you declare Active Record models within a module.

(*)===> This will work fine, because both the Supplier and the Account class are defined within the same scope.
____________________________________________
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end

    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
____________________________________________


(*)===> But the following will not work, because Supplier and Account are defined in different scopes:
____________________________________________
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
____________________________________________



(*)===> To associate a model with a model in a different namespace, you must specify the complete class name in your association declaration:
____________________________________________
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end
____________________________________________

___________________________________________________________________

############### Bi-directional associations ###############

 It's normal for associations to work in two directions, requiring declaration on two different models:
____________________________________________
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
____________________________________________


____________________________________________
irb> a = Author.first
irb> b = a.books.first
irb> a.first_name == b.author.first_name
=> true
irb> a.first_name = 'David'
irb> a.first_name == b.author.first_name
=> true
____________________________________________

## Active Record supports automatic identification for most associations with standard names. 
## However, Active Record will not automatically identify bi-directional associations that contain the :through or :foreign_key options. 
## Custom scopes on the opposite association also prevent automatic identification, as do custom scopes on the association itself 
unless config.active_record.automatic_scope_inversing is set to true (the default for new applications).

For example, consider the following model declarations:
____________________________________________
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
____________________________________________

## In the Book class definition, the belongs_to association is specified with an option class_name: 'Author'. This means that the writer attribute of a Book object is associated with an Author object.

## The writer attribute is not a built-in attribute of a Book object, but rather a custom attribute that is defined in the Book class. This custom attribute is used to create a more descriptive name for the association between a Book object and an Author object.

## By default, when a belongs_to association is defined in Rails, the name of the association is used as the name of the attribute for the associated object. In this case, if the belongs_to association was defined with the default options, the attribute for the associated Author object would be called author.

## However, by specifying class_name: 'Author' and using the custom attribute name writer, the code makes the association more readable and easier to understand. It also provides more clarity and consistency with the has_many association in the Author class, which specifies that an author has many books.

## So in short, writer is used as a custom attribute name for the belongs_to association between a Book object and an Author object, in order to make the code more readable and easier to understand.
 

 Active Record will no longer automatically recognize the bi-directional association:
____________________________________________
irb> a = Author.first
irb> b = a.books.first
irb> a.first_name == b.writer.first_name
=> true
irb> a.first_name = 'David'
irb> a.first_name == b.writer.first_name
=> false
____________________________________________



Active Record provides the :inverse_of option so you can explicitly declare bi-directional associations:
____________________________________________
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
____________________________________________

By including the :inverse_of option in the has_many association declaration, Active Record will now recognize the bi-directional association:
____________________________________________
irb> a = Author.first
irb> b = a.books.first
irb> a.first_name == b.writer.first_name
=> true
irb> a.first_name = 'David'
irb> a.first_name == b.writer.first_name
=> true
____________________________________________


___________________________________________________________________


___________________________________________________________________
                  belongs_to Association Reference
___________________________________________________________________

In database terms, the belongs_to association says that this model's table contains a column which represents a reference to another table. This can be used to set up one-to-one or one-to-many relations, depending on the setup.
___________________________________________________________________

############### belongs_to Association Reference : Methods Added by belongs_to ###############

When you declare a belongs_to association, the declaring class automatically gains 8 methods related to the association:

In all of these methods, association is replaced with the symbol passed as the first argument to belongs_to. For example, given the declaration:
____________________________________________
class Book < ApplicationRecord
  belongs_to :author
end
____________________________________________


## Each instance of the Book model will have these methods:
____________________________________________
author
author=
build_author
create_author
create_author!
reload_author
author_changed?
author_previously_changed?
____________________________________________



(*)===> association
The association method returns the associated object, if any. If no associated object is found, it returns nil.
____________________________________________
@author = @book.author
____________________________________________


(*)===> reload_association

If the associated object has already been retrieved from the database for this object, the cached version will be returned.
To override this behavior (and force a database read), call #reload_association on the parent object.
____________________________________________
@author = @book.reload_author
____________________________________________


(*)===> association=(associate)

The association= method assigns an associated object to this object. 
Behind the scenes, this means extracting the primary key from the associated object and setting this object's foreign key to the same value.
____________________________________________
@book.author = @author
____________________________________________


(*)===> build_association(attributes = {})

The build_association method returns a new object of the associated type. 
This object will be instantiated from the passed attributes, and the link through this object's foreign key will be set, 

## but the associated object will not yet be saved.
____________________________________________
@author = @book.build_author(author_number: 123,           author_name: "John Doe")
____________________________________________


(*)===> create_association(attributes = {})

The create_association method returns a new object of the associated type. 
This object will be instantiated from the passed attributes, the link through this object's foreign key will be set, and, once it passes all of the validations specified on the associated model, 

## the associated object will be saved.
____________________________________________
@author = @book.create_author(author_number: 123,
                              author_name: "John Doe")
____________________________________________


(*)===> create_association!(attributes = {})

Does the same as create_association above, but raises 
ActiveRecord::RecordInvalid if the record is invalid.
____________________________________________
@author = @book.create_author!(author_number: 123,
                              author_name: "John Doe")
____________________________________________


(*)===> association_changed?

method returns true if a new associated object has been assigned and the foreign key will be updated in the next save.
____________________________________________
@book.author # => #<Book author_number: 123, author_name: "John Doe">
@book.author_changed? # => false

@book.author = Author.second # => #<Book author_number: 456, author_name: "Jane Smith">
@book.author_changed? # => true

@book.save!
@book.author_changed? # => false
____________________________________________


(*)===> association_previously_changed?

method returns true if the previous save updated the association to reference a new associate object.
____________________________________________
@book.author # => #<Book author_number: 123, author_name: "John Doe">
@book.author_previously_changed? # => false

@book.author = Author.second # => #<Book author_number: 456, author_name: "Jane Smith">
@book.save!
@book.author_previously_changed? # => true
____________________________________________


___________________________________________________________________

###############  belongs_to Association Reference : Options for belongs_to  ###############

Example:
____________________________________________
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at,
    counter_cache: true
end
____________________________________________

        The belongs_to association supports these options:

(*)===> :autosave

____________________________________________
class Author < ApplicationRecord
  has_many :books, autosave: false
end
____________________________________________

____________________________________________
class Author < ApplicationRecord
  has_many :books, autosave: false
end

class Book < ApplicationRecord
  belongs_to :author
end

author = Author.first
book = author.books.first
book.title = 'New Title'
author.save
____________________________________________

## In this code, we have the same Author and Book models, but with :autosave set to false. We load an Author object and one of its associated Book objects. We update the title of the Book object, and then we save the Author object. Because :autosave is set to false, Rails does not automatically save the associated Book object with the updated title. If we want to save the updated Book object, we need to call book.save explicitly.

## If the :autosave option is not present, then new associated objects will be saved, but updated associated objects will not be saved. 



(*)===> :class_name

If the name of the other model cannot be derived from the association name, you can use the :class_name option to supply the model name. For example, if a book belongs to an author, but the actual name of the model containing authors is Patron, you'd set things up this way:
____________________________________________
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron"
end
____________________________________________


(*)===> :counter_cache

asking for the value of @author.books.size requires making a call to the database to perform a COUNT(*) query. 
To avoid this call, you can add a counter cache to the belonging model:

____________________________________________
class Book < ApplicationRecord
  belongs_to :author, counter_cache: true
end

class Author < ApplicationRecord
  has_many :books
end
____________________________________________
## With this declaration, Rails will keep the cache value up to date, and then return that value in response to the size method.

## Although the :counter_cache option is specified on the model that includes the belongs_to declaration, the actual column must be added to the associated (has_many) model. 
In the case above, you would need to add a column named books_count to the Author model.

## You can override the default column name by specifying a custom column name in the counter_cache declaration instead of true. 

For example, to use count_of_books instead of books_count:
____________________________________________
class Book < ApplicationRecord
  belongs_to :author, counter_cache: :count_of_books
end

class Author < ApplicationRecord
  has_many :books
end
____________________________________________

## You only need to specify the :counter_cache option on the belongs_to side of the association.



(*)===> :dependent
____________________________________________
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end

author = Author.first
author.destroy # this will also destroy all of the author's books
____________________________________________

If you set the :dependent option to:

    :destroy, when the object is destroyed, destroy will be called on its associated objects.
    
    :delete, when the object is destroyed, all its associated objects will be deleted directly from the database without calling their destroy method.
    
    :destroy_async: when the object is destroyed, an ActiveRecord::DestroyAssociationAsyncJob job is enqueued which will call destroy on its associated objects. Active Job must be set up for this to work.

##You should not specify this option on a belongs_to association that is connected with a has_many association on the other class. Doing so can lead to orphaned records in your database.

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author, dependent: :destroy
end

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

## This is not recommended because if you destroy an author, it will attempt to destroy all of its associated books. However, since the book also belongs to an author, it will attempt to destroy the author again, creating an infinite loop and potentially orphaned records in the database.



(*)===> :foreign_key

By convention, Rails assumes that the column used to hold the foreign key on this model is the name of the association with the suffix _id added. 

The :foreign_key option lets you set the name of the foreign key directly:
____________________________________________
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron",
                      foreign_key: "patron_id"
end
____________________________________________

##In any case, Rails will not create foreign key columns for you. 
You need to explicitly define them as part of your migrations.



(*)===> :primary_key

## By convention, Rails assumes that the id column is used to hold the primary key of its tables. The :primary_key option allows you to specify a different column.

## For example, given we have a users table with guid as the primary key. If we want a separate todos table to hold the foreign key user_id in the guid column, then we can use primary_key to achieve this like so:
____________________________________________
class User < ApplicationRecord
  self.primary_key = 'guid' # primary key is guid and not id
end

class Todo < ApplicationRecord
  belongs_to :user, primary_key: 'guid'
end
____________________________________________
## When we execute @user.todos.create then the @todo record will have its user_id value as the guid value of @user.



(*)===> :inverse_of

The :inverse_of option specifies the name of the has_many or has_one association that is the inverse of this association.
____________________________________________
class Author < ApplicationRecord
  has_many :books, inverse_of: :author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books
end
____________________________________________


(*)===> :polymorphic

Passing true to the :polymorphic option indicates that this is a polymorphic association. Polymorphic associations were discussed in detail ====> 615


(*)===> :touch

If you set the :touch option to true, then the updated_at or updated_on timestamp on the associated object will be set to the current time whenever this object is saved or destroyed:

## The touch option allows you to update a timestamp on the associated Author object when a Book object is created or updated. 
## In this case, the books_updated_at attribute of the Author object is updated when a Book object is created or updated. 
## This can be useful for caching or performance reasons, or for tracking when an author's works were last updated.
____________________________________________
class Book < ApplicationRecord
  belongs_to :author, touch: true
end

class Author < ApplicationRecord
  has_many :books
end
____________________________________________

## In this case, saving or destroying a book will update the timestamp on the associated author. 

You can also specify a particular timestamp attribute to update:
____________________________________________
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at
end
____________________________________________


(*)===> :validate

##If you set the :validate option to true, then new associated objects will be validated whenever you save this object. 

##By default, this is false: new associated objects will not be validated when this object is saved.
____________________________________________
class Author < ApplicationRecord
  has_many :books, validate: true
end

class Book < ApplicationRecord
  belongs_to :author
  validates :title, presence: true
end

author = Author.new(name: "Jane Doe")
book = author.books.build(title: "")
author.save # returns false, and the book will not be saved because of its validation error
____________________________________________


(*)===> :optional

## If you set the :optional option to true, then the presence of the associated object won't be validated. By default, this option is set to false.
____________________________________________
class Book < ApplicationRecord
  belongs_to :author, optional: true
end

class Author < ApplicationRecord
  has_many :books
end
____________________________________________

##With this setup, you can create a book without specifying an author:

irb=> book = Book.new(title: "The Hitchhiker's Guide to the Galaxy")
irb=> book.save  # this will save the book without an associated author



## Without the optional: true option, this would raise an error:

irb=> book = Book.new(title: "The Hitchhiker's Guide to the Galaxy")
irb=> book.save  # this would raise an error, because an author is required

___________________________________________________________________

###############  belongs_to Association Reference : Scopes for belongs_to ###############

There may be times when you wish to customize the query used by belongs_to. Such customizations can be achieved via a scope block.
____________________________________________
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
____________________________________________

      You can use any of the standard querying methods inside the scope block. The following ones are discussed below:

(*)===> where

The where method lets you specify the conditions that the associated object must meet.
____________________________________________
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
____________________________________________

(*)===> includes

If you frequently retrieve authors directly from chapters (@chapter.book.author), then you can make your code somewhat more efficient by including authors in the association from chapters to books:
____________________________________________
class Chapter < ApplicationRecord
  belongs_to :book, -> { includes :author }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
____________________________________________

## With this setup, when you retrieve a chapter and its associated book, the associated author will also be loaded in a single query:

irb=> chapter = Chapter.find(1)
irb=> chapter.book.author  # this will retrieve the associated author without sending an additional query

## Without the includes option, this would result in two separate SQL queries being sent to the database:

irb=> chapter = Chapter.find(1)
irb=> book = chapter.book  # this sends one query
irb=> author = book.author  # this sends a second query

## By including the includes :author option in the belongs_to association from Chapter to Book, 
Rails will automatically generate a single SQL query that retrieves both the book and its associated author in a single join. 
This can result in significant performance improvements when you frequently retrieve associated records.

## Note that eager loading can be used with other types of associations as well, not just belongs_to. However, it should be used judiciously, as it can result in loading a large amount of data into memory if not used carefully.

##There's no need to use includes for immediate associations - that is, if you have Book belongs_to :author, then the author is eager-loaded automatically when it's needed.



(*)===> readonly
If you use readonly, then the associated object will be read-only when retrieved via the association.
____________________________________________
class Author < ApplicationRecord
  has_many :books, readonly: true
end

class Book < ApplicationRecord
  belongs_to :author
end
____________________________________________

## With this setup, when you retrieve an author and its associated books, the associated books will be read-only:

irb=> author = Author.find(1)
irb=> author.books.first.update(title: "New Title")  # This will raise an ActiveRecord::ReadOnlyRecord error


## If you want to update a read-only associated object, you can use the readonly(false) method to disable the read-only constraint:

irb=> author = Author.find(1)
irb=> book = author.books.first.readonly(false)
irb=> book.update(title: "New Title")  # This will update the book's title

## Note that using readonly does not prevent updates to the associated records via other associations or by directly manipulating the database. It only prevents updates via the association that includes the readonly option.

## Also note that using readonly can be a useful security measure, but it should be used carefully, as it can make debugging and troubleshooting more difficult. Additionally, it may not be appropriate in all situations, so use your judgment when deciding whether to use it.



(*)===> select

The select method lets you override the SQL SELECT clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns.

If we want to retrieve only the name and email columns from the associated author for a given book, we can use the select method as follows:
____________________________________________
book = Book.select(:id, :title).includes(:author).select("authors.name, authors.email").find(1)
____________________________________________


## If you use the select method on a belongs_to association, you should also set the :foreign_key option to guarantee the correct results.

______________________________________________
class Book < ApplicationRecord
  belongs_to :author, foreign_key: 'writer_id'
end
______________________________________________
___________________________________________________________________



___________________________________________________________________
                  has_one Association Reference
___________________________________________________________________

The has_one association creates a one-to-one match with another model. 
In database terms, this association says that the other class contains the foreign key. 

If this class contains the foreign key, then you should use belongs_to instead.

___________________________________________________________________

############### The has_one Association : Methods Added by has_one ###############

When you declare a has_one association, the declaring class automatically gains 6 methods related to the association:

    association
    association=(associate)
    build_association(attributes = {})
    create_association(attributes = {})
    create_association!(attributes = {})
    reload_association

___________________________________________________________________

############### The has_one Association : Options for has_one ###############

The has_one association supports these options:

    :as
    :autosave
    :class_name
    :dependent
    :foreign_key
    :inverse_of
    :primary_key
    :source
    :source_type
    :through
    :touch
    :validate


(*)===> :as

The :as option is used with has_one associations in Rails to specify a polymorphic association, which allows a single association to belong to multiple types of models. This can be useful in cases where multiple models share a common set of associated data.
____________________________________________
class User < ApplicationRecord
  has_one :profile, as: :profileable
end

class Company < ApplicationRecord
  has_one :profile, as: :profileable
end

class Profile < ApplicationRecord
  belongs_to :profileable, polymorphic: true
end
____________________________________________

## In this example, both the User and Company models have a has_one association with the Profile model, and the Profile model belongs to a polymorphic association called :profileable. The :as option is used to specify the name of the polymorphic association (:profileable), which will be used as the foreign key to store the associated object's type.


(*)===> :dependent
Controls what happens to the associated object when its owner is destroyed:

()===> :destroy = causes the associated object to also be destroyed
____________________________________________
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end

author = Author.create(name: "J.K. Rowling")
book = author.books.create(title: "Harry Potter")

author.destroy

Book.exists?(book.id) #=> false
____________________________________________


()===> :delete = causes the associated object to be deleted directly from the database (so callbacks will not execute)
____________________________________________
class Author < ApplicationRecord
  has_many :books, dependent: :delete
end

class Book < ApplicationRecord
  belongs_to :author
end

author = Author.create(name: "Stephen King")
book = author.books.create(title: "The Shining")

author.destroy

Book.exists?(book.id) #=> false
____________________________________________

()===> :destroy_async = when the object is destroyed, an ActiveRecord::DestroyAssociationAsyncJob job is enqueued which will call destroy on its associated objects. Active Job must be set up for this to work.
____________________________________________
class Author < ApplicationRecord
  has_many :books, dependent: :destroy_async
end

class Book < ApplicationRecord
  belongs_to :author
end

author = Author.create(name: "J.R.R. Tolkien")
book = author.books.create(title: "The Lord of the Rings")

author.destroy

# Wait for the background job to complete...
Book.exists?(book.id) #=> false
____________________________________________


()===> :nullify = causes the foreign key to be set to NULL. Polymorphic type column is also nullified on polymorphic associations. Callbacks are not executed.
____________________________________________
class Author < ApplicationRecord
  has_many :books, dependent: :nullify
end

class Book < ApplicationRecord
  belongs_to :author
end

author = Author.create(name: "Agatha Christie")
book = author.books.create(title: "Murder on the Orient Express")

author.destroy

book.reload
book.author_id #=> nil
____________________________________________

()===> :restrict_with_exception = causes an ActiveRecord::DeleteRestrictionError exception to be raised if there is an associated record
____________________________________________
class Author < ApplicationRecord
  has_many :books, dependent: :restrict_with_exception
end

class Book < ApplicationRecord
  belongs_to :author
end

author = Author.create(name: "George R.R. Martin")
book = author.books.create(title: "A Game of Thrones")

begin
  author.destroy
rescue ActiveRecord::DeleteRestrictionError => e
  puts e.message #=> "Cannot delete record because of dependent books"
end
____________________________________________


()===> :restrict_with_error = causes an error to be added to the owner if there is an associated object
____________________________________________
class Author < ApplicationRecord
  has_many :books, dependent: :restrict_with_error
end

class Book < ApplicationRecord
  belongs_to :author
end

author = Author.create(name: "Jane Austen")
book = author.books.create(title: "Pride and Prejudice")

author.destroy

author.errors.full_messages #=> ["Cannot delete record because of dependent books"]
____________________________________________





(*)===> :source

The :source option is used in a has_one :through association to specify the name of the source association. This allows you to specify a different association than the default association used to retrieve the associated object.
____________________________________________
class User < ApplicationRecord
  has_many :orders
  has_one :shipping_address, through: :last_order, source: :address
  has_one :last_order, -> { order(created_at: :desc) }, class_name: "Order"
end

class Order < ApplicationRecord
  belongs_to :user
  has_one :address
end

class Address < ApplicationRecord
  belongs_to :order
end
____________________________________________

## In this example, a user has many orders and we want to define a shipping_address association that is associated with the most recent order for that user. 

## We use has_one :through to define the association and set the :source option to specify that we want to use the address association on the Order model to retrieve the associated Address object.

irb=> user = User.first
irb=> user.orders.create
irb=> order = user.orders.create
irb=> order.build_address(street: "123 Main St", city: "Anytown")
irb=> order.save
irb=> user.shipping_address # returns the address for the most recent order

## In this example, we create two orders for the user and associate an address with the second order. We then retrieve the shipping_address for the user, which is the address associated with the most recent order.

## Note that the :source option is not required if the source association name is the same as the name of the association used to retrieve the associated object. In that case, Rails will use the default association name.

(*)===> :source_type 

The :source_type option specifies the source association type for a has_one :through association that proceeds through a polymorphic association.
____________________________________________
class Author < ApplicationRecord
  has_one :book
  has_one :hardback, through: :book, source: :format, source_type: "Hardback"
  has_one :dust_jacket, through: :hardback
end

class Book < ApplicationRecord
  belongs_to :format, polymorphic: true
end

class Paperback < ApplicationRecord; end

class Hardback < ApplicationRecord
  has_one :dust_jacket
end

class DustJacket < ApplicationRecord; end
____________________________________________


(*)===> :through

The :through option in Rails is used to specify a "through" association in a has_many or has_one association. 

It allows you to define a direct association between two models by using a third model as a "bridge".
____________________________________________
class User < ApplicationRecord
  has_many :assignments
  has_many :projects, through: :assignments
end

class Project < ApplicationRecord
  has_many :assignments
  has_many :users, through: :assignments
end

class Assignment < ApplicationRecord
  belongs_to :user
  belongs_to :project
end
____________________________________________



___________________________________________________________________

############### The has_one Association : Scopes for has_one ###############

You can use any of the standard querying methods inside the scope block. The following ones are discussed below:

    where
    includes
    readonly
    select

___________________________________________________________________

############### The has_one Association : Do Any Associated Objects Exist? ###############

(*)===> You can see if any associated objects exist by using the association.nil? method:
____________________________________________
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
____________________________________________

___________________________________________________________________

############### The has_one Association : When are Objects Saved? ###############

## When you assign an object to a has_one association, that object is automatically saved (in order to update its foreign key). In addition, any object being replaced is also automatically saved, because its foreign key will change too.

## If either of these saves fails due to validation errors, then the assignment statement returns false and the assignment itself is cancelled.

## If the parent object (the one declaring the has_one association) is unsaved (that is, new_record? returns true) then the child objects are not saved. They will automatically when the parent object is saved.

## If you want to assign an object to a has_one association without saving the object, use the build_association method.


___________________________________________________________________



___________________________________________________________________
                  has_many Association Reference
___________________________________________________________________

The has_many association creates a one-to-many relationship with another model. In database terms, this association says that the other class will have a foreign key that refers to instances of this class.
___________________________________________________________________

############### has_many Association Reference: Methods Added by has_many ###############

## In all of these methods, collection is replaced with the symbol passed as the first argument to has_many, and 

## collection_singular is replaced with the singularized version of that symbol. 

For example, given the declaration:
__________________________________________
class Author < ApplicationRecord
  has_many :books
end
__________________________________________

Each instance of the Author model will have these methods:

books
books<<(object, ...)
books.delete(object, ...)
books.destroy(object, ...)
books=(objects)
book_ids
book_ids=(ids)
books.clear
books.empty?
books.size
books.find(...)
books.where(...)
books.exists?(...)
books.build(attributes = {}, ...)
books.create(attributes = {})
books.create!(attributes = {})
books.reload




(*)===> collection
The collection method returns a Relation of all of the associated objects. If there are no associated objects, it returns an empty Relation.
____________________________________________
@books = @author.books
____________________________________________


(*)===> collection<<(object, ...)
The collection<< method adds one or more objects to the collection by setting their foreign keys to the primary key of the calling model.
____________________________________________
@author.books << @book1
____________________________________________


(*)===> collection.delete(object, ...)
The collection.delete method removes one or more objects from the collection by setting their foreign keys to NULL.
____________________________________________
@author.books.delete(@book1)
____________________________________________
## Additionally, objects will be destroyed if they're associated with dependent: :destroy, and deleted if they're associated with dependent: :delete_all.


(*)===> collection.destroy(object, ...)
The collection.destroy method removes one or more objects from the collection by running destroy on each object.
____________________________________________
@author.books.destroy(@book1)
____________________________________________
## Objects will always be removed from the database, ignoring the :dependent option.


(*)===> collection=(objects)
____________________________________________
user = User.find(1)
tasks = Task.where(completed: true)

user.tasks = tasks
____________________________________________
## In this example, the user.tasks association will be replaced with the tasks that were returned by the Task.where query. 

## Any tasks that were previously associated with the user but are not included in the new array will be removed, and any new tasks that are not already associated with the user will be added.


(*)===> collection_singular_ids
The collection_singular_ids method returns an array of the ids of the objects in the collection.
____________________________________________
@book_ids = @author.book_ids
____________________________________________


(*)===> collection_singular_ids=(ids)
The collection_singular_ids= method makes the collection contain only the objects identified by the supplied primary key values, by adding and deleting as appropriate. The changes are persisted to the database.

For example, consider a Book model that has many Authors through a BookAuthor join table:
____________________________________________
class Book < ApplicationRecord
  has_many :book_authors
  has_many :authors, through: :book_authors
end

class Author < ApplicationRecord
  has_many :book_authors
  has_many :books, through: :book_authors
end

class BookAuthor < ApplicationRecord
  belongs_to :book
  belongs_to :author
end
____________________________________________

Suppose we want to set the authors of a book with a given ID to a specific set of authors identified by their IDs. We can do this using the collection_singular_ids= method:

irb=> book = Book.find(1)
irb=> author_ids = [2, 4, 6]
irb=> book.author_ids = author_ids

## This will set the authors of the book with ID 1 to the authors with IDs 2, 4, and 6. The collection_singular_ids= method will automatically add any new authors that are not currently associated with the book and remove any authors that are associated with the book but not in the supplied list.

The changes are persisted to the database when the book is saved:

irb=> book.save




(*)===> collection.clear
The collection.clear method removes all objects from the collection according to the strategy specified by the dependent option. 
If no option is given, it follows the default strategy. 
The default strategy for has_many :through associations is delete_all, and 
for has_many associations is to set the foreign keys to NULL.

____________________________________________
@author.books.clear
____________________________________________

## Objects will be deleted if they're associated with dependent: :destroy or dependent: :destroy_async, just like dependent: :delete_all.


(*)===> collection.empty?
The collection.empty? method returns true if the collection does not contain any associated objects.
____________________________________________
<% if @author.books.empty? %>
  No Books Found
<% end %>
____________________________________________


(*)===> collection.size
The collection.size method returns the number of objects in the collection.
____________________________________________
@book_count = @author.books.size
____________________________________________



(*)===> collection.find(...)
The collection.find method finds objects within the collection's table.
____________________________________________
@available_book = @author.books.find(1)
____________________________________________



(*)===> collection.where(...)
The collection.where method finds objects within the collection based on the conditions supplied but the objects are loaded lazily meaning that the database is queried only when the object(s) are accessed.
____________________________________________
@available_books = @author.books.where(available: true) # No query yet
@available_book = @available_books.first # Now the database will be queried
____________________________________________


(*)===> collection.exists?(...)

The collection.exists? method checks whether an object meeting the supplied conditions exists in the collection's table.
____________________________________________
user = User.find(1)
user.posts.exists?(published: true)

or

user.posts.where(published: true).exists?
____________________________________________



(*)===> collection.build(attributes = {})

the associated objects will not yet be saved.
____________________________________________
@book = @author.books.build(published_at: Time.now,
                            book_number: "A12345")

@books = @author.books.build([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }
])
____________________________________________


(*)===> collection.create(attributes = {})

the associated object will be saved.
____________________________________________
@book = @author.books.create(published_at: Time.now,
                             book_number: "A12345")

@books = @author.books.create([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }
])
____________________________________________



(*)===> collection.create!(attributes = {})
Does the same as collection.create above, but raises ActiveRecord::RecordInvalid if the record is invalid.



(*)===> collection.reload
The collection.reload method returns a Relation of all of the associated objects, forcing a database read. If there are no associated objects, it returns an empty Relation.
____________________________________________
@books = @author.books.reload
____________________________________________


___________________________________________________________________

############### has_many Association Reference: Options for has_many ###############

The has_many association supports these options:

    :as
    :autosave
    :class_name
    :counter_cache
    :dependent
    :foreign_key
    :inverse_of
    :primary_key
    :source
    :source_type
    :through
    :validate

___________________________________________________________________

############### has_many Association Reference: Scopes for has_many ###############

There may be times when you wish to customize the query used by has_many. Such customizations can be achieved via a scope block. For example:
________________________________________________
class Author < ApplicationRecord
  has_many :books, -> { where processed: true }
end
________________________________________________

You can use any of the standard querying methods inside the scope block. The following ones are discussed below:

    where
    extending
    group
    includes
    limit
    offset
    order
    readonly
    select
    distinct



(*)===> extending
The extending method in Rails is used to add custom methods to an association object. It allows you to specify a named module that will be extended into the association proxy object. This module can contain custom methods that can be called on the association object.

____________________________________________
module BookExtension
  def published
    where(published: true)
  end
end

class Author < ApplicationRecord
  has_many :books, extending: BookExtension
end
____________________________________________

## In the example above, we define a module BookExtension with a custom method published. We then use the extending option to add this module to the has_many :books association of the Author class.

Now we can call the published method on an author's books association to retrieve only the published books:

irb=> author = Author.first
irb=> author.books.published # returns all published books for the author

## The extending method can also be used with has_one and belongs_to associations.




(*)===> group
The group method supplies an attribute name to group the result set by, using a GROUP BY clause in the finder SQL.
____________________________________________
class Author < ApplicationRecord
  has_many :chapters, -> { group 'books.id' },
                      through: :books
end
____________________________________________




(*)===> limit
The limit method lets you restrict the total number of objects that will be fetched through an association.

____________________________________________
class Author < ApplicationRecord
  has_many :recent_books,
    -> { order('published_at desc').limit(100) },
    class_name: "Book"
end
____________________________________________



(*)===> offset

The offset method lets you specify the starting offset for fetching objects via an association. 
For example, -> { offset(11) } will skip the first 11 records.



(*)===> order
The order method dictates the order in which associated objects will be received (in the syntax used by an SQL ORDER BY clause).
____________________________________________
class Author < ApplicationRecord
  has_many :books, -> { order "date_confirmed DESC" }
end
____________________________________________



(*)===> distinct

Use the distinct method to keep the collection free of duplicates. This is mostly useful together with the :through option.
____________________________________________
class Person
  has_many :readings
  has_many :articles, -> { distinct }, through: :readings
end
____________________________________________

//with distinct
irb> person = Person.create(name: 'Honda')
irb> article = Article.create(name: 'a1')
irb> person.articles << article
irb> person.articles << article
irb> person.articles.to_a
=> [#<Article id: 7, name: "a1">]
irb> Reading.all.to_a
=> [#<Reading id: 16, person_id: 7, article_id: 7>, #<Reading id: 17, person_id: 7, article_id: 7>]

## In the above case there are still two readings. However person.articles shows only one article because the collection loads only unique records.

If you want to make sure that, upon insertion, all of the records in the persisted association are distinct (so that you can be sure that when you inspect the association that you will never find duplicate records), you should add a unique index on the table itself. For example, if you have a table named readings and you want to make sure the articles can only be added to a person once, you could add the following in a migration:

------------------------------------------------
add_index :readings, [:person_id, :article_id], unique: true
------------------------------------------------

irb> person = Person.create(name: 'Honda')
irb> article = Article.create(name: 'a1')
irb> person.articles << article
irb> person.articles << article
ActiveRecord::RecordNotUnique




___________________________________________________________________

############### has_many Association Reference: When are Objects Saved? ###############

## When you assign an object to a has_many association, that object is automatically saved (in order to update its foreign key). If you assign multiple objects in one statement, then they are all saved.

## If any of these saves fails due to validation errors, then the assignment statement returns false and the assignment itself is cancelled.

## If the parent object (the one declaring the has_many association) is unsaved (that is, new_record? returns true) then the child objects are not saved when they are added. All unsaved members of the association will automatically be saved when the parent is saved.

## If you want to assign an object to a has_many association without saving the object, use the collection.build method.


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


___________________________________________________________________

###############  ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________



___________________________________________________________________

############### END ###############

(*)===> 
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________




