---------------------------------------------------------------------
               			Active Record Query Interface
---------------------------------------------------------------------
Active Record will perform queries on the database for you and is compatible with most database systems, including MySQL, MariaDB, PostgreSQL, and SQLite. Regardless of which database system you're using, the Active Record method format will always be the same.

## All of the following models use id as the primary key, unless specified otherwise.

___________________________________________________________________

    Retrieving Objects from the Database
___________________________________________________________________

############### Retrieving a Single Object ###############
Active Record provides several finder methods

(*)===> annotate : Adds an SQL comment to queries generated from this relation.
____________________________________________
User.annotate("selecting user names").select(:name)
# SELECT "users"."name" FROM "users" /* selecting user names */

User.annotate("selecting", "user", "names").select(:name)
# SELECT "users"."name" FROM "users" /* selecting */ /* user */ /* names */
____________________________________________


===================================================================
(*)===> find : Using the find method, you can retrieve the object corresponding to the specified primary key that matches any supplied options. 

Find by id - This can either be a specific id (1), 
a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]). 

If one or more records cannot be found for the requested ids, then ActiveRecord::RecordNotFound will be raised. 
If the primary key is an integer, find by id coerces its arguments by using to_i.

____________________________________________
Person.find(1)          # returns the object for ID = 1
Person.find("1")        # returns the object for ID = 1
Person.find("31-sarah") # returns the object for ID = 31
Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6)
Person.find([7, 17])    # returns an array for objects with IDs in (7, 17)
Person.find([1])        # returns an array for the object with ID = 1
Person.where("administrator = 1").order("created_on DESC").find(1)
____________________________________________


===================================================================
(*)===> create_with : Sets attributes to be used when creating new records from a relation object.
____________________________________________
users = User.where(name: 'Oscar')
users.new.name # => 'Oscar'

users = users.create_with(name: 'DHH')
users.new.name # => 'DHH'
____________________________________________


You can pass nil to create_with to reset attributes:
____________________________________________
users = users.create_with(nil)
users.new.name # => 'Oscar'
____________________________________________



===================================================================
(*)===> distinct : Specifies whether the records should be unique or not. 

For example:
____________________________________________
User.select(:name)
# Might return two records with the same name

User.select(:name).distinct
# Returns 1 record per distinct name

User.select(:name).distinct.distinct(false)
# You can also remove the uniqueness
____________________________________________


===================================================================
(*)===> eager_load : loads associated records in a single query
Forces eager loading by performing a LEFT OUTER JOIN on args:
____________________________________________
User.eager_load(:posts)
# SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, ...
# FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" =
# "users"."id"
____________________________________________

===================================================================
(*)===> extending : adds methods to a relation object
____________________________________________
# Example
User.where(name: 'John').extending(User::CustomMethods)

# Result
# [Custom methods added to the relation object]
____________________________________________

Used to extend a scope with additional methods, either through a module or through a block provided.

The object returned is a relation, which can be further extended.


  ==> Using a module
    ____________________________________________
    module Pagination
      def page(number)
        # pagination code goes here
      end
    end

    scope = Model.all.extending(Pagination)
    scope.page(params[:page])
    ____________________________________________

            or
 
  You can also pass a list of modules:
    ____________________________________________
     scope = Model.all.extending(Pagination, SomethingElse)
    ____________________________________________


  ==> Using a block
    ____________________________________________
    scope = Model.all.extending do
      def page(number)
        # pagination code goes here
      end
    end
    scope.page(params[:page])
    ____________________________________________

                      or
  You can also use a block and a module list:
    ____________________________________________
    scope = Model.all.extending(Pagination) do
      def per_page(number)
        # pagination code goes here
      end
    end
    ____________________________________________


===================================================================
(*)===> extract_associated
Extracts a named association from the relation. The named association is first preloaded, then the individual association records are collected from the relation. 

Like so:
____________________________________________
account.memberships.extract_associated(:user)
# => Returns collection of User records
____________________________________________

This is short-hand for:
____________________________________________
account.memberships.preload(:user).collect(&:user)
____________________________________________



===================================================================
(*)===> from : 

Specifies the table from which the records will be fetched. For example:

____________________________________________
Topic.select('title').from('posts')
# SELECT title FROM posts
____________________________________________


Can accept other relation objects. For example:
____________________________________________
Topic.select('title').from(Topic.approved)
# SELECT title FROM (SELECT * FROM topics WHERE approved = 't') subquery
____________________________________________


Passing a second argument (string or symbol), creates the alias for the SQL from clause. Otherwise the alias “subquery” is used:
____________________________________________
Topic.select('a.title').from(Topic.approved, :a)
# SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a
____________________________________________


It does not add multiple arguments to the SQL from clause. The last from chained is the one used:
____________________________________________
Topic.select('title').from(Topic.approved).from(Topic.inactive)
# SELECT title FROM (SELECT topics.* FROM topics WHERE topics.active = 'f') subquery
____________________________________________



For multiple arguments for the SQL from clause, you can pass a string with the exact elements in the SQL from list:

____________________________________________
color = "red"
Color
  .from("colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)")
  .where("colorvalue->>'color' = ?", color)
  .select("c.*").to_a
# SELECT c.*
# FROM colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)
# WHERE (colorvalue->>'color' = 'red')
____________________________________________



===================================================================
(*)===> group : 

Allows to specify a group attribute:
____________________________________________
User.group(:name)
# SELECT "users".* FROM "users" GROUP BY name
____________________________________________


Returns an array with distinct records based on the group attribute:
____________________________________________
User.select([:id, :name])
# => [#<User id: 1, name: "Oscar">, #<User id: 2, name: "Oscar">, #<User id: 3, name: "Foo">]
____________________________________________

____________________________________________
User.group(:name)
# => [#<User id: 3, name: "Foo", ...>, #<User id: 2, name: "Oscar", ...>]
____________________________________________

____________________________________________
User.group('name AS grouped_name, age')
# => [#<User id: 3, name: "Foo", age: 21, ...>, #<User id: 2, name: "Oscar", age: 21, ...>, #<User id: 5, name: "Foo", age: 23, ...>]
____________________________________________


Passing in an array of attributes to group by is also supported.
____________________________________________
User.select([:id, :first_name]).group(:id, :first_name).first(3)
# => [#<User id: 1, first_name: "Bill">, #<User id: 2, first_name: "Earl">, #<User id: 3, first_name: "Beto">]
____________________________________________




===================================================================
(*)===> having : Allows to specify a HAVING clause. Note that you can't use HAVING without also specifying a GROUP clause.
____________________________________________
Order.having('SUM(price) > 30').group('user_id')
____________________________________________



===================================================================
(*)===> includes : 

Specify relationships to be included in the result set. For example:
____________________________________________
users = User.includes(:address)
users.each do |user|
  user.address.city
end
____________________________________________

allows you to access the address attribute of the User model without firing an additional query. This will often result in a performance improvement over a simple join.


You can also specify multiple relationships, like this:
____________________________________________
users = User.includes(:address, :friends)
____________________________________________


Loading nested relationships is possible using a Hash:
____________________________________________
users = User.includes(:address, friends: [:address, :followers])
____________________________________________


===Conditions===
If you want to add string conditions to your included models, you'll have to explicitly reference them. 
For example:
____________________________________________
User.includes(:posts).where('posts.name = ?', 'example')
____________________________________________

Will throw an error, but this will work:
____________________________________________
User.includes(:posts).where('posts.name = ?', 'example').references(:posts)
____________________________________________

## Note that includes works with association names while references needs the actual table name.

If you pass the conditions via hash, you don't need to call references explicitly, as where references the tables for you. 
For example, this will work correctly:
____________________________________________
User.includes(:posts).where(posts: { name: 'example' })
____________________________________________



===================================================================
(*)===> joins : 

Performs JOINs on args. The given symbol(s) should match the name of the association(s).
____________________________________________
User.joins(:posts)
# SELECT "users".*
# FROM "users"
# INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
____________________________________________


Multiple joins:
____________________________________________
User.joins(:posts, :account)
# SELECT "users".*
# FROM "users"
# INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
# INNER JOIN "accounts" ON "accounts"."id" = "users"."account_id"
____________________________________________


Nested joins:
____________________________________________
User.joins(posts: [:comments])
# SELECT "users".*
# FROM "users"
# INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
# INNER JOIN "comments" ON "comments"."post_id" = "posts"."id"
____________________________________________

You can use strings in order to customize your joins:
____________________________________________
User.joins("LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id")
# SELECT "users".* FROM "users" LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id
____________________________________________



===================================================================
(*)===> left_outer_joins || left_joins

Performs LEFT OUTER JOINs on args.
____________________________________________
User.left_outer_joins(:posts)
=> SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
____________________________________________



===================================================================
(*)===> limit : Specifies a limit for the number of records to retrieve.
____________________________________________
User.limit(10) # generated SQL has 'LIMIT 10'

User.limit(10).limit(20) # generated SQL has 'LIMIT 20'
____________________________________________



===================================================================
(*)===> lock : This method locks the selected records in the database to prevent other transactions from modifying them until the current transaction is complete. 

Here's an example:
____________________________________________
User.where(name: 'John').lock
____________________________________________

This generates the following SQL query:
____________________________________________
SELECT "users".* FROM "users" WHERE "users"."name" = 'John' FOR UPDATE
____________________________________________



===================================================================
(*)===> none : Returns a chainable relation with zero records.

The returned relation implements the Null Object pattern. It is an object with defined null behavior and always returns an empty array of records without querying the database.

Any subsequent condition chained to the returned relation will continue generating an empty relation and will not fire any query to the database.

Used in cases where a method or scope could return zero records but the result needs to be chainable.

For example:
____________________________________________
User.limit(10) # generated SQL has 'LIMIT 10'

User.limit(10).limit(20) # generated SQL has 'LIMIT 20'
____________________________________________



===================================================================
(*)===> offset : 

Specifies the number of rows to skip before returning rows.
____________________________________________
User.offset(10) # generated SQL has "OFFSET 10"
____________________________________________

Should be used with order.
____________________________________________
User.offset(10).order("name ASC")
____________________________________________



===================================================================
(*)===> optimizer_hints : Specify optimizer hints to be used in the SELECT statement.

Example (for PostgreSQL with pg_hint_plan):
____________________________________________
Topic.optimizer_hints("SeqScan(topics)", "Parallel(topics 8)")
# SELECT /*+ SeqScan(topics) Parallel(topics 8) ____________________________________________



===================================================================
(*)===> order : Applies an ORDER BY clause to a query.

order accepts arguments in one of several formats.

==> symbols
____________________________________________
User.order(:name)
# SELECT "users".* FROM "users" ORDER BY "users"."name" ASC
____________________________________________

____________________________________________
User.order(email: :desc)
# SELECT "users".* FROM "users" ORDER BY "users"."email" DESC
____________________________________________

____________________________________________
User.order(:name, email: :desc)
# SELECT "users".* FROM "users" ORDER BY "users"."name" ASC, "users"."email" DESC
____________________________________________



==> strings
____________________________________________
User.order('name')
# SELECT "users".* FROM "users" ORDER BY name

User.order('name DESC')
# SELECT "users".* FROM "users" ORDER BY name DESC

User.order('name DESC, email')
# SELECT "users".* FROM "users" ORDER BY name DESC, email
____________________________________________


==> Arel

If you need to pass in complicated expressions that you have verified are safe for the database, you can use Arel.
____________________________________________
User.order(Arel.sql('end_date - start_date'))
# SELECT "users".* FROM "users" ORDER BY end_date - start_date
____________________________________________


Custom query syntax, like JSON columns for Postgres, is supported in this way.
____________________________________________
User.order(Arel.sql("payload->>'kind'"))
# SELECT "users".* FROM "users" ORDER BY payload->>'kind'
____________________________________________



===================================================================
(*)===> preload : Allows preloading of args, in the same way that includes does.

____________________________________________
User.preload(:posts)
# SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3)
____________________________________________


===================================================================
(*)===> readonly :  This method prevents the resulting records from being modified and raises an exception if you try to save them. 

Here's an example:
____________________________________________
User.readonly.where(name: 'John')
____________________________________________


This generates the following SQL query:
____________________________________________
SELECT "users".* FROM "users" WHERE "users"."name" = 'John' FOR READ ONLY
____________________________________________



===================================================================
(*)===> references : : This method includes associated tables in the query to avoid ambiguous column references. 

Here's an example:
____________________________________________
User.includes(:posts).where("posts.name = 'foo'")
# Doesn't JOIN the posts table, resulting in an error.

User.includes(:posts).where("posts.name = 'foo'").references(:posts)
# Query now knows the string references posts, so adds a JOIN
____________________________________________


===================================================================
(*)===> reorder : 

Replaces any existing order defined on the relation with the specified order.

____________________________________________
User.order('email DESC').reorder('id ASC') # generated SQL has 'ORDER BY id ASC'
____________________________________________


Subsequent calls to order on the same relation will be appended. For example:
____________________________________________
User.order('email DESC').reorder('id ASC').order('name ASC')

## generates a query with 'ORDER BY id ASC, name ASC'.
____________________________________________



===================================================================
(*)===> reselect : Allows you to change a previously set select statement.
____________________________________________
Post.select(:title, :body)
# SELECT `posts`.`title`, `posts`.`body` FROM `posts`

Post.select(:title, :body).reselect(:created_at)
# SELECT `posts`.`created_at` FROM `posts`
____________________________________________



===================================================================
(*)===> reverse_order : Reverse the existing order clause on the relation.
____________________________________________
User.order('name ASC').reverse_order # generated SQL has 'ORDER BY name DESC'
____________________________________________


===================================================================
(*)===> select

____________________________________________
Model.all.select { |m| m.field == value }____________________________________________

## This will build an array of objects from the database for the scope, converting them into an array and iterating through them using Array#select.


____________________________________________
Model.select(:field)
# => [#<Model id: nil, field: "value">]
____________________________________________
## Modifies the SELECT statement for the query so that only certain fields are retrieved:

____________________________________________
Model.select(:field, :other_field, :and_one_more)
# => [#<Model id: nil, field: "value", other_field: "value", and_one_more: "value">]
____________________________________________

____________________________________________
Model.select('field AS field_one', 'other_field AS field_two')
# => [#<Model id: nil, field: "value", other_field: "value">]
____________________________________________

## If an alias was specified, it will be accessible from the resulting objects:
____________________________________________
Model.select('field AS field_one').first.field_one
# => "value"
____________________________________________

## Accessing attributes of an object that do not have fields retrieved by a select except id will throw ActiveModel::MissingAttributeError:
____________________________________________
Model.select(:field).first.other_field
# => ActiveModel::MissingAttributeError: missing attribute: other_field
____________________________________________



===================================================================
(*)===> where : Returns a new relation, which is the result of filtering the current relation according to the conditions in the arguments.


==> string
____________________________________________
Client.where("orders_count = '2'")
# SELECT * from clients where orders_count = '2';
____________________________________________

==> array
____________________________________________
User.where(["name = ? and email = ?", "Joe", "joe@example.com"])
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
____________________________________________

____________________________________________
User.where(["name = :name and email = :email", { name: "Joe", email: "joe@example.com" }])
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
____________________________________________

____________________________________________
User.where(["name = '%s' and email = '%s'", "Joe", "joe@example.com"])
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
____________________________________________

____________________________________________
User.where("name = :name and email = :email", { name: "Joe", email: "joe@example.com" })
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
____________________________________________


==> hash
____________________________________________
User.where(name: "Joe", email: "joe@example.com")
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com'

User.where(name: ["Alice", "Bob"])
# SELECT * FROM users WHERE name IN ('Alice', 'Bob')

User.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
# SELECT * FROM users WHERE (created_at BETWEEN '2012-06-09 07:00:00.000000' AND '2012-06-10 07:00:00.000000')
____________________________________________


In the case of a belongs_to relationship, an association key can be used to specify the model if an ActiveRecord object is used as the value.
____________________________________________
author = Author.find(1)

# The following queries will be equivalent:
Post.where(author: author)
Post.where(author_id: author)
____________________________________________


This also works with polymorphic belongs_to relationships:
____________________________________________
treasure = Treasure.create(name: 'gold coins')
treasure.price_estimates << PriceEstimate.create(price: 125)

# The following queries will be equivalent:
PriceEstimate.where(estimate_of: treasure)
PriceEstimate.where(estimate_of_type: 'Treasure', estimate_of_id: treasure)
____________________________________________


==> Joins
____________________________________________
User.joins(:posts).where("posts.created_at < ?", Time.now)
____________________________________________

____________________________________________
User.joins(:posts).where("posts.published" => true)
User.joins(:posts).where(posts: { published: true })
____________________________________________


==> no argument

## Chaining with WhereChain#not:
____________________________________________
User.where.not(name: "Jon")
# SELECT * FROM users WHERE name != 'Jon'
____________________________________________


## Chaining with WhereChain#associated:
____________________________________________
Post.where.associated(:author)
# SELECT "posts".* FROM "posts"
# INNER JOIN "authors" ON "authors"."id" = "posts"."author_id"
# WHERE "authors"."id" IS NOT NULL
____________________________________________

## Chaining with WhereChain#missing:
____________________________________________
Post.where.missing(:author)
# SELECT "posts".* FROM "posts"
# LEFT OUTER JOIN "authors" ON "authors"."id" = "posts"."author_id"
# WHERE "authors"."id" IS NULL
____________________________________________


==> blank condition
If the condition is any blank-ish object, then where is a no-op and returns the current relation.



===================================================================
(*)===> take

The take method retrieves a record without any implicit ordering. 
____________________________________________
irb> customer = Customer.take
=> #<Customer id: 1, first_name: "Lifo">
____________________________________________

The SQL equivalent of the above is:
____________________________________________
SELECT * FROM customers LIMIT 1
____________________________________________

## The take method returns nil if no record is found and no exception will be raised.

____________________________________________
irb> customers = Customer.take(2)
=> [#<Customer id: 1, first_name: "Lifo">, #<Customer id: 220, first_name: "Sara">]
____________________________________________

##  The take! method behaves exactly like take, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.




===================================================================
(*)===> first : The first method finds the first record ordered by primary key (default). 
____________________________________________
irb> customer = Customer.first
=> #<Customer id: 1, first_name: "Lifo">
____________________________________________

The SQL equivalent of the above is:
____________________________________________
SELECT * FROM customers ORDER BY customers.id ASC LIMIT 1
____________________________________________

## The first method returns nil if no matching record is found and no exception will be raised

____________________________________________
irb> customers = Customer.first(3)
=> [#<Customer id: 1, first_name: "Lifo">, #<Customer id: 2, first_name: "Fifo">, #<Customer id: 3, first_name: "Filo">]
____________________________________________

____________________________________________
irb> customer = Customer.order(:first_name).first
=> #<Customer id: 2, first_name: "Fifo">
____________________________________________

## The first! method behaves exactly like first, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.


===================================================================
(*)===> last : The last method finds the last record ordered by primary key (default).

____________________________________________
irb> customer = Customer.last
=> #<Customer id: 221, first_name: "Russel">
____________________________________________

The SQL equivalent of the above is:
____________________________________________
SELECT * FROM customers ORDER BY customers.id DESC LIMIT 1
____________________________________________

## The last method returns nil if no matching record is found and no exception will be raised.

## If your default scope contains an order method, last will return the last record according to this ordering.


____________________________________________
irb> customers = Customer.last(3)
=> [#<Customer id: 219, first_name: "James">, #<Customer id: 220, first_name: "Sara">, #<Customer id: 221, first_name: "Russel">]
____________________________________________

____________________________________________
irb> customer = Customer.order(:first_name).last
=> #<Customer id: 220, first_name: "Sara">
____________________________________________

## The last! method behaves exactly like last, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.



===================================================================
(*)===> find_by : The find_by method finds the first record matching some conditions. 

____________________________________________
irb> Customer.find_by first_name: 'Lifo'
=> #<Customer id: 1, first_name: "Lifo">

irb> Customer.find_by first_name: 'Jon'
=> nil
____________________________________________


It is equivalent to writing:
____________________________________________
Customer.where(first_name: 'Lifo').take
____________________________________________

The SQL equivalent of the above is:
____________________________________________
SELECT * FROM customers WHERE (customers.first_name = 'Lifo') LIMIT 1
____________________________________________

## The find_by! method behaves exactly like find_by, except that it will raise ActiveRecord::RecordNotFound if no matching record is found. 

___________________________________________________________________

############### Retrieving Multiple Objects in Batches ###############

## The find_each and find_in_batches methods are intended for use in the batch processing of a large number of records that wouldn't fit in memory all at once. 

If you just need to loop over a thousand records the regular find methods are the preferred option.

(*)===> find_each

The find_each method retrieves records in batches and then yields each one to the block. 

In the following example, find_each retrieves customers in batches of 1000 and yields them to the block one by one:
____________________________________________
Customer.find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________


find_each works on model classes, as seen above, and also on relations:
____________________________________________
Customer.where(weekly_subscriber: true).find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________

          Options for find_each

 :batch_size

The :batch_size option allows you to specify the number of records to be retrieved in each batch, before being passed individually to the block. 

For example, to retrieve records in batches of 5000:
____________________________________________
Customer.find_each(batch_size: 5000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________


:start

By default, records are fetched in ascending order of the primary key. 
The :start option allows you to configure the first ID of the sequence whenever the lowest ID is not the one you need.

This would be useful, for example, if you wanted to resume an interrupted batch process, provided you saved the last processed ID as a checkpoint.

For example, to send newsletters only to customers with the primary key starting from 2000:
____________________________________________
Customer.find_each(start: 2000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________




:finish

Similar to the :start option, :finish allows you to configure the last ID of the sequence whenever the highest ID is not the one you need. 
This would be useful, for example, if you wanted to run a batch process using a subset of records based on :start and :finish.

For example, to send newsletters only to customers with the primary key starting from 2000 up to 10000:
____________________________________________
Customer.find_each(start: 2000, finish: 10000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________


:error_on_ignore
The :error_on_ignore option is used to override the application configuration and specify whether an error should be raised when an order is present in the relation.

By default, Rails ignores the order clause when using the includes method to eagerly load associations. This behavior can be changed globally in the application configuration by setting config.active_record.raise_on_order_by_clause to true. However, if you only want to change this behavior for a specific relation, you can pass the :error_on_ignore option to the includes method.

When :error_on_ignore is set to true, Rails will raise an ActiveRecord::StatementInvalid error if an order clause is present in the relation and is being ignored by the includes method. Here's an example:

____________________________________________
class Post < ActiveRecord::Base
  has_many :comments
end

class Comment < ActiveRecord::Base
  belongs_to :post
end

# Assume there are 10 posts in the database, each with 5 comments

# This will eagerly load all comments for the posts, ignoring any order clause on the comments association
posts = Post.includes(:comments)

# This will raise an ActiveRecord::StatementInvalid error because the order clause on the comments association is being ignored
posts = Post.includes(:comments).order('comments.created_at DESC').merge(Comment.order('created_at ASC').limit(5)).references(:comments).error_on_ignore(true)
____________________________________________


===================================================================
(*)===> find_in_batches

The find_in_batches method is similar to find_each,
since both retrieve batches of records. 

The difference is that find_in_batches yields batches to the block as an array of models, instead of individually. 

The following example will yield to the supplied block an array of up to 1000 customers at a time, with the final block containing any remaining customers:

____________________________________________
# Give add_customers an array of 1000 customers at a time.
Customer.find_in_batches do |customers|
  export.add_customers(customers)
end
____________________________________________


find_in_batches works on model classes, as seen above, and also on relations:
____________________________________________
# Give add_customers an array of 1000 recently active customers at a time.
Customer.recently_active.find_in_batches do |customers|
  export.add_customers(customers)
end
____________________________________________


       Options for find_in_batches


       
:batch_size

Just like for find_each, batch_size establishes how many records will be retrieved in each group. 

For example, retrieving batches of 2500 records can be specified as:
____________________________________________
Customer.find_in_batches(batch_size: 2500) do |customers|
  export.add_customers(customers)
end
____________________________________________


:start

____________________________________________
Customer.find_in_batches(batch_size: 2500, start: 5000) do |customers|
  export.add_customers(customers)
end
____________________________________________


:finish
____________________________________________
Customer.find_in_batches(finish: 7000) do |customers|
  export.add_customers(customers)
end
____________________________________________



:error_on_ignore
____________________________________________
The error_on_ignore option overrides the application config to specify if an error should be raised when a specific order is present in the relation.
____________________________________________


___________________________________________________________________

############### Conditions ###############

===================================================================
(*)===> Pure String Conditions
____________________________________________
Book.where("title = 'Introduction to Algorithms'")
____________________________________________

## Building your own conditions as pure strings can leave you vulnerable to SQL injection exploits. 

For example, 
Book.where("title LIKE '%#{params[:title]}%'")
is not safe.


===================================================================
(*)===> Array Conditions
____________________________________________
Book.where("title = ?", params[:title])
____________________________________________

____________________________________________
Book.where("title = ? AND out_of_print = ?", params[:title], false)
____________________________________________




This code is highly preferable:
____________________________________________
Book.where("title = ?", params[:title])
____________________________________________
to this code:
____________________________________________
Book.where("title = #{params[:title]}")
____________________________________________
because of argument safety. 
Putting the variable directly into the conditions string will pass the variable to the database as-is. 
This means that it will be an unescaped variable directly from a user who may have malicious intent. 
If you do this, you put your entire database at risk because once a user finds out they can exploit your database they can do just about anything to it. 
Never ever put your arguments directly inside the conditions string.



// Placeholder Conditions
____________________________________________
Book.where("created_at >= :start_date AND created_at <= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
____________________________________________



// Conditions That Use LIKE
____________________________________________
Book.where("title LIKE ?", params[:title] + "%")
____________________________________________
In the above code, the intent is to match titles that start with a user-specified string. 
However, any occurrences of % or _ in params[:title] will be treated as wildcards, leading to surprising query results. 
In some circumstances, this may also prevent the database from using an intended index, leading to a much slower query.

To avoid these problems, use sanitize_sql_like to escape wildcard characters in the relevant portion of the argument:
____________________________________________
Book.where("title LIKE ?",
  Book.sanitize_sql_like(params[:title]) + "%")
____________________________________________



===================================================================
(*)===> Hash Conditions

// Equality Conditions
____________________________________________
Book.where(out_of_print: true)
____________________________________________
 or
____________________________________________
Book.where('out_of_print' => true)
____________________________________________
 

This will generate SQL like this:
____________________________________________
SELECT * FROM books WHERE (books.out_of_print = 1)
____________________________________________



// In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. 
This method works with polymorphic relationships as well.
____________________________________________
author = Author.first
Book.where(author: author)
Author.joins(:books).where(books: { author: author })
____________________________________________




// Range Conditions
____________________________________________
Book.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
____________________________________________
____________________________________________
SELECT * FROM books WHERE (books.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
____________________________________________


____________________________________________
Book.where(created_at: (Time.now.midnight - 1.day)..)
____________________________________________
____________________________________________
SELECT * FROM books WHERE books.created_at >= '2008-12-21 00:00:00'
____________________________________________


// Subset Conditions
____________________________________________
Customer.where(orders_count: [1,3,5])
____________________________________________
____________________________________________
SELECT * FROM customers WHERE (customers.orders_count IN (1,3,5))
____________________________________________



===================================================================
(*)===> NOT Conditions
____________________________________________
Customer.where.not(orders_count: [1,3,5])
____________________________________________
____________________________________________
SELECT * FROM customers WHERE (customers.orders_count NOT IN (1,3,5))
____________________________________________


____________________________________________
Customer.create!(nullable_contry: nil)
Customer.where.not(nullable_country: "UK")
=> []
# But
Customer.create!(nullable_contry: "UK")
Customer.where.not(nullable_country: nil)
=> [#<Customer id: 2, nullable_contry: "UK">]
____________________________________________

===================================================================
(*)===> OR Conditions
____________________________________________
Customer.where(last_name: 'Smith').or(Customer.where(orders_count: [1,3,5]))
____________________________________________
____________________________________________
SELECT * FROM customers WHERE (customers.last_name = 'Smith' OR customers.orders_count IN (1,3,5))
____________________________________________





===================================================================
(*)===>  AND Conditions
____________________________________________
Customer.where(last_name: 'Smith').where(orders_count: [1,3,5]))
____________________________________________
____________________________________________
SELECT * FROM customers WHERE customers.last_name = 'Smith' AND customers.orders_count IN (1,3,5)
____________________________________________


____________________________________________
Customer.where(id: [1, 2]).and(Customer.where(id: [2, 3]))
____________________________________________
____________________________________________
SELECT * FROM customers WHERE (customers.id IN (1, 2) AND customers.id IN (2, 3))
____________________________________________



###############  ###############
===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________



___________________________________________________________________

############### END ###############

(*)===>
____________________________________________
____________________________________________

(*)===>
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


