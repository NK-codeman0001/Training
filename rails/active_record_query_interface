---------------------------------------------------------------------
               			Active Record Query Interface
---------------------------------------------------------------------
Active Record will perform queries on the database for you and is compatible with most database systems, including MySQL, MariaDB, PostgreSQL, and SQLite. Regardless of which database system you're using, the Active Record method format will always be the same.

## All of the following models use id as the primary key, unless specified otherwise.

___________________________________________________________________

    Retrieving Objects from the Database
___________________________________________________________________

############### Retrieving a Single Object ###############
Active Record provides several finder methods

(*)===> annotate : Adds an SQL comment to queries generated from this relation.
____________________________________________
User.annotate("selecting user names").select(:name)
# SELECT "users"."name" FROM "users" /* selecting user names */

User.annotate("selecting", "user", "names").select(:name)
# SELECT "users"."name" FROM "users" /* selecting */ /* user */ /* names */
____________________________________________


===================================================================
(*)===> find : Using the find method, you can retrieve the object corresponding to the specified primary key that matches any supplied options. 

Find by id - This can either be a specific id (1), 
a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]). 

If one or more records cannot be found for the requested ids, then ActiveRecord::RecordNotFound will be raised. 
If the primary key is an integer, find by id coerces its arguments by using to_i.

____________________________________________
Person.find(1)          # returns the object for ID = 1
Person.find("1")        # returns the object for ID = 1
Person.find("31-sarah") # returns the object for ID = 31
Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6)
Person.find([7, 17])    # returns an array for objects with IDs in (7, 17)
Person.find([1])        # returns an array for the object with ID = 1
Person.where("administrator = 1").order("created_on DESC").find(1)
____________________________________________


===================================================================
(*)===> create_with : Sets attributes to be used when creating new records from a relation object.
____________________________________________
users = User.where(name: 'Oscar')
users.new.name # => 'Oscar'

users = users.create_with(name: 'DHH')
users.new.name # => 'DHH'
____________________________________________


You can pass nil to create_with to reset attributes:
____________________________________________
users = users.create_with(nil)
users.new.name # => 'Oscar'
____________________________________________



===================================================================
(*)===> distinct : Specifies whether the records should be unique or not. 

For example:
____________________________________________
User.select(:name)
# Might return two records with the same name

User.select(:name).distinct
# Returns 1 record per distinct name

User.select(:name).distinct.distinct(false)
# You can also remove the uniqueness
____________________________________________


===================================================================
(*)===> eager_load : loads associated records in a single query
Forces eager loading by performing a LEFT OUTER JOIN on args:
____________________________________________
User.eager_load(:posts)
# SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, ...
# FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" =
# "users"."id"
____________________________________________

===================================================================
(*)===> extending : adds methods to a relation object
____________________________________________
# Example
User.where(name: 'John').extending(User::CustomMethods)

# Result
# [Custom methods added to the relation object]
____________________________________________

Used to extend a scope with additional methods, either through a module or through a block provided.

The object returned is a relation, which can be further extended.


  ==> Using a module
    ____________________________________________
    module Pagination
      def page(number)
        # pagination code goes here
      end
    end

    scope = Model.all.extending(Pagination)
    scope.page(params[:page])
    ____________________________________________

            or
 
  You can also pass a list of modules:
    ____________________________________________
     scope = Model.all.extending(Pagination, SomethingElse)
    ____________________________________________


  ==> Using a block
    ____________________________________________
    scope = Model.all.extending do
      def page(number)
        # pagination code goes here
      end
    end
    scope.page(params[:page])
    ____________________________________________

                      or
  You can also use a block and a module list:
    ____________________________________________
    scope = Model.all.extending(Pagination) do
      def per_page(number)
        # pagination code goes here
      end
    end
    ____________________________________________


===================================================================
(*)===> extract_associated
Extracts a named association from the relation. The named association is first preloaded, then the individual association records are collected from the relation. 

Like so:
____________________________________________
account.memberships.extract_associated(:user)
# => Returns collection of User records
____________________________________________

This is short-hand for:
____________________________________________
account.memberships.preload(:user).collect(&:user)
____________________________________________



===================================================================
(*)===> from : 

Specifies the table from which the records will be fetched. For example:

____________________________________________
Topic.select('title').from('posts')
# SELECT title FROM posts
____________________________________________


Can accept other relation objects. For example:
____________________________________________
Topic.select('title').from(Topic.approved)
# SELECT title FROM (SELECT * FROM topics WHERE approved = 't') subquery
____________________________________________


Passing a second argument (string or symbol), creates the alias for the SQL from clause. Otherwise the alias “subquery” is used:
____________________________________________
Topic.select('a.title').from(Topic.approved, :a)
# SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a
____________________________________________


It does not add multiple arguments to the SQL from clause. The last from chained is the one used:
____________________________________________
Topic.select('title').from(Topic.approved).from(Topic.inactive)
# SELECT title FROM (SELECT topics.* FROM topics WHERE topics.active = 'f') subquery
____________________________________________



For multiple arguments for the SQL from clause, you can pass a string with the exact elements in the SQL from list:

____________________________________________
color = "red"
Color
  .from("colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)")
  .where("colorvalue->>'color' = ?", color)
  .select("c.*").to_a
# SELECT c.*
# FROM colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)
# WHERE (colorvalue->>'color' = 'red')
____________________________________________



===================================================================
(*)===> group : 

Allows to specify a group attribute:
____________________________________________
User.group(:name)
# SELECT "users".* FROM "users" GROUP BY name
____________________________________________


Returns an array with distinct records based on the group attribute:
____________________________________________
User.select([:id, :name])
# => [#<User id: 1, name: "Oscar">, #<User id: 2, name: "Oscar">, #<User id: 3, name: "Foo">]
____________________________________________

____________________________________________
User.group(:name)
# => [#<User id: 3, name: "Foo", ...>, #<User id: 2, name: "Oscar", ...>]
____________________________________________

____________________________________________
User.group('name AS grouped_name, age')
# => [#<User id: 3, name: "Foo", age: 21, ...>, #<User id: 2, name: "Oscar", age: 21, ...>, #<User id: 5, name: "Foo", age: 23, ...>]
____________________________________________


Passing in an array of attributes to group by is also supported.
____________________________________________
User.select([:id, :first_name]).group(:id, :first_name).first(3)
# => [#<User id: 1, first_name: "Bill">, #<User id: 2, first_name: "Earl">, #<User id: 3, first_name: "Beto">]
____________________________________________




===================================================================
(*)===> having : Allows to specify a HAVING clause. Note that you can't use HAVING without also specifying a GROUP clause.
____________________________________________
Order.having('SUM(price) > 30').group('user_id')
____________________________________________



===================================================================
(*)===> includes : 

Specify relationships to be included in the result set. For example:
____________________________________________
users = User.includes(:address)
users.each do |user|
  user.address.city
end
____________________________________________

allows you to access the address attribute of the User model without firing an additional query. This will often result in a performance improvement over a simple join.


You can also specify multiple relationships, like this:
____________________________________________
users = User.includes(:address, :friends)
____________________________________________


Loading nested relationships is possible using a Hash:
____________________________________________
users = User.includes(:address, friends: [:address, :followers])
____________________________________________


===Conditions===
If you want to add string conditions to your included models, you'll have to explicitly reference them. 
For example:
____________________________________________
User.includes(:posts).where('posts.name = ?', 'example')
____________________________________________

Will throw an error, but this will work:
____________________________________________
User.includes(:posts).where('posts.name = ?', 'example').references(:posts)
____________________________________________

## Note that includes works with association names while references needs the actual table name.

If you pass the conditions via hash, you don't need to call references explicitly, as where references the tables for you. 
For example, this will work correctly:
____________________________________________
User.includes(:posts).where(posts: { name: 'example' })
____________________________________________



===================================================================
(*)===> joins : 

Performs JOINs on args. The given symbol(s) should match the name of the association(s).
____________________________________________
User.joins(:posts)
# SELECT "users".*
# FROM "users"
# INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
____________________________________________


Multiple joins:
____________________________________________
User.joins(:posts, :account)
# SELECT "users".*
# FROM "users"
# INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
# INNER JOIN "accounts" ON "accounts"."id" = "users"."account_id"
____________________________________________


Nested joins:
____________________________________________
User.joins(posts: [:comments])
# SELECT "users".*
# FROM "users"
# INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
# INNER JOIN "comments" ON "comments"."post_id" = "posts"."id"
____________________________________________

You can use strings in order to customize your joins:
____________________________________________
User.joins("LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id")
# SELECT "users".* FROM "users" LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id
____________________________________________



===================================================================
(*)===> left_outer_joins || left_joins

Performs LEFT OUTER JOINs on args.
____________________________________________
User.left_outer_joins(:posts)
=> SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
____________________________________________



===================================================================
(*)===> limit : Specifies a limit for the number of records to retrieve.
____________________________________________
User.limit(10) # generated SQL has 'LIMIT 10'

User.limit(10).limit(20) # generated SQL has 'LIMIT 20'
____________________________________________



===================================================================
(*)===> lock : This method locks the selected records in the database to prevent other transactions from modifying them until the current transaction is complete. 

Here's an example:
____________________________________________
User.where(name: 'John').lock
____________________________________________

This generates the following SQL query:
____________________________________________
SELECT "users".* FROM "users" WHERE "users"."name" = 'John' FOR UPDATE
____________________________________________



===================================================================
(*)===> none : Returns a chainable relation with zero records.

The returned relation implements the Null Object pattern. It is an object with defined null behavior and always returns an empty array of records without querying the database.

Any subsequent condition chained to the returned relation will continue generating an empty relation and will not fire any query to the database.

Used in cases where a method or scope could return zero records but the result needs to be chainable.

For example:
____________________________________________
User.limit(10) # generated SQL has 'LIMIT 10'

User.limit(10).limit(20) # generated SQL has 'LIMIT 20'
____________________________________________



===================================================================
(*)===> offset : 

Specifies the number of rows to skip before returning rows.
____________________________________________
User.offset(10) # generated SQL has "OFFSET 10"
____________________________________________

Should be used with order.
____________________________________________
User.offset(10).order("name ASC")
____________________________________________



===================================================================
(*)===> optimizer_hints : Specify optimizer hints to be used in the SELECT statement.

Example (for PostgreSQL with pg_hint_plan):
____________________________________________
Topic.optimizer_hints("SeqScan(topics)", "Parallel(topics 8)")
# SELECT /*+ SeqScan(topics) Parallel(topics 8) ____________________________________________



===================================================================
(*)===> order : Applies an ORDER BY clause to a query.

order accepts arguments in one of several formats.

==> symbols
____________________________________________
User.order(:name)
# SELECT "users".* FROM "users" ORDER BY "users"."name" ASC
____________________________________________

____________________________________________
User.order(email: :desc)
# SELECT "users".* FROM "users" ORDER BY "users"."email" DESC
____________________________________________

____________________________________________
User.order(:name, email: :desc)
# SELECT "users".* FROM "users" ORDER BY "users"."name" ASC, "users"."email" DESC
____________________________________________



==> strings
____________________________________________
User.order('name')
# SELECT "users".* FROM "users" ORDER BY name

User.order('name DESC')
# SELECT "users".* FROM "users" ORDER BY name DESC

User.order('name DESC, email')
# SELECT "users".* FROM "users" ORDER BY name DESC, email
____________________________________________


==> Arel

If you need to pass in complicated expressions that you have verified are safe for the database, you can use Arel.
____________________________________________
User.order(Arel.sql('end_date - start_date'))
# SELECT "users".* FROM "users" ORDER BY end_date - start_date
____________________________________________


Custom query syntax, like JSON columns for Postgres, is supported in this way.
____________________________________________
User.order(Arel.sql("payload->>'kind'"))
# SELECT "users".* FROM "users" ORDER BY payload->>'kind'
____________________________________________



===================================================================
(*)===> preload : Allows preloading of args, in the same way that includes does.

____________________________________________
User.preload(:posts)
# SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3)
____________________________________________


===================================================================
(*)===> readonly :  This method prevents the resulting records from being modified and raises an exception if you try to save them. 

Here's an example:
____________________________________________
User.readonly.where(name: 'John')
____________________________________________


This generates the following SQL query:
____________________________________________
SELECT "users".* FROM "users" WHERE "users"."name" = 'John' FOR READ ONLY
____________________________________________



===================================================================
(*)===> references : : This method includes associated tables in the query to avoid ambiguous column references. 

Here's an example:
____________________________________________
User.includes(:posts).where("posts.name = 'foo'")
# Doesn't JOIN the posts table, resulting in an error.

User.includes(:posts).where("posts.name = 'foo'").references(:posts)
# Query now knows the string references posts, so adds a JOIN
____________________________________________


===================================================================
(*)===> reorder : 

Replaces any existing order defined on the relation with the specified order.

____________________________________________
User.order('email DESC').reorder('id ASC') # generated SQL has 'ORDER BY id ASC'
____________________________________________


Subsequent calls to order on the same relation will be appended. For example:
____________________________________________
User.order('email DESC').reorder('id ASC').order('name ASC')

## generates a query with 'ORDER BY id ASC, name ASC'.
____________________________________________



===================================================================
(*)===> reselect : Allows you to change a previously set select statement.
____________________________________________
Post.select(:title, :body)
# SELECT `posts`.`title`, `posts`.`body` FROM `posts`

Post.select(:title, :body).reselect(:created_at)
# SELECT `posts`.`created_at` FROM `posts`
____________________________________________



===================================================================
(*)===> reverse_order : Reverse the existing order clause on the relation.
____________________________________________
User.order('name ASC').reverse_order # generated SQL has 'ORDER BY name DESC'
____________________________________________


===================================================================
(*)===> select

____________________________________________
Model.all.select { |m| m.field == value }____________________________________________

## This will build an array of objects from the database for the scope, converting them into an array and iterating through them using Array#select.


____________________________________________
Model.select(:field)
# => [#<Model id: nil, field: "value">]
____________________________________________
## Modifies the SELECT statement for the query so that only certain fields are retrieved:

____________________________________________
Model.select(:field, :other_field, :and_one_more)
# => [#<Model id: nil, field: "value", other_field: "value", and_one_more: "value">]
____________________________________________

____________________________________________
Model.select('field AS field_one', 'other_field AS field_two')
# => [#<Model id: nil, field: "value", other_field: "value">]
____________________________________________

## If an alias was specified, it will be accessible from the resulting objects:
____________________________________________
Model.select('field AS field_one').first.field_one
# => "value"
____________________________________________

## Accessing attributes of an object that do not have fields retrieved by a select except id will throw ActiveModel::MissingAttributeError:
____________________________________________
Model.select(:field).first.other_field
# => ActiveModel::MissingAttributeError: missing attribute: other_field
____________________________________________



===================================================================
(*)===> where : Returns a new relation, which is the result of filtering the current relation according to the conditions in the arguments.


==> string
____________________________________________
Client.where("orders_count = '2'")
# SELECT * from clients where orders_count = '2';
____________________________________________

==> array
____________________________________________
User.where(["name = ? and email = ?", "Joe", "joe@example.com"])
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
____________________________________________

____________________________________________
User.where(["name = :name and email = :email", { name: "Joe", email: "joe@example.com" }])
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
____________________________________________

____________________________________________
User.where(["name = '%s' and email = '%s'", "Joe", "joe@example.com"])
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
____________________________________________

____________________________________________
User.where("name = :name and email = :email", { name: "Joe", email: "joe@example.com" })
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
____________________________________________


==> hash
____________________________________________
User.where(name: "Joe", email: "joe@example.com")
# SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com'

User.where(name: ["Alice", "Bob"])
# SELECT * FROM users WHERE name IN ('Alice', 'Bob')

User.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
# SELECT * FROM users WHERE (created_at BETWEEN '2012-06-09 07:00:00.000000' AND '2012-06-10 07:00:00.000000')
____________________________________________


In the case of a belongs_to relationship, an association key can be used to specify the model if an ActiveRecord object is used as the value.
____________________________________________
author = Author.find(1)

# The following queries will be equivalent:
Post.where(author: author)
Post.where(author_id: author)
____________________________________________


This also works with polymorphic belongs_to relationships:
____________________________________________
treasure = Treasure.create(name: 'gold coins')
treasure.price_estimates << PriceEstimate.create(price: 125)

# The following queries will be equivalent:
PriceEstimate.where(estimate_of: treasure)
PriceEstimate.where(estimate_of_type: 'Treasure', estimate_of_id: treasure)
____________________________________________


==> Joins
____________________________________________
User.joins(:posts).where("posts.created_at < ?", Time.now)
____________________________________________

____________________________________________
User.joins(:posts).where("posts.published" => true)
User.joins(:posts).where(posts: { published: true })
____________________________________________


==> no argument

## Chaining with WhereChain#not:
____________________________________________
User.where.not(name: "Jon")
# SELECT * FROM users WHERE name != 'Jon'
____________________________________________


## Chaining with WhereChain#associated:
____________________________________________
Post.where.associated(:author)
# SELECT "posts".* FROM "posts"
# INNER JOIN "authors" ON "authors"."id" = "posts"."author_id"
# WHERE "authors"."id" IS NOT NULL
____________________________________________

## Chaining with WhereChain#missing:
____________________________________________
Post.where.missing(:author)
# SELECT "posts".* FROM "posts"
# LEFT OUTER JOIN "authors" ON "authors"."id" = "posts"."author_id"
# WHERE "authors"."id" IS NULL
____________________________________________


==> blank condition
If the condition is any blank-ish object, then where is a no-op and returns the current relation.



===================================================================
(*)===> take

The take method retrieves a record without any implicit ordering. 
____________________________________________
irb> customer = Customer.take
=> #<Customer id: 1, first_name: "Lifo">
____________________________________________

The SQL equivalent of the above is:
____________________________________________
SELECT * FROM customers LIMIT 1
____________________________________________

## The take method returns nil if no record is found and no exception will be raised.

____________________________________________
irb> customers = Customer.take(2)
=> [#<Customer id: 1, first_name: "Lifo">, #<Customer id: 220, first_name: "Sara">]
____________________________________________

##  The take! method behaves exactly like take, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.




===================================================================
(*)===> first : The first method finds the first record ordered by primary key (default). 
____________________________________________
irb> customer = Customer.first
=> #<Customer id: 1, first_name: "Lifo">
____________________________________________

The SQL equivalent of the above is:
____________________________________________
SELECT * FROM customers ORDER BY customers.id ASC LIMIT 1
____________________________________________

## The first method returns nil if no matching record is found and no exception will be raised

____________________________________________
irb> customers = Customer.first(3)
=> [#<Customer id: 1, first_name: "Lifo">, #<Customer id: 2, first_name: "Fifo">, #<Customer id: 3, first_name: "Filo">]
____________________________________________

____________________________________________
irb> customer = Customer.order(:first_name).first
=> #<Customer id: 2, first_name: "Fifo">
____________________________________________

## The first! method behaves exactly like first, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.


===================================================================
(*)===> last : The last method finds the last record ordered by primary key (default).

____________________________________________
irb> customer = Customer.last
=> #<Customer id: 221, first_name: "Russel">
____________________________________________

The SQL equivalent of the above is:
____________________________________________
SELECT * FROM customers ORDER BY customers.id DESC LIMIT 1
____________________________________________

## The last method returns nil if no matching record is found and no exception will be raised.

## If your default scope contains an order method, last will return the last record according to this ordering.


____________________________________________
irb> customers = Customer.last(3)
=> [#<Customer id: 219, first_name: "James">, #<Customer id: 220, first_name: "Sara">, #<Customer id: 221, first_name: "Russel">]
____________________________________________

____________________________________________
irb> customer = Customer.order(:first_name).last
=> #<Customer id: 220, first_name: "Sara">
____________________________________________

## The last! method behaves exactly like last, except that it will raise ActiveRecord::RecordNotFound if no matching record is found.



===================================================================
(*)===> find_by : The find_by method finds the first record matching some conditions. 

____________________________________________
irb> Customer.find_by first_name: 'Lifo'
=> #<Customer id: 1, first_name: "Lifo">

irb> Customer.find_by first_name: 'Jon'
=> nil
____________________________________________


It is equivalent to writing:
____________________________________________
Customer.where(first_name: 'Lifo').take
____________________________________________

The SQL equivalent of the above is:
____________________________________________
SELECT * FROM customers WHERE (customers.first_name = 'Lifo') LIMIT 1
____________________________________________

## The find_by! method behaves exactly like find_by, except that it will raise ActiveRecord::RecordNotFound if no matching record is found. 

___________________________________________________________________

############### Retrieving Multiple Objects in Batches ###############

## The find_each and find_in_batches methods are intended for use in the batch processing of a large number of records that wouldn't fit in memory all at once. 

If you just need to loop over a thousand records the regular find methods are the preferred option.

(*)===> find_each

The find_each method retrieves records in batches and then yields each one to the block. 

In the following example, find_each retrieves customers in batches of 1000 and yields them to the block one by one:
____________________________________________
Customer.find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________


find_each works on model classes, as seen above, and also on relations:
____________________________________________
Customer.where(weekly_subscriber: true).find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________

          Options for find_each

 :batch_size

The :batch_size option allows you to specify the number of records to be retrieved in each batch, before being passed individually to the block. 

For example, to retrieve records in batches of 5000:
____________________________________________
Customer.find_each(batch_size: 5000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________


:start

By default, records are fetched in ascending order of the primary key. 
The :start option allows you to configure the first ID of the sequence whenever the lowest ID is not the one you need.

This would be useful, for example, if you wanted to resume an interrupted batch process, provided you saved the last processed ID as a checkpoint.

For example, to send newsletters only to customers with the primary key starting from 2000:
____________________________________________
Customer.find_each(start: 2000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________




:finish

Similar to the :start option, :finish allows you to configure the last ID of the sequence whenever the highest ID is not the one you need. 
This would be useful, for example, if you wanted to run a batch process using a subset of records based on :start and :finish.

For example, to send newsletters only to customers with the primary key starting from 2000 up to 10000:
____________________________________________
Customer.find_each(start: 2000, finish: 10000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
____________________________________________


:error_on_ignore
The :error_on_ignore option is used to override the application configuration and specify whether an error should be raised when an order is present in the relation.

By default, Rails ignores the order clause when using the includes method to eagerly load associations. This behavior can be changed globally in the application configuration by setting config.active_record.raise_on_order_by_clause to true. However, if you only want to change this behavior for a specific relation, you can pass the :error_on_ignore option to the includes method.

When :error_on_ignore is set to true, Rails will raise an ActiveRecord::StatementInvalid error if an order clause is present in the relation and is being ignored by the includes method. Here's an example:

____________________________________________
class Post < ActiveRecord::Base
  has_many :comments
end

class Comment < ActiveRecord::Base
  belongs_to :post
end

# Assume there are 10 posts in the database, each with 5 comments

# This will eagerly load all comments for the posts, ignoring any order clause on the comments association
posts = Post.includes(:comments)

# This will raise an ActiveRecord::StatementInvalid error because the order clause on the comments association is being ignored
posts = Post.includes(:comments).order('comments.created_at DESC').merge(Comment.order('created_at ASC').limit(5)).references(:comments).error_on_ignore(true)
____________________________________________


===================================================================
(*)===> find_in_batches

The find_in_batches method is similar to find_each,
since both retrieve batches of records. 

The difference is that find_in_batches yields batches to the block as an array of models, instead of individually. 

The following example will yield to the supplied block an array of up to 1000 customers at a time, with the final block containing any remaining customers:

____________________________________________
# Give add_customers an array of 1000 customers at a time.
Customer.find_in_batches do |customers|
  export.add_customers(customers)
end
____________________________________________


find_in_batches works on model classes, as seen above, and also on relations:
____________________________________________
# Give add_customers an array of 1000 recently active customers at a time.
Customer.recently_active.find_in_batches do |customers|
  export.add_customers(customers)
end
____________________________________________


       Options for find_in_batches


       
:batch_size

Just like for find_each, batch_size establishes how many records will be retrieved in each group. 

For example, retrieving batches of 2500 records can be specified as:
____________________________________________
Customer.find_in_batches(batch_size: 2500) do |customers|
  export.add_customers(customers)
end
____________________________________________


:start

____________________________________________
Customer.find_in_batches(batch_size: 2500, start: 5000) do |customers|
  export.add_customers(customers)
end
____________________________________________


:finish
____________________________________________
Customer.find_in_batches(finish: 7000) do |customers|
  export.add_customers(customers)
end
____________________________________________



:error_on_ignore
____________________________________________
The error_on_ignore option overrides the application config to specify if an error should be raised when a specific order is present in the relation.
____________________________________________


___________________________________________________________________

############### Conditions ###############

===================================================================
(*)===> Pure String Conditions
____________________________________________
Book.where("title = 'Introduction to Algorithms'")
____________________________________________

## Building your own conditions as pure strings can leave you vulnerable to SQL injection exploits. 

For example, 
Book.where("title LIKE '%#{params[:title]}%'")
is not safe.


===================================================================
(*)===> Array Conditions
____________________________________________
Book.where("title = ?", params[:title])
____________________________________________

____________________________________________
Book.where("title = ? AND out_of_print = ?", params[:title], false)
____________________________________________




This code is highly preferable:
____________________________________________
Book.where("title = ?", params[:title])
____________________________________________
to this code:
____________________________________________
Book.where("title = #{params[:title]}")
____________________________________________
because of argument safety. 
Putting the variable directly into the conditions string will pass the variable to the database as-is. 
This means that it will be an unescaped variable directly from a user who may have malicious intent. 
If you do this, you put your entire database at risk because once a user finds out they can exploit your database they can do just about anything to it. 
Never ever put your arguments directly inside the conditions string.



// Placeholder Conditions
____________________________________________
Book.where("created_at >= :start_date AND created_at <= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
____________________________________________



// Conditions That Use LIKE
____________________________________________
Book.where("title LIKE ?", params[:title] + "%")
____________________________________________
In the above code, the intent is to match titles that start with a user-specified string. 
However, any occurrences of % or _ in params[:title] will be treated as wildcards, leading to surprising query results. 
In some circumstances, this may also prevent the database from using an intended index, leading to a much slower query.

To avoid these problems, use sanitize_sql_like to escape wildcard characters in the relevant portion of the argument:
____________________________________________
Book.where("title LIKE ?",
  Book.sanitize_sql_like(params[:title]) + "%")
____________________________________________



===================================================================
(*)===> Hash Conditions

// Equality Conditions
____________________________________________
Book.where(out_of_print: true)
____________________________________________
 or
____________________________________________
Book.where('out_of_print' => true)
____________________________________________
 

This will generate SQL like this:
____________________________________________
SELECT * FROM books WHERE (books.out_of_print = 1)
____________________________________________



// In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. 
This method works with polymorphic relationships as well.
____________________________________________
author = Author.first
Book.where(author: author)
Author.joins(:books).where(books: { author: author })
____________________________________________




// Range Conditions
____________________________________________
Book.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
____________________________________________
____________________________________________
SELECT * FROM books WHERE (books.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
____________________________________________


____________________________________________
Book.where(created_at: (Time.now.midnight - 1.day)..)
____________________________________________
____________________________________________
SELECT * FROM books WHERE books.created_at >= '2008-12-21 00:00:00'
____________________________________________


// Subset Conditions
____________________________________________
Customer.where(orders_count: [1,3,5])
____________________________________________
____________________________________________
SELECT * FROM customers WHERE (customers.orders_count IN (1,3,5))
____________________________________________



===================================================================
(*)===> NOT Conditions
____________________________________________
Customer.where.not(orders_count: [1,3,5])
____________________________________________
____________________________________________
SELECT * FROM customers WHERE (customers.orders_count NOT IN (1,3,5))
____________________________________________


____________________________________________
Customer.create!(nullable_contry: nil)
Customer.where.not(nullable_country: "UK")
=> []
# But
Customer.create!(nullable_contry: "UK")
Customer.where.not(nullable_country: nil)
=> [#<Customer id: 2, nullable_contry: "UK">]
____________________________________________

===================================================================
(*)===> OR Conditions
____________________________________________
Customer.where(last_name: 'Smith').or(Customer.where(orders_count: [1,3,5]))
____________________________________________
____________________________________________
SELECT * FROM customers WHERE (customers.last_name = 'Smith' OR customers.orders_count IN (1,3,5))
____________________________________________





===================================================================
(*)===>  AND Conditions
____________________________________________
Customer.where(last_name: 'Smith').where(orders_count: [1,3,5]))
____________________________________________
____________________________________________
SELECT * FROM customers WHERE customers.last_name = 'Smith' AND customers.orders_count IN (1,3,5)
____________________________________________


____________________________________________
Customer.where(id: [1, 2]).and(Customer.where(id: [2, 3]))
____________________________________________
____________________________________________
SELECT * FROM customers WHERE (customers.id IN (1, 2) AND customers.id IN (2, 3))
____________________________________________



___________________________________________________________________
############### Ordering ###############
===================================================================

____________________________________________
Book.order(:created_at)
# OR
Book.order("created_at")
____________________________________________

____________________________________________
Book.order(created_at: :desc)
# OR
Book.order(created_at: :asc)
# OR
Book.order("created_at DESC")
# OR
Book.order("created_at ASC")
____________________________________________

____________________________________________
Book.order(title: :asc, created_at: :desc)
# OR
Book.order(:title, created_at: :desc)
# OR
Book.order("title ASC, created_at DESC")
# OR
Book.order("title ASC", "created_at DESC")
____________________________________________

____________________________________________
irb> Book.order("title ASC").order("created_at DESC")
SELECT * FROM books ORDER BY title ASC, created_at DESC
____________________________________________





___________________________________________________________________
############### Selecting Specific Fields ###############
===================================================================
____________________________________________
Book.select(:isbn, :out_of_print)
# OR
Book.select("isbn, out_of_print")
____________________________________________
____________________________________________
SELECT isbn, out_of_print FROM books
____________________________________________


____________________________________________
# Returns unique last_names
query = Customer.select(:last_name).distinct

# Returns all last_names, even if there are duplicates
query.distinct(false)
____________________________________________


===================================================================
(*)===> Total of grouped items
____________________________________________
Order.group(:status).count
____________________________________________

##SQL==> SELECT COUNT (*) AS count_all, status AS status
FROM orders
GROUP BY status



___________________________________________________________________
############### Overriding Conditions ###############
===================================================================
(*)===> unscope
____________________________________________
Book.where('id > 100').limit(20).order('id desc').unscope(:order)
____________________________________________
____________________________________________
SELECT * FROM books WHERE id > 100 LIMIT 20

-- Original query without `unscope`
SELECT * FROM books WHERE id > 100 ORDER BY id desc LIMIT 20
____________________________________________



//You can also unscope specific where clauses
____________________________________________
Book.where(id: 10, out_of_print: false).unscope(where: :id)
# SELECT books.* FROM books WHERE out_of_print = 0
____________________________________________


//A relation which has used unscope will affect any relation into which it is merged:
____________________________________________
Book.order('id desc').merge(Book.unscope(:order))
# SELECT books.* FROM books
____________________________________________




===================================================================
(*)===> only
____________________________________________
Book.where('id > 10').limit(20).order('id desc').only(:order, :where)
____________________________________________
____________________________________________
SELECT * FROM books WHERE id > 10 ORDER BY id DESC

-- Original query without `only`
SELECT * FROM books WHERE id > 10 ORDER BY id DESC LIMIT 20
____________________________________________




===================================================================
(*)===> reselect
____________________________________________
Book.select(:title, :isbn).reselect(:created_at)
____________________________________________
____________________________________________
SELECT books.created_at FROM books
____________________________________________



// Compare this to the case where the reselect clause is not used:
____________________________________________
Book.select(:title, :isbn).select(:created_at)
____________________________________________
____________________________________________
SELECT books.title, books.isbn, books.created_at FROM books
____________________________________________





===================================================================
(*)===> reorder

// The reorder method overrides the default scope order. For example if the class definition includes this:
____________________________________________
class Author < ApplicationRecord
  has_many :books, -> { order(year_published: :desc) }
end
____________________________________________
==And you execute this:
____________________________________________
Author.find(10).books
____________________________________________
==The SQL that would be executed:
____________________________________________
SELECT * FROM authors WHERE id = 10 LIMIT 1
SELECT * FROM books WHERE author_id = 10 ORDER BY year_published DESC
____________________________________________



// You can using the reorder clause to specify a different way to order the books:
____________________________________________
Author.find(10).books.reorder('year_published ASC')
____________________________________________
____________________________________________
SELECT * FROM authors WHERE id = 10 LIMIT 1
SELECT * FROM books WHERE author_id = 10 ORDER BY year_published ASC
____________________________________________



===================================================================
(*)===> reverse_order
____________________________________________
Book.where("author_id > 10").order(:year_published).reverse_order
____________________________________________
____________________________________________
SELECT * FROM books WHERE author_id > 10 ORDER BY year_published DESC
____________________________________________


// If no ordering clause is specified in the query, the reverse_order orders by the primary key in reverse order.
____________________________________________
Book.where("author_id > 10").reverse_order
____________________________________________
____________________________________________
SELECT * FROM books WHERE author_id > 10 ORDER BY books.id DESC
____________________________________________

## The reverse_order method accepts no arguments.



===================================================================
(*)===> rewhere
____________________________________________
Book.where(out_of_print: true).rewhere(out_of_print: false)
____________________________________________
____________________________________________
SELECT * FROM books WHERE out_of_print = 0
____________________________________________


// If the rewhere clause is not used, the where clauses are ANDed together:
____________________________________________
Book.where(out_of_print: true).where(out_of_print: false)
____________________________________________
____________________________________________
SELECT * FROM books WHERE out_of_print = 1 AND out_of_print = 0
____________________________________________




___________________________________________________________________

###############  Null Relation & Readonly Objects ###############
===================================================================
____________________________________________
Book.none # returns an empty Relation and fires no queries.
____________________________________________

____________________________________________
# The highlighted_reviews method below is expected to always return a Relation.
Book.first.highlighted_reviews.average(:rating)
# => Returns average rating of a book

class Book
  # Returns reviews if there are at least 5,
  # else consider this as non-reviewed book
  def highlighted_reviews
    if reviews.count > 5
      reviews
    else
      Review.none # Does not meet minimum threshold yet
    end
  end
end
____________________________________________

===================================================================
(*)===> readonly 
// Active Record provides the readonly method on a relation to explicitly disallow modification of any of the returned objects.

Any attempt to alter a readonly record will not succeed, raising an ActiveRecord::ReadOnlyRecord exception.

____________________________________________
customer = Customer.readonly.first
customer.visits += 1
customer.save
____________________________________________



___________________________________________________________________

###############  Joining Tables ###############

Active Record provides two finder methods for specifying JOIN clauses on the resulting SQL:

joins and left_outer_joins. 

While joins should be used for INNER JOIN or custom queries, 
left_outer_joins is used for queries using LEFT OUTER JOIN.

===================================================================
(*)===> joins


//  Using a String SQL Fragment
____________________________________________
Author.joins("INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE")
____________________________________________
____________________________________________
SELECT authors.* FROM authors INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE
____________________________________________



//Joining a Single Association
____________________________________________
Book.joins(:reviews)
____________________________________________
____________________________________________
SELECT books.* FROM books
  INNER JOIN reviews ON reviews.book_id = books.id
____________________________________________



// Joining Multiple Associations
____________________________________________
Book.joins(:author, :reviews)
____________________________________________
____________________________________________
SELECT books.* FROM books
  INNER JOIN authors ON authors.id = books.author_id
  INNER JOIN reviews ON reviews.book_id = books.id
____________________________________________




// Joining Nested Associations (Single Level)
____________________________________________
Book.joins(reviews: :customer)
____________________________________________
____________________________________________
SELECT books.* FROM books
  INNER JOIN reviews ON reviews.book_id = books.id
  INNER JOIN customers ON customers.id = reviews.customer_id
____________________________________________



// Joining Nested Associations (Multiple Level)
____________________________________________
Author.joins(books: [{ reviews: { customer: :orders } }, :supplier] )
____________________________________________
____________________________________________
SELECT * FROM authors
  INNER JOIN books ON books.author_id = authors.id
  INNER JOIN reviews ON reviews.book_id = books.id
  INNER JOIN customers ON customers.id = reviews.customer_id
  INNER JOIN orders ON orders.customer_id = customers.id
INNER JOIN suppliers ON suppliers.id = books.supplier_id
____________________________________________



// Specifying Conditions on the Joined Tables
____________________________________________
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).where('orders.created_at' => time_range).distinct
____________________________________________
                  or
____________________________________________
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).where(orders: { created_at: time_range }).distinct
____________________________________________

## This will find all customers who have orders that were created yesterday, using a BETWEEN SQL expression to compare created_at.




===================================================================
(*)===> left_outer_joins
____________________________________________
Customer.left_outer_joins(:reviews).distinct.select('customers.*, COUNT(reviews.*) AS reviews_count').group('customers.id')
____________________________________________
____________________________________________
SELECT DISTINCT customers.*, COUNT(reviews.*) AS reviews_count FROM customers
LEFT OUTER JOIN reviews ON reviews.customer_id = customers.id GROUP BY customers.id
____________________________________________




___________________________________________________________________

############### Eager Loading Associations ###############

===================================================================
(*)===> includes : With includes, Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.

____________________________________________
books = Book.includes(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end
____________________________________________
____________________________________________
SELECT books.* FROM books LIMIT 10
SELECT authors.* FROM authors
  WHERE authors.book_id IN (1,2,3,4,5,6,7,8,9,10)
____________________________________________


____________________________________________
Author.includes(:books).where(books: { out_of_print: true })
____________________________________________
____________________________________________
  SELECT authors.id AS t0_r0, ... books.updated_at AS t1_r5 FROM authors LEFT OUTER JOIN books ON books.author_id = authors.id WHERE (books.out_of_print = 1)
____________________________________________

## If there was no where condition, this would generate the normal set of two queries.


// Using where like this will only work when you pass it a Hash. For SQL-fragments you need to use references to force joined tables:
____________________________________________
Author.includes(:books).where("books.out_of_print = true").references(:books)
____________________________________________






===================================================================
(*)===> preload : With preload, Active Record loads each specified association using one query per association.
____________________________________________
books = Book.preload(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end
____________________________________________
____________________________________________
SELECT books.* FROM books LIMIT 10
SELECT authors.* FROM authors
  WHERE authors.book_id IN (1,2,3,4,5,6,7,8,9,10)
____________________________________________

## unlike the includes method, it is not possible to specify conditions for preloaded associations.



===================================================================
(*)===> eager_load : With eager_load, Active Record loads all specified associations using a LEFT OUTER JOIN.

____________________________________________
books = Book.eager_load(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end
____________________________________________
## The above code will execute just 2 queries, as opposed to the 11 queries from the original case
____________________________________________
SELECT DISTINCT books.id FROM books LEFT OUTER JOIN authors ON authors.book_id = books.id LIMIT 10
SELECT books.id AS t0_r0, books.last_name AS t0_r1, ...
  FROM books LEFT OUTER JOIN authors ON authors.book_id = books.id
  WHERE books.id IN (1,2,3,4,5,6,7,8,9,10)
____________________________________________

## like the includes method, you can specify conditions for eager loaded associations.





___________________________________________________________________

############### Scopes ###############
===================================================================
(*)===> To define a simple scope, we use the scope method inside the class, passing the query that we'd like to run when this scope is called:
____________________________________________
class Book < ApplicationRecord
  scope :out_of_print, -> { where(out_of_print: true) }
end
____________________________________________

// To call this out_of_print scope we can call it on either the class:
____________________________________________
irb> Book.out_of_print
=> #<ActiveRecord::Relation> # all out of print books
____________________________________________


// Or on an association consisting of Book objects:
____________________________________________
irb> author = Author.first
irb> author.books.out_of_print
=> #<ActiveRecord::Relation> # all out of print books by `author`
____________________________________________


// Scopes are also chainable within scopes:
____________________________________________
class Book < ApplicationRecord
  scope :out_of_print, -> { where(out_of_print: true) }
  scope :out_of_print_and_expensive, -> { out_of_print.where("price > 500") }
end
____________________________________________






===================================================================
(*)===> Passing in arguments
// Your scope can take arguments:
____________________________________________
class Book < ApplicationRecord
  scope :costs_more_than, ->(amount) { where("price > ?", amount) }
end
____________________________________________

// Call the scope as if it were a class method:
____________________________________________
irb> Book.costs_more_than(100.10)
____________________________________________


However, this is just duplicating the functionality that would be provided to you by a class method.
____________________________________________
class Book < ApplicationRecord
  def self.costs_more_than(amount)
    where("price > ?", amount)
  end
end
____________________________________________

// These methods will still be accessible on the association objects:
____________________________________________
irb> author.books.costs_more_than(100.10)
____________________________________________




===================================================================
(*)===> Using conditionals

// Your scope can utilize conditionals:
____________________________________________
class Order < ApplicationRecord
  scope :created_before, ->(time) { where("created_at < ?", time) if time.present? }
end
____________________________________________



// Like the other examples, this will behave similarly to a class method.
____________________________________________
class Order < ApplicationRecord
  def self.created_before(time)
    where("created_at < ?", time) if time.present?
  end
end
____________________________________________


## However, there is one important caveat: A scope will always return an ActiveRecord::Relation object, even if the conditional evaluates to false, whereas a class method, will return nil. 
This can cause NoMethodError when chaining class methods with conditionals, if any of the conditionals return false.




===================================================================
(*)===>  Applying a default scope
____________________________________________
class Book < ApplicationRecord
  default_scope { where(out_of_print: false) }
end
____________________________________________
____________________________________________
SELECT * FROM books WHERE (out_of_print = false)
____________________________________________


## The default_scope is also applied while creating/building a record when the scope arguments are given as a Hash. 
It is not applied while updating a record. E.g.:

____________________________________________
class Book < ApplicationRecord
  default_scope { where(out_of_print: false) }
end
____________________________________________

____________________________________________
irb> Book.new
=> #<Book id: nil, out_of_print: false>
irb> Book.unscoped.new
=> #<Book id: nil, out_of_print: nil>
____________________________________________

## Be aware that, when given in the Array format, default_scope query arguments cannot be converted to a Hash for default attribute assignment. E.g.:
____________________________________________
class Book < ApplicationRecord
  default_scope { where("out_of_print = ?", false) }
end
____________________________________________
____________________________________________
irb> Book.new
=> #<Book id: nil, out_of_print: nil>
____________________________________________



===================================================================
(*)===> Merging of scopes

Just like where clauses, scopes are merged using AND conditions.
____________________________________________
class Book < ApplicationRecord
  scope :in_print, -> { where(out_of_print: false) }
  scope :out_of_print, -> { where(out_of_print: true) }

  scope :recent, -> { where('year_published >= ?', Date.current.year - 50 )}
  scope :old, -> { where('year_published < ?', Date.current.year - 50 )}
end
____________________________________________
____________________________________________
irb> Book.out_of_print.old
SELECT books.* FROM books WHERE books.out_of_print = 'true' AND books.year_published < 1969
____________________________________________


// We can mix and match scope and where conditions and the final SQL will have all conditions joined with AND.
____________________________________________
irb> Book.in_print.where('price < 100')
SELECT books.* FROM books WHERE books.out_of_print = 'false' AND books.price < 100
____________________________________________

## If we do want the last where clause to win then merge can be used.
____________________________________________
irb> Book.in_print.merge(Book.out_of_print)
SELECT books.* FROM books WHERE books.out_of_print = true
____________________________________________

## One important caveat is that default_scope will be prepended in scope and where conditions.
____________________________________________
class Book < ApplicationRecord
  default_scope { where('year_published >= ?', Date.current.year - 50 )}

  scope :in_print, -> { where(out_of_print: false) }
  scope :out_of_print, -> { where(out_of_print: true) }
end
____________________________________________
____________________________________________
irb> Book.all
SELECT books.* FROM books WHERE (year_published >= 1969)

irb> Book.in_print
SELECT books.* FROM books WHERE (year_published >= 1969) AND books.out_of_print = false

irb> Book.where('price > 50')
SELECT books.* FROM books WHERE (year_published >= 1969) AND (price > 50)
____________________________________________

===================================================================
(*)===> Removing All Scoping
____________________________________________
Book.unscoped.load
____________________________________________

____________________________________________
irb> Book.unscoped.all
SELECT books.* FROM books

irb> Book.where(out_of_print: true).unscoped.all
SELECT books.* FROM books
____________________________________________


// unscoped can also accept a block:
____________________________________________
irb> Book.unscoped { Book.out_of_print }
SELECT books.* FROM books WHERE books.out_of_print
____________________________________________




___________________________________________________________________

###############  ###############
===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________

===================================================================
(*)===> 
____________________________________________
____________________________________________



___________________________________________________________________

############### END ###############

(*)===>
____________________________________________
____________________________________________

(*)===>
____________________________________________
____________________________________________

(*)===> 
____________________________________________
____________________________________________


