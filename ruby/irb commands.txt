$ irb
_____________________________________________________________________________________
//stdout commands
_____________________________________________________________________________________
print "hello system"
hello system => nil 

puts "hello system"	#print + \n
hello system
 => nil       
 
putc "hello system"    #print on first char
h => "hello system" 

//variables
emp_name="Neeraj"      #string Class
 => "Neeraj" 
emp_name.class
 => String 

emp_id = 101		#integer class
 => 101 
emp_id.class
 => Integer 

isMale = true		# Trueclass
 => true 
isMale.class
 => TrueClass 

isMarried = false	# Falseclass
 => false 
isMarried.class
 => FalseClass 

leaves = nil		# Nilclass
 => nil 
leaves.class
 => NilClass 
leaves.nil?
 => true

_____________________________________________________________________________________
//strings
_____________________________________________________________________________________
emp_name = "Neeraj Kumar"
 => "Neeraj Kumar" 
puts emp_name
Neeraj Kumar
 => nil                                      

########## Using indexes in String ###########
puts emp_name.length
12
 => nil                                                    

> puts emp_name[0]
N
 => nil                                                    

> puts emp_name[12]

 => nil                                                    

> puts emp_name[11]
r
 => nil 

> puts emp_name[1,4]         #it will print 4 char from index 1
eera
 => nil                                                    

> puts emp_name[2,4]	    #it will print 4 char from index 2
eraj
 => nil

> puts emp_name.index("N")    #it return index of first matching char from left to right
0
 => nil                                                    

> puts emp_name.index("E")

 => nil                                                    

> puts emp_name.index("e")
1
 => nil 

> puts emp_name.index("a")
4
 => nil 

> puts emp_name.index("K")
7
 => nil 
 
 > puts emp_name.index("ee")
1
 => nil 

########## Escape Characters in String ###########
emp_name = "Neeraj-Kumar"
 => "Neeraj-Kumar" 
puts emp_name
Neeraj-Kumar
 => nil                                      

emp_name = "Neeraj/nKumar"
 => "Neeraj/nKumar" 
puts emp_name
Neeraj/nKumar
 => nil                                      

emp_name = "Neeraj\nKumar"
 => "Neeraj\nKumar" 
puts emp_name
Neeraj
Kumar
 => nil 

puts "Neeraj\nKumar" 			#to print in newline
Neeraj
Kumar                                        
 => nil 

emp_name = "Neeraj\"Kumar"		#'\' escape charater to print '"'
 => "Neeraj\"Kumar" 
puts emp_name
Neeraj"Kumar
 => nil 

########## Upper Case the String ###########
emp_name = "Neeraj Kumar"
 => "Neeraj Kumar" 
> puts emp_name.upcase
NEERAJ KUMAR
 => nil                                          
> puts emp_name.upcase()
NEERAJ KUMAR
 => nil  

########## Down Case the String ###########
> puts emp_name.downcase
neeraj kumar
 => nil     

########## Stripe Function ###########
emp_name = "     Neeraj Kumar     "
 => "     Neeraj Kumar     " 
> puts emp_name
     Neeraj Kumar     
 => nil 

> puts emp_name.strip		# remove extra spaces at start and end of string
Neeraj Kumar
 => nil  
 
emp_name = "     Neeraj     Kumar     "
 => "     Neeraj     Kumar     " 
> puts emp_name.strip
Neeraj     Kumar
 => nil
       
########## Length of String ###########
emp_name = "     Neeraj     Kumar     "
 => "     Neeraj     Kumar     " 
> puts emp_name.length
26
 => nil                                                    

> puts emp_name.strip.length
16
 => nil                                                               
                                                           
########## Include Method in String ###########
> puts emp_name.include? "kumar"
false
 => nil                                                               
> puts emp_name.include? "Kumar"
true
 => nil 

_____________________________________________________________________________________
Math & Numbers
_____________________________________________________________________________________

########## Math operators ###########
> 2-3
 => -1 

> 3-3
 => 0 

> 3*3
 => 9 

> 3**3
 => 27 

> 3**4
 => 81 

> 9/2
 => 4 

> 9.0/2
 => 4.5 

> 9/2.0
 => 4.5 

> 9%2
 => 1 

> 9.0%2
 => 1.0 

> 9%2.0
 => 1.0 

########## Numbers ###########
emp_id = 101
puts ("emp id :  #{emp_id}")

emp_id = -101
puts ("emp id : "+emp_id.to_s)

puts emp_id.abs       ##absolute functions
puts emp_id.abs()

puts emp_id.round()
puts emp_id.ceil()
puts emp_id.floor()

puts Math.sqrt(36)
puts Math.log(36)   ##sin,cos, etc is also there

_____________________________________________________________________________________
Getting Inputs
_____________________________________________________________________________________
########## gets ###########
when we store input in a variable and press enter, a newline also get store in it.

name = gets
puts "hello " + name + ", Good Morning"
=> 
Neeraj
hello Neeraj
, Good Morning
              
to remove the extra newline stored with the variable use .chomp() function
name = gets
puts "hello " + name.chomp() + ", Good Morning"
=>
Neeraj
hello Neeraj, Good Morning
b
_____________________________________________________________________________________
Arrays
_____________________________________________________________________________________
########## [] ###########
friends = Array[1,2.3,"Ram"]
or
friends = Array.new
friends[0]=1
friends[1]=3.3
friends[2] ="Ram"

########## puts ###########
puts friends   	##prints every element of array in new line
puts friends[0]  ##prints 1st element of array in
puts friends[0,2] 	##prints 2 element from 0 index of array in new line

########## methods ###########
friends.length()
friends.include? "Ram"     #case sensitive
friends.reverse()
friends.sort()       ##it will work only when all element have same data types

########## array & other_array ###########
Returns a new array containing elements common to the two arrays, with no duplicates.

3.2.1 :128 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :129 > arr2=[1,3,6,3,6,7,5]
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :130 > arr & arr2
 => [1, 3, 5] 

########## array * int ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :143 > arr3 = arr*1
 => [1, 2, 3, 4, 5] 
3.2.1 :144 > arr3 = arr*2
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
3.2.1 :145 > arr3 = arr*3
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
 
 3.2.1 :152 > str * 1
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :153 > str * 2
 => ["Ram", "Shayam", "Radha", "Ram", "Shayam", "Radha"] 

########## array * str ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :146 > str =['Ram','Shayam','Radha']
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :147 > str *,
3.2.1 :148 > 
^C                                      
3.2.1 :147 > str * ","
 => "Ram,Shayam,Radha" 
3.2.1 :148 > str * "R"
 => "RamRShayamRRadha" 
3.2.1 :149 > str * "<+>"
 => "Ram<+>Shayam<+>Radha" 
 
 3.2.1 :150 > arr*","
 => "1,2,3,4,5" 
3.2.1 :151 > arr*"=>"
 => "1=>2=>3=>4=>5" 

 
########## array + other_array ###########
Returns a new array built by concatenating the two arrays together to produce a third array.
3.2.1 :155 > arr3= arr + str
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :156 > arr4 = arr + arr2
 => [1, 2, 3, 4, 5, 1, 3, 6, 3, 6, 7, 5] 


########## array - other_array ###########
Returns a new array that is a copy of the original array, removing any items that also appear in other_array.
3.2.1 :157 > arr3
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :158 > arr3-arr
 => ["Ram", "Shayam", "Radha"] 


########## array | other_array ###########
Returns a new array by joining array with other_array, removing
duplicates.
3.2.1 :161 > arr
 => [1, 2, 3, 4, 5] 
3.2.1 :162 > arr2
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :163 > arr | arr2
 => [1, 2, 3, 4, 5, 6, 7] 
3.2.1 :164 > 


########## array << obj ###########
Pushes the given object onto the end of array. This expression returns the array itself, so several appends may be chained together.
//push_back
3.2.1 :175 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :176 > arr<<404
 => [1, 2, 3, 4, 5, 404] 
 
 //recuring values (bad practice)
 3.2.1 :039 > arr<<arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :040 > arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :041 > arr[5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :042 > arr[5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :043 > arr[5][5][5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :044 > str
 => ["Neeraj", "Kumar"] 
3.2.1 :045 > str[1]
 => "Kumar" 
3.2.1 :046 > str[1][1]
 => "u" 
3.2.1 :047 > str[1][1][1]
 => nil 

 
########## range,slice,index ###########
array[range]
3.2.1 :180 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9]

array.slice(index) 
3.2.1 :186 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
3.2.1 :187 > arr.slice(5,8)
 => [6, 7, 8, 9] 
 
 array.slice(range)
 3.2.1 :188 > arr.slice(5..8)
 => [6, 7, 8, 9] 
 
 array[start, length]
 3.2.1 :189 > arr[2,3]
 => [3, 4, 5]
 
########## input values in array ###########
3.2.1 :005 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
 
 array[index] = obj
3.2.1 :006 > arr[10]=100
 => 100 
3.2.1 :007 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100] 
3.2.1 :008 > arr<<200
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100, 200] 
 
 array[start, length] = obj or an_array or nil [or]
3.2.1 :009 > arr[3,6]=404
 => 404 
3.2.1 :010 > arr
 => [1, 2, 3, 404, nil, 100, 200] 
 
array[range] = obj or an_array or nil
3.2.1 :011 > arr[0..2]=500
 => 500 
3.2.1 :012 > arr
 => [500, 404, nil, 100, 200] 

########## array.abbrev(pattern = nil) ###########
Calculates the set of unambiguous abbreviations for the strings in self. If passed a pattern or a string, only the strings matching the pattern or starting with the string are considered.

3.2.1 :023 > require 'abbrev'
 => true 
3.2.1 :024 > arr.abbrev
/usr/share/rvm/rubies/ruby-3.2.1/lib/ruby/3.2.0/abbrev.rb:82:in `block in abbrev': undefined method `empty?' for 500:Integer (NoMethodError)

      next if word.empty?
      
3.2.1 :020 > str=['Neeraj','Kumar']
 => ["Neeraj", "Kumar"] 
3.2.1 :021 > str.abbrev
 => 
{"Neeraj"=>"Neeraj",                             
 "Neera"=>"Neeraj",                              
 "Neer"=>"Neeraj",                               
 "Nee"=>"Neeraj",                                
 "Ne"=>"Neeraj",                                 
 "N"=>"Neeraj",                                  
 "Kumar"=>"Kumar",                               
 "Kuma"=>"Kumar",                                
 "Kum"=>"Kumar",                                 
 "Ku"=>"Kumar",                                  
 "K"=>"Kumar"}  

########## array.assoc(obj) ###########
Searches through an array whose elements are also arrays comparing obj with the ﬁrst element of each contained array using obj.==. Returns the ﬁrst contained array that matches or nil if no match is found.
3.2.1 :062 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :063 > arr.assoc(1)
 => [1, 2, 3, 4] 
3.2.1 :064 > arr.assoc(500)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :065 > arr.rassoc(500)
 => nil 
3.2.1 :066 > arr.rassoc(404)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :067 > arr.rassoc(1)
 => nil 
3.2.1 :068 > arr.rassoc(2)
 => [1, 2, 3, 4] 

########## array.clear ###########
Removes all elements from array.
3.2.1 :070 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :071 > arr.clear
 => [] 
3.2.1 :072 > arr
 => [] 


########## array.collect { |item| block } [or]
array.map { |item| block } (return new array) ###########

3.2.1 :087 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :088 > arr.map{|i| 
3.2.1 :089 >   if i%2==0
3.2.1 :090 >     i
3.2.1 :091 >   end
3.2.1 :092 > }
 => 
[nil,                                               
 2,                                                 
 nil,                                               
 4,                                                 
 nil,                                               
 6,                                                 
 nil,                                               
 8,                                                 
 nil,                                           
 10,                                           
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :093 > arr.map{|i| 
3.2.1 :094 >   if i%2==0
3.2.1 :095 >     i
3.2.1 :096 >   end
3.2.1 :097 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 


########## array.collect! { |item| block } [or]
array.map! { |item| block } (it will change the original value of arr #inplace) ###########
3.2.1 :098 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :099 > arr.map!{|i| 
3.2.1 :100 >   if i%2==0
3.2.1 :101 >     i
3.2.1 :102 >   end
3.2.1 :103 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :104 > arr.map!{|i| 
3.2.1 :105 >   if i%2==0
3.2.1 :106 >     i
3.2.1 :107 >   end
3.2.1 :108 > }
(irb):105:in `block in <top (required)>': undefined method `%' for nil:NilClass (NoMethodError)

########## array.compact & array.compact! (inplace)  ###########
array.compact
Returns a copy of self with all nil elements removed.

array.compact!
Removes nil elements from array. Returns nil if no changes were made.

3.2.1 :132 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :133 > arr.map!{|i| 
3.2.1 :134 >   if i%2==0
3.2.1 :135 >     i
3.2.1 :136 >   end
3.2.1 :137 > }.compact
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :138 > arr
 => 
[nil,                                                                 
 2,                                                                   
 nil,                 
 4,                   
 nil,                 
 6,                   
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :139 > arr.compact!
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :140 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18]
 
########## array.concat(other_array) ###########
Appends the elements in other_array to self.
3.2.1 :142 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :143 > arr1= Array(19..25)
 => [19, 20, 21, 22, 23, 24, 25] 
3.2.1 :144 > arr.concat(arr1)
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :145 > 
 
########## array.delete(obj) [or]
array.delete(obj) { block } ###########

Deletes items from self that are equal to obj. If the item is not found,
returns nil. If the optional code block is given, returns the result of block
if the item is not found.

3.2.1 :151 > arr
 => [2, 4, 6, 8, 10, 12, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :152 > arr.delete(12){"not found"}
 => 12 
3.2.1 :153 > arr.delete(12){"not found"}
 => "not found" 
3.2.1 :154 > arr.delete(12)
 => nil 
3.2.1 :155 > arr.delete(16)
 => 16 


array.delete_at(index)
Deletes the element at the speciﬁed index, returning that element, or
nil if the index is out of range.
3.2.1 :156 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :157 > arr.delete_at(10)
 => 23 
3.2.1 :158 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 24, 25] 

array.delete_if { |item| block }

Deletes every element of self for which block evaluates to true.
3.2.1 :161 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :162 > arr.delete_if{|i| i%2==1}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 
########## array.empty?  and array.eql?(other)###########
array.empty?
Returns true if the self array contains no elements.

array.eql?(other)
Returns true if array and other are the same object, or are both arrays
with the same content.
 
########## array.each { |item| block } and array.each_index { |index| block } ###########

array.each { |item| block }
Calls block once for each element in self, passing that element as a
parameter.

array.each_index { |index| block }
Same as Array#each, but passes the index of the element instead of the
element itself.

3.2.1 :170 > arr.each {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :171 > arr.each_index {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 3.2.1 :173 > arr.each_index {|i| print i.to_s + " :"}
0 :1 :2 :3 :4 :5 :6 :7 :8 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :174 > arr.each {|i| print i.to_s + " :"}
2 :4 :6 :8 :10 :12 :14 :16 :18 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
########## array.fetch ###########
array.fetch(index) [or]
array.fetch(index, default) [or]
array.fetch(index) { |index| block }
Tries to return the element at position index. If index lies outside the array, the ﬁrst form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking block, passing in index. Negative values of index count from the end of the array.
 
array.fetch(index) 
3.2.1 :011 > arr.fetch(10)
 => 11 
3.2.1 :012 > arr.fetch(11)
(irb):12:in `fetch': index 11 outside of array bounds: -11...11 (IndexError)         


array.fetch(index, default) 
3.2.1 :013 > arr.fetch(11,404)
 => 404 

array.fetch(index) { |index| block }
3.2.1 :015 > arr.fetch(10){|i| put i}
 => 11 
3.2.1 :016 > arr.fetch(11){|i|}
 => nil 
3.2.1 :017 > arr.fetch(11){|i| i*2}
 => 22 
3.2.1 :018 > arr.fetch(11){|i| i}
 => 11 

##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########


_____________________________________________________________________________________
Hashes (map in C++, dictonary in python)
_____________________________________________________________________________________
########## [] ###########
states = {
	:PN => "Punjab"
	"DL" => "Delhi"
	1 => "Haryana"
	}

########## puts ###########
puts states
puts states[1]
puts states["DL"]
puts states[:PN]

_____________________________________________________________________________________
Methods (functions)
_____________________________________________________________________________________
########## [] ###########
3.2.1 :006 > def sayhi
3.2.1 :007 >   puts "Hi, Good Morning"
3.2.1 :008 > end
 => :sayhi 
3.2.1 :012 > sayhi.class   	##it prints NilClass because return type is void
Hi, Good Morning
 => NilClass


3.2.1 :013 > def sayhi(name,age)
3.2.1 :014 >   puts ("Hello, #{name}. Your age is #{age}")
3.2.1 :015 > end
 => :sayhi 
3.2.1 :016 > sayhi("Neeraj",22)
Hello, Neeraj. Your age is 22
 => nil       


3.2.1 :019 > def sayhi(name="Unkown",age=-1)
3.2.1 :020 >   puts ("Hello, #{name}. Your age is #{age}")
3.2.1 :021 > end
 => :sayhi 
3.2.1 :022 > sayhi
Hello, Unkown. Your age is -1
 => nil 
 
 ## returning a value
3.2.1 :029 > def cube(num)
3.2.1 :030 >   num*num*num
3.2.1 :031 > end
 => :cube 
3.2.1 :032 > cube(5)
 => 125 
 
 or
  
##using return statatement
3.2.1 :029 > def cube(num)
3.2.1 :030 >   return num*num*num
3.2.1 :031 > end
 => :cube 
3.2.1 :032 > cube(5)
 => 125 

3.2.1 :036 > def cube(num)
3.2.1 :037 >  return num*num*num,num
3.2.1 :038 > end
 => :cube 
3.2.1 :039 > cube(5)
 => [125, 5] 
3.2.1 :040 > cube(5)[0]
 => 125 
3.2.1 :041 > cube(5)[1]
 => 5 

_____________________________________________________________________________________
if .. else.. statements
_____________________________________________________________________________________
########## [] ###########
3.2.1 :042 > ismale = true
 => true 
3.2.1 :043 > istall = false
 => false 
3.2.1 :044 > if ismale and istall
3.2.1 :045 >   puts "You are a tall male"
3.2.1 :046 > elsif ismale and !istall
3.2.1 :047 >   puts "You are a short male"
3.2.1 :048 > elsif !ismale and istall
3.2.1 :049 >   puts "You are tall but not male"
3.2.1 :050 > else
3.2.1 :051 >   puts "You are neihter tall nor male"
3.2.1 :052 > end
You are a short male
 => nil          

_____________________________________________________________________________________
case statements
_____________________________________________________________________________________
########## [] ###########
3.2.1 :058 > abr = "HR"
 => "HR" 
3.2.1 :059 > case abr
3.2.1 :060 > when "HR"
3.2.1 :061 >   state = "Haryana"
3.2.1 :062 > when "PN"
3.2.1 :063 >   state = "Punjab"
3.2.1 :064 > when "UP"
3.2.1 :065 >   state = "Uttar Pradesh"
3.2.1 :066 > else
3.2.1 :067 >   state = "Invalid State Abbrevation"
3.2.1 :068 > end
 => "Haryana" 

_____________________________________________________________________________________
while loop
_____________________________________________________________________________________
########## [] ###########
3.2.1 :069 > i = 5
 => 5 
 3.2.1 :074 > while i>0
3.2.1 :075 >   puts i;
3.2.1 :076 >   i=i-1;
3.2.1 :077 > end
5
4                                              
3                                              
2                                              
1                                              
 => nil  

_____________________________________________________________________________________
for loop
_____________________________________________________________________________________
friends = ["ram","shyam","radha"]

########## Method 1 ###########
for ele in friends
	puts ele
end

########## Method 2 ###########
friends.each do |ele|
	puts ele
end

########## Method 3 ###########
 for i in 0..5
 	puts i
 end
 
########## Method 4 ###########
6.times do |i|
	puts i
end

_____________________________________________________________________________________
comments
_____________________________________________________________________________________
########## [] ###########

single line comment  use "#"

multiple line
=begin
.....comments......
=end

_____________________________________________________________________________________
reading files
_____________________________________________________________________________________
########## [] ###########
File.open("/home/beryl/Neeraj/test","r") do |file|
    puts file  #it will read the meta data of file
    puts file.read()  #it will read the content of the file
    puts file.read().include? "ruby" #it will search the text in the file
    puts file.readline() #it will read the first line of the file and move the postion of curr pointer to nextline
    puts file.readline() #now it will print the second line
    puts file.readchar() #it will read the first character of the file and move the postion of curr pointer to next character
    puts file.readchar() #now it will print the second character
    puts file.readlines() 

    for line in file   #line will take value of every line in the file line by line
        puts line
    end
end
    or 
file = File.open("/home/beryl/Neeraj/test","r")
puts file.read()
file.close()

_____________________________________________________________________________________
writing files
_____________________________________________________________________________________
########## [a] ###########
File.open("/home/beryl/Neeraj/test","a") do |file|
    file.write("\n this line will be append in new line of test file")
end

########## [w] ###########
File.open("/home/beryl/Neeraj/test2","w") do |file|
    file.write("it will first clear the previous content then overwrite this value int the file")
    file.write("\n if the given file doesnot exist it will create new file the overwrite it")
end

########## [r+] ###########
File.open("/home/beryl/Neeraj/test2","r+") do |file|
    file.readline() #it will read the first line of the file and move the postion of curr pointer to nextline
    file.readchar() #it will read the first character of the file and move the postion of curr pointer to next character
    file.write("it will overwrite from the positon of curr position of the file")
    file.write("\n in this case it will overwrite from 2nd line's 2nd character")
end

_____________________________________________________________________________________
error handling
_____________________________________________________________________________________
########## [begin...rescue...end] ###########

lucky_nums = [1,2,3,4,5,6]

3.2.1 :118 > begin
3.2.1 :119 >   lucky_nums["fog"]
3.2.1 :120 >   num=10/0
3.2.1 :121 > rescue ZeroDivisionError 
3.2.1 :122 >   puts "Division by Zero Error"
3.2.1 :123 > rescue TypeError => err
3.2.1 :124 >   puts err
3.2.1 :125 > rescue
3.2.1 :126 >   puts "Unknown Error"
3.2.1 :127 > end
no implicit conversion of String into Integer
 => nil               

_____________________________________________________________________________________
Classes and Object
_____________________________________________________________________________________
########## [] ###########
class Shape
    attr_accessor :length, :breadth, :height
    def initialize(length,breadth,height)
        @length = length
        @breadth = breadth
        @height = height
    end

    def area 
        @length*@breadth*@height
    end

    def isSqaure
        if @length == @height and @length==@breadth
            return true
        else 
            return false
        end
    end
    def to_s
        return "Length: #{@length}\nBreadth: #{@breadth}\nHeight: #{@height}" 
    end
end

shape1 = Shape.new(2,3,4)
shape2 = Shape.new(4,4,4)

puts shape1
puts shape1.area()
puts shape1.isSqaure()

puts shape2
puts shape2.area()
puts shape2.isSqaure()

_____________________________________________________________________________________
Inheritance
_____________________________________________________________________________________
########## [] ###########
class Chef
    def make_meat
        puts "Can make meat"
    end
    def make_salad
        puts "Can make salad"
    end
    def special_dish
        puts "Gajjar ka Halwa"
    end
end    

class ItalianChef < Chef
    def special_dish
        puts "Pasta and Sandwich"
    end
end

chef1= Chef.new
chef2= ItalianChef.new
puts "chef1"
chef1.make_meat
chef1.make_salad
chef1.special_dish
puts "\nchef2"
chef2.make_meat
chef2.make_salad
chef2.special_dish

_____________________________________________________________________________________
Tools
_____________________________________________________________________________________
########## [] ###########




