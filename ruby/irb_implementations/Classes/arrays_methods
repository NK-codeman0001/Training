Arrays
_____________________________________________________________________________________
########## [] ###########
friends = Array[1,2.3,"Ram"]
or
friends = Array.new
friends[0]=1
friends[1]=3.3
friends[2] ="Ram"

########## Array literal ###########
3.2.1 :002 > arr=[1, 'one', :one, [2, 'two', :two]]
 => [1, "one", :one, [2, "two", :two]] 
3.2.1 :003 > arr
 => [1, "one", :one, [2, "two", :two]] 
 
3.2.1 :004 > %w[neeraj kumar, graduate engineer trainee]
 => ["neeraj", "kumar,", "graduate", "engineer", "trainee"] 

3.2.1 :005 > %i[neeraj kumar, graduate engineer trainee]
 => [:neeraj, :"kumar,", :graduate, :engineer, :trainee] 
 
 3.2.1 :006 > Array(key: :value)   
 => [[:key, :value]] 

3.2.1 :008 > Array({:a => "a", :b => "b"})
 => [[:a, "a"], [:b, "b"]] 

3.2.1 :009 > Array(nil) 
 => []

3.2.1 :013 > Array.new 
 => [] 
 
3.2.1 :010 > Array.new(3) 
 => [nil, nil, nil] 
 
3.2.1 :011 > Array.new(4) {Hash.new}
 => [{}, {}, {}, {}] 

3.2.1 :012 > Array.new(3, true) 
 => [true, true, true] 
 
3.2.1 :014 > Array.new(4) {|i| i.to_s }
 => ["0", "1", "2", "3"] 
 
3.2.1 :015 > Array.new(3) {Array.new(3)}
 => [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]] 

########## array information ###########

3.2.1 :001 > arr=Array(1..5)
 => [1, 2, 3, 4, 5]
 3.2.1 :030 > arr.length
 => 5 
3.2.1 :031 > arr.size
 => 5 
3.2.1 :032 > arr.count
 => 5 
3.2.1 :034 > arr.empty?
 => false 
 
 
3.2.1 :035 > arr[6]=nil
 => nil 
3.2.1 :036 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :037 > arr.length
 => 7 
3.2.1 :038 > arr.size
 => 7 
3.2.1 :039 > arr.count
 => 7 
3.2.1 :040 > arr.empty?
 => false 

3.2.1 :041 > arr.include?5
 => true 
3.2.1 :042 > arr.include?(5)
 => true 
 3.2.1 :044 > arr.include?nil
 => true 
 

########## puts ###########
puts friends   	##prints every element of array in new line
puts friends[0]  ##prints 1st element of array in
puts friends[0,2] 	##prints 2 element from 0 index of array in new line

########## methods ###########
friends.length()
friends.include? "Ram"     #case sensitive
friends.reverse()
friends.sort()       ##it will work only when all element have same data types

########## Adding Items to Arrays ###########
3.2.1 :045 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :046 > arr.push(200)
 => [1, 2, 3, 4, 5, nil, nil, 200] 
3.2.1 :047 > arr<<6
 => [1, 2, 3, 4, 5, nil, nil, 200, 6] 

//unshift
unshift will add a new item to the beginning of an array.

3.2.1 :048 > arr.unshift(404)
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6] 
 
//insert
With insert you can add a new element to an array at any position.
If there is already an element at that position then new element will be added at that index only shifting the other elements

3.2.1 :049 > arr.size
 => 10 
3.2.1 :050 > arr.insert(10,'Apple')
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple"] 
3.2.1 :051 > arr.insert(15,'A2')
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A2"] 

3.2.1 :055 > arr
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A3", nil] 
3.2.1 :056 > arr.insert(1,'one')
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A3", nil] 
3.2.1 :057 > arr[16]
 => "A2" 
3.2.1 :058 > arr.insert(16,'sixteen') //it will shift the other elements
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen", "A2", "A3", nil] 

3.2.1 :059 > arr.insert(0,'0','1','2')  //adding multiple element at a time.
 => ["0", "1", "2", 404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen", "A2", "A3", nil] 

########## Removing Items from an Array ###########
//pop (remove last element and return it)
The method pop removes the last element in an array and returns it:

3.2.1 :062 > arr.pop
 => "A3" 
3.2.1 :063 > d=arr.pop
 => "A2" 
3.2.1 :064 > d
 => "A2" 
//shift (remove first element and return it)
To retrieve and at the same time remove the first item, use shift:
3.2.1 :065 > d=arr.shift
 => "0" 
3.2.1 :066 > d
 => "0" 

//delete_at(index)  
To delete an element at a particular index:
3.2.1 :067 > d=arr.delete_at(0)
 => "1" 
3.2.1 :068 > d
 => "1" 
 
//delete(value)
To delete a particular element anywhere in an array, use delete
3.2.1 :069 > d=arr.delete(0)
 => nil 
3.2.1 :070 > d=arr.delete('2')
 => "2" 
3.2.1 :071 > d
 => "2" 

//compact and compact! 
A useful method if you need to remove nil values from an array is compact:
3.2.1 :072 > arr.compact
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :073 > arr
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen"] 
3.2.1 :074 > arr.compact!
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :075 > arr
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 

########## Iterating over Arrays ###########
3.2.1 :081 > num=Array(1..5)
 => [1, 2, 3, 4, 5] 
 
//.each
In case of Array’s each, all elements in the Array instance are yielded to the supplied block in sequence.
Note that this operation leaves the array unchanged.

3.2.1 :082 > num.each {|i| print i -= 10, " "}
-9 -8 -7 -6 -5  => [1, 2, 3, 4, 5] 

//.reverse_each
reverse_each which will iterate over the elements in the array in reverse order.

3.2.1 :083 > arr.reverse_each {|i| print i, " "}
sixteen Apple 6 200 5 4 3 2 1 one 404  => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"]                                               
3.2.1 :084 > words=%w[hello world ruby]
 => ["hello", "world", "ruby"] 
3.2.1 :085 > str=""
 => "" 
3.2.1 :086 > words.reverse_each {|i| str += "#{i}"}
 => ["hello", "world", "ruby"] 
3.2.1 :087 > str
 => "rubyworldhello" 
3.2.1 :088 > str=""
 => "" 
3.2.1 :089 > words.reverse_each {|i| str += "#{i} "}
 => ["hello", "world", "ruby"] 
 
//map

The map method can be used to create a new array based on the original array, but with the values modified by the supplied block

arr.map {|i| i*2}	#=> [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
arr	#=> [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
arr.map! {|i| i*2}	# => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
arr	# => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
 
Returns a new Enumerator if no block given:
a = [:foo, 'bar', 2]
a1 = a.map
a1 # => #<Enumerator: [:foo, "bar", 2]:map>

########## Selecting Items from an Array ###########
select! and reject! are the corresponding destructive methods to select and reject

Similar to select vs. reject, delete_if and keep_if have the exact opposite result when supplied with the same block

3.2.1 :094 > num
 => [1, 2, 3, 4, 5] 
 //select
3.2.1 :095 > num.select {|i| i>3}
 => [4, 5] 
 
//reject
3.2.1 :096 > num.reject {|i| i>3}
 => [1, 2, 3]
 
//drop_while  (it is similar to use while loop with drop function)
 
3.2.1 :097 > num.drop_while {|i| i>3}  (the while loop breaks since the initial condition is not meet for first element)
 => [1, 2, 3, 4, 5] 
3.2.1 :101 > num.drop_while { |i| i < 3}
 => [3, 4, 5] 
 
//delete_if
3.2.1 :103 > num.delete_if {|i| i>3}
 => [1, 2, 3] 
3.2.1 :104 > num
 => [1, 2, 3]
 
 //keep_if 
3.2.1 :105 > num.keep_if {|i| i>3}
 => []  
3.2.1 :107 > num
 => [] 

######### Methods for Creating an Array ###########

    ::[]: Returns a new array populated with given objects.

3.2.1 :003 > Array.[](1,'2','three')
 => [1, "2", "three"] 
3.2.1 :004 > Array.[](1..6)
 => [1..6]        
3.2.1 :006 > Array[1..6]
 => [1..6] 
3.2.1 :007 > Array[1,'2','three']
 => [1, "2", "three"] 
3.2.1 :008 > [1..6]
 => [1..6] 
3.2.1 :009 > [1,'2','three']
 => [1, "2", "three"] 


    ::new: Returns a new array.
With no block and a single Array argument array, returns a new Array formed from array:

3.2.1 :017 > a=Array.new([1,:to,'three','5'])
 => [1, :to, "three", "5"] 

3.2.1 :018 > a.class # => Array

3.2.1 :018 > a 
 => [1, :to, "three", "5"] 
 

With no block and a single Integer argument size, returns a new Array of the given size whose elements are all nil:

3.2.1 :018 > Array.new(5)
 => [nil, nil, nil, nil, nil] 


With no block and arguments size and default_value, returns an Array of the given size; each element is that same default_value:

3.2.1 :019 > Array.new(5,404)
 => [404, 404, 404, 404, 404] 


With a block and argument size, returns an Array of the given size; the block is called with each successive integer index; the element for that index is the return value from the block:

3.2.1 :020 > Array.new(5) {|i| "item #{i}"}
 => ["item 0", "item 1", "item 2", "item 3", "item 4"] 


=>>Raises ArgumentError if size is negative.
=>>With a block and no argument, or a single argument 0, ignores the block and returns a new empty Array.


    ::try_convert: Returns a new array created from a given object.
Method: Array.try_convert


If object is an Array object, returns object.

Otherwise if object responds to :to_ary, calls object.to_ary and returns the result.

Returns nil if object does not respond to :to_ary

Raises an exception unless object.to_ary returns an Array object.

3.2.1 :098 > arr=[1,2,3]
 => [1, 2, 3] 
3.2.1 :099 > Array.try_convert(arr)
 => [1, 2, 3] 
3.2.1 :100 > Array.try_convert(33)
 => nil 
3.2.1 :101 > Array.try_convert('Neeraj')
 => nil 
3.2.1 :102 > Array.try_convert(['Neeraj',12,'22',:dd])
 => ["Neeraj", 12, "22", :dd] 

try_convert example->

arr = [1, 2, 3]

if new_arr = Array.try_convert(arr)
  new_arr << 4
  puts "Array conversion successful: #{new_arr.inspect}"
else
  puts "Array conversion failed"
end

str = "hello"

if new_str = Array.try_convert(str)
  new_str << "world"
  puts "Array conversion successful: #{new_str.inspect}"
else
  puts "Array conversion failed"
end

########## Methods for Querying ###########


    length, size: Returns the count of elements.

    include?: Returns whether any element == a given object.

    empty?: Returns whether there are no elements.

    all?: Returns whether all elements meet a given criterion.

    any?: Returns whether any element meets a given criterion.

    none?: Returns whether no element == a given object.

    one?: Returns whether exactly one element == a given object.

    count: Returns the count of elements that meet a given criterion.

    count()
    Array#count() : count() is a Array class method which returns the number of elements in the array. It can also find the total number of a particular element in the array.

Syntax:  Array.count()
Parameter:  obj - specific element to found
Return:  removes all the nil values from the array. 

Code #1 : 
a = [18, 22, 33, nil, 5, 6]
b = [1, 4, 1, 1, 88, 9]
c = [18, 22, nil, nil, 50, 6]
  
puts "counting : #{a.count}\n\n"
puts "counting : #{b.count(1)}\n\n"
puts "counting : #{c.count(nil)}\n\n"

Output :
counting : 6
counting : 3
counting : 2

Code #2 : 
a = ["abc", "nil", "dog"]
b = ["cow", nil, "dog"]
c = ["cat", nil, nil]

puts "counting : #{a.count}\n\n"
puts "counting : #{b.count(1)}\n\n"
puts "counting : #{c.count(nil)}\n\n"

Output :
counting: 3
counting : 0
counting : 2


    find_index, index: Returns the index of the first element that meets a given criterion.

    rindex: Returns the index of the last element that meets a given criterion.

    hash: Returns the integer hash code.


3.2.1 :001 > arr=Array(1..5)
 => [1, 2, 3, 4, 5]
 
 //length , size, count, empty?, include?
 
 3.2.1 :030 > arr.length
 => 5 
3.2.1 :031 > arr.size
 => 5 
3.2.1 :032 > arr.count
 => 5 
3.2.1 :034 > arr.empty?
 => false 
 
 
3.2.1 :035 > arr[6]=nil
 => nil 
3.2.1 :036 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :037 > arr.length
 => 7 
3.2.1 :038 > arr.size
 => 7 
3.2.1 :039 > arr.count
 => 7 
3.2.1 :040 > arr.empty?
 => false 

3.2.1 :041 > arr.include?5
 => true 
3.2.1 :042 > arr.include?(5)
 => true 
 3.2.1 :044 > arr.include?nil
 => true 
 
//all?, any?, none?, one?, find_index, index, rindex, hash

#all?
Returns true if all elements of self meet a given criterion.

With no block given and no argument, returns true if self contains only truthy elements, false otherwise:

3.2.1 :034 > [0, 1, :foo].all?
 => true 
3.2.1 :035 > [0, 1, :foo].all?nil
 => false 
3.2.1 :036 > [0, nil, 2].all?
 => false 
3.2.1 :037 > [0, nil, 2].all?nil
 => false 
3.2.1 :038 > [].all?
 => true 
3.2.1 :039 > [].all?nil
 => true 

3.2.1 :041 > num=Array(1..8)
 => [1, 2, 3, 4, 5, 6, 7, 8] 
 
3.2.1 :043 > num.all? {|i| i>0}
 => true 
3.2.1 :044 > num.all? {|i| i<7}
 => false 

If argument obj is given, returns true if obj.=== every element, false otherwise:
3.2.1 :045 > ['food', 'fool', 'foot'].all?(/foo/)
 => true 
3.2.1 :046 > ['food', 'drink'].all?(/bar/)
 => false 
3.2.1 :047 > [].all?(/foo/)
 => true 
3.2.1 :048 > [].all?(/bar/)
 => true 
3.2.1 :049 > [0, 0, 0].all?(0)
 => true 
3.2.1 :050 > [0, 1, 2].all?(1)
 => false 


#any?
Returns true if any element of self meets a given criterion.

With no block given and no argument, returns true if self has any truthy element, false otherwise:

##similar to all?



#none?
Returns true if no element of self meet a given criterion.

With no block given and no argument, returns true if self has no truthy elements, false otherwise:

##similar to all?


#one?
Returns true if exactly one element of self meets a given criterion.

With no block given and no argument, returns true if self has exactly one truthy element, false otherwise:

3.2.1 :062 > num
 => [1, 2, 3, 4, 5, 5, 7, 8] 
3.2.1 :063 > num.one?
 => false 
3.2.1 :064 > [].one?
 => false 

3.2.1 :067 > num.one? {|i| i>0}
 => false 
3.2.1 :068 > num.one? {|i| i>7}
 => true 

3.2.1 :069 > ['food', 'drink'].one?(/bar/)
 => false 
3.2.1 :070 > ['food', 'drink'].one?(/foo/)
 => true 


#find_index or index

array.index(obj)
Returns the index of obj 

arr=[1,2,3,4,5,6,7,7,8]
3.2.1 :036 > arr.index(7)
 => 6 
3.2.1 :037 > arr.index(10)
 => nil 

#rindex
=> similar to index(obj) but it returns the last matching obj

#array.hash
Computes a hash-code for array. Two arrays with the same content will
have the same hash code.

3.2.1 :027 > arr.hash
 => -4241591116995688593 
3.2.1 :028 > arr1.hash
 => 3624524072152072368


########## Methods for Comparing ###########


    <=>: Returns -1, 0, or 1 * as self is less than, equal to, or greater than a given object.
Returns -1 if any result is -1
Returns 1 if any result is 1:
Returns 1 both are equal:

3.2.1 :071 > [0,1,2,3] <=> [0,1,2,3]
 => 0 
3.2.1 :072 > [0,1,2,3] <=> [0,1,2,3,4]
 => -1 
3.2.1 :073 > [0,1,2,3,4] <=> [0,1,2,3]
 => 1 
3.2.1 :074 > [0,1,2,3,5] <=> [0,1,2,3,6]
 => -1 
3.2.1 :075 > [0,1,2,3,5,8] <=> [0,1,2,3,6,7]
 => -1 

    ==: Returns whether each element in self is == to the corresponding element in a given object.
=>check if both array is same
syntax: arr1==arr2

    eql?: Returns whether each element in self is eql? to the corresponding element in a given object.

=>similar to ==
syntax: arr1.eql?(arr2)

########## array find () ###########
The find() of enumerable is an inbuilt method in Ruby returns the first element which satisfies the given condition in the block. If there is no block, then it returns the enumerator itself.

    Syntax: block.find { |obj| block }
    Parameters: The function takes the block according to which the first which satisfies is to be returned.
    Return Value: It returns the first element which satisfies the block or the enumerator instead.

Example 1:

enu = (1..50)
enu.find { |el|  el % 2 == 0 && el % 9 == 0}

Output:
18


Example 2:
enu = (1..50)
enu.find

Output:
Enumerator: 1..50:find


########## array << obj ###########
Pushes the given object onto the end of array. This expression returns the array itself, so several appends may be chained together.
//push_back
3.2.1 :175 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :176 > arr<<404
 => [1, 2, 3, 4, 5, 404] 
 
 //recuring values (bad practice)
 3.2.1 :039 > arr<<arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :040 > arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :041 > arr[5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :042 > arr[5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :043 > arr[5][5][5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :044 > str
 => ["Neeraj", "Kumar"] 
3.2.1 :045 > str[1]
 => "Kumar" 
3.2.1 :046 > str[1][1]
 => "u" 
3.2.1 :047 > str[1][1][1]
 => nil 

 
########## range,index ###########
array[range]
3.2.1 :180 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9]

 array[start, length]
 3.2.1 :189 > arr[2,3]
 => [3, 4, 5]
 
########## input values in array ###########
3.2.1 :005 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
 
 array[index] = obj
3.2.1 :006 > arr[10]=100
 => 100 
3.2.1 :007 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100] 
3.2.1 :008 > arr<<200
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100, 200] 
 
 array[start, length] = obj or an_array or nil [or]
3.2.1 :009 > arr[3,6]=404
 => 404 
3.2.1 :010 > arr
 => [1, 2, 3, 404, nil, 100, 200] 
 
array[range] = obj or an_array or nil
3.2.1 :011 > arr[0..2]=500
 => 500 
3.2.1 :012 > arr
 => [500, 404, nil, 100, 200] 



########## array.clear ###########
Removes all elements from array.
3.2.1 :070 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :071 > arr.clear
 => [] 
3.2.1 :072 > arr
 => [] 


########## array.concat(other_array) ###########
Appends the elements in other_array to self.
3.2.1 :142 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :143 > arr1= Array(19..25)
 => [19, 20, 21, 22, 23, 24, 25] 
3.2.1 :144 > arr.concat(arr1)
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :145 > 
 
########## array.delete(obj) [or]
array.delete(obj) { block } ###########

Deletes items from self that are equal to obj. If the item is not found,
returns nil. If the optional code block is given, returns the result of block
if the item is not found.

3.2.1 :151 > arr
 => [2, 4, 6, 8, 10, 12, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :152 > arr.delete(12){"not found"}
 => 12 
3.2.1 :153 > arr.delete(12){"not found"}
 => "not found" 
3.2.1 :154 > arr.delete(12)
 => nil 
3.2.1 :155 > arr.delete(16)
 => 16 


array.delete_at(index)
Deletes the element at the speciﬁed index, returning that element, or
nil if the index is out of range.
3.2.1 :156 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :157 > arr.delete_at(10)
 => 23 
3.2.1 :158 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 24, 25] 

array.delete_if { |item| block }

Deletes every element of self for which block evaluates to true.
3.2.1 :161 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :162 > arr.delete_if{|i| i%2==1}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 
########## array.empty?###########
array.empty?
Returns true if the self array contains no elements.

 
########## array.frozen? ###########
array.frozen?
Returns true if array is frozen (or temporarily frozen while being sorted)
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :026 > arr.frozen?
 => false 

 
########## finding ###########
array.include?(obj)
Returns true if obj is present in self, false otherwise.
 
array.include?(obj)
3.2.1 :033 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :034 > arr.include?(7)
 => true 
3.2.1 :035 > arr.include?(10)
 => false 
 
array.index(obj)
Returns the index of t 
 
array.index(obj)
3.2.1 :036 > arr.index(7)
 => 6 
3.2.1 :037 > arr.index(10)
 => nil 
 
########## Methods for Fetching ###########
These methods do not modify self.

    [] or slice: Returns one or more elements.
    a = [:foo, 'bar', 2]
    a[0] # => :foo
    a[2] # => 2
    a # => [:foo, "bar", 2]

    a[-1] # => 2
    a[-2] # => "bar"

    a[0, 2] # => [:foo, "bar"]
    a[1, 2] # => ["bar", 2]

    If start + length is greater than self.length, returns all elements from offset start to the end:

    a = [:foo, 'bar', 2]
    a[0, 4] # => [:foo, "bar", 2]
    a[1, 3] # => ["bar", 2]
    a[2, 2] # => [2]

    If start + length is greater than self.length, returns all elements from offset start to the end:

    a = [:foo, 'bar', 2]
    a[0, 4] # => [:foo, "bar", 2]
    a[1, 3] # => ["bar", 2]
    a[2, 2] # => [2]

    If start == self.size and length >= 0, returns a new empty Array.

    If length is negative, returns nil.

    When a single Range argument range is given, treats range.min as start above and range.size as length above:

    a = [:foo, 'bar', 2]
    a[0..1] # => [:foo, "bar"]
    a[1..2] # => ["bar", 2]

    Special case: If range.start == a.size, returns a new empty Array.

    If range.end is negative, calculates the end index from the end:

    a = [:foo, 'bar', 2]
    a[0..-1] # => [:foo, "bar", 2]
    a[0..-2] # => [:foo, "bar"]
    a[0..-3] # => [:foo]
    
    If range.start is negative, calculates the start index from the end:
    
    a = [:foo, 'bar', 2]
    a[-1..2] # => [2]
    a[-2..2] # => ["bar", 2]
    a[-3..2] # => [:foo, "bar", 2]
    
    If range.start is larger than the array size, returns nil.
    
    a = [:foo, 'bar', 2]
    a[4..1] # => nil
    a[4..0] # => nil
    a[4..-1] # => nil
    


    fetch: Returns the element at a given offset.
    ########## array.fetch ###########
    array.fetch(index) [or]
    array.fetch(index, default) [or]
    array.fetch(index) { |index| block }
    Tries to return the element at position index. If index lies outside the array, the ﬁrst form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking block, passing in index. Negative values of index count from the end of the array.
     
    array.fetch(index) 
    3.2.1 :011 > arr.fetch(10)
     => 11 
    3.2.1 :012 > arr.fetch(11)
    (irb):12:in `fetch': index 11 outside of array bounds: -11...11 (IndexError)         
    
    
    array.fetch(index, default) 
    3.2.1 :013 > arr.fetch(11,404)
     => 404 
    
    array.fetch(index) { |index| block }
    3.2.1 :015 > arr.fetch(10){|i| put i}
     => 11 
    3.2.1 :016 > arr.fetch(11){|i|}
     => nil 
    3.2.1 :017 > arr.fetch(11){|i| i*2}
     => 22 
    3.2.1 :018 > arr.fetch(11){|i| i}
     => 11 
    

    first: Returns one or more leading elements.
    ########## array.first  ###########
    array.ﬁrst [or]
    array.ﬁrst(n)
    Returns the ﬁrst element, or the ﬁrst n elements, of the array. If the
    array is empty, the ﬁrst form returns nil, and the second form returns an
    empty array.
    
    array.ﬁrst
    3.2.1 :078 > arr
     => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
    3.2.1 :079 > arr.first
     => 1 
    
    3.2.1 :082 > arr1=[]
     => [] 
    3.2.1 :084 > arr1.first
     => nil 
    
    array.ﬁrst(n)
    3.2.1 :080 > arr.first(5)
     => [1, 2, 3, 4, 5] 
    3.2.1 :085 > arr1.first(5)
     => [] 
    
    last: Returns one or more trailing elements.
    ########## array.last(n) ###########
    //last(n)
    
    3.2.1 :026 > arr
     => [1, 2, 3, 4, 5] 
    3.2.1 :027 > arr.last
     => 5 
    3.2.1 :028 > arr.last(3)
     => [3, 4, 5] 


    max: Returns one or more maximum-valued elements, as determined by <=> or a given block.
    irb(main):025:0> arr
    => [:one, "two", "3", 4]
    irb(main):026:0> arr.max
    (irb):26:in `max': comparison of Symbol with String failed (ArgumentError)

    irb(main):027:0> nums=Array(1..6)
    => [1, 2, 3, 4, 5, 6]
    irb(main):028:0> nums.max
    => 6
    irb(main):029:0> nums.max(2)
    => [6, 5]
    irb(main):030:0> nums.max(10)
    => [6, 5, 4, 3, 2, 1]
    irb(main):031:0> arr.max {|a,b| a.size <=> b.size}
    => 4
    irb(main):032:0> 4.size
    => 4
    irb(main):033:0> arr[0].size
    => 3
    irb(main):034:0> arr.max(2) {|a,b| a.size <=> b.size}
    => [4, "two"]
    
    
    min: Returns one or more minimum-valued elements, as determined by <=> or a given block.

=>>similar to max it will return min value


    minmax: Returns the minimum-valued and maximum-valued elements, as determined by <=> or a given block.
    irb(main):040:0> nums
    => [1, 2, 3, 4, 5, 6]
    irb(main):041:0> arr
    => [:one, "two", "3", 4]
    irb(main):042:0> nums.minmax
    => [1, 6]
    irb(main):043:0> arr.minmax { |a,b| a.size <=> b.size }
    => ["3", 4]


    assoc: Returns the first element that is an array whose first element == a given object.
########## array.assoc(obj) ###########
Searches through an array whose elements are also arrays comparing obj with the ﬁrst element of each contained array using obj.==. Returns the ﬁrst contained array that matches or nil if no match is found.
3.2.1 :062 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :063 > arr.assoc(1)
 => [1, 2, 3, 4] 
3.2.1 :064 > arr.assoc(500)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :065 > arr.rassoc(500)
 => nil 
3.2.1 :066 > arr.rassoc(404)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :067 > arr.rassoc(1)
 => nil 
3.2.1 :068 > arr.rassoc(2)
 => [1, 2, 3, 4] 


    rassoc: Returns the first element that is an array whose second element == a given object.
3.2.1 :062 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :065 > arr.rassoc(500)
 => nil 
3.2.1 :066 > arr.rassoc(404)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :067 > arr.rassoc(1)
 => nil 
3.2.1 :068 > arr.rassoc(2)
 => [1, 2, 3, 4] 


    at: Returns the element at a given offset.
 
    irb(main):040:0> nums
    => [1, 2, 3, 4, 5, 6]
    irb(main):041:0> arr
    => [:one, "two", "3", 4]
    irb(main):044:0> arr.at(0)
    => :one
    irb(main):045:0> nums.at(6)
    => nil
    irb(main):046:0> nums.at(3)
    => 4

    values_at: Returns the elements at given offsets.
    irb(main):047:0> nums.at(0..3)
    
    (irb):47:in `at': no implicit conversion of Range into Integer (TypeError)
            
    irb(main):048:0> nums.at(0,3)
    (irb):48:in `at': wrong number of arguments (given 2, expected 1) (ArgumentError)

    irb(main):049:0> nums.values_at(0..3)
    => [1, 2, 3, 4]
    irb(main):050:0> nums.values_at(1,3)
    => [2, 4]
    irb(main):051:0> nums.values_at(3,1,2,0)
    => [4, 2, 3, 1]
    irb(main):052:0> nums
    => [1, 2, 3, 4, 5, 6]
    irb(main):053:0> nums.values_at(-3,-1,-2,-0)
    => [4, 6, 5, 1]

    dig: Returns the object in nested objects that is specified by a given index and additional arguments.
    Finds and returns the object in nested objects that is specified by index and identifiers. The nested objects may be instances of various classes. See Dig Methods.

    Examples:
    
    a = [:foo, [:bar, :baz, [:bat, :bam]]]
    a.dig(1) # => [:bar, :baz, [:bat, :bam]]
    a.dig(1, 2) # => [:bat, :bam]
    a.dig(1, 2, 0) # => :bat
    a.dig(1, 2, 3) # => nil
   

    drop: Returns trailing elements as determined by a given index.

    //drop(n)
    drop does the opposite of take, by returning the elements after n elements have been dropped:
    3.2.1 :024 > arr.drop(1)
     => [2, 3, 4, 5] 
    3.2.1 :025 > arr
     => [1, 2, 3, 4, 5]


    take: Returns leading elements as determined by a given index.

    //take(n) 
    to return the first n elements of an array, use take
    
    3.2.1 :020 > arr.take(5)
     => [1, 2, 3, 4, 5] 
    3.2.1 :021 > arr.take(6)
     => [1, 2, 3, 4, 5] 
    3.2.1 :022 > arr.take(10)
     => [1, 2, 3, 4, 5] 

    drop_while: Returns trailing elements as determined by a given block.

    //drop_while  (it is similar to use while loop with drop function)
 
    3.2.1 :097 > num.drop_while {|i| i>3}  (the while loop breaks since the initial condition is not meet for first element)
     => [1, 2, 3, 4, 5] 
    3.2.1 :101 > num.drop_while { |i| i < 3}
     => [3, 4, 5] 
    
    take_while: Returns leading elements as determined by a given block.
=>> similar to drop_while but it return values which satisgy the condition

    slice & slice!: Returns consecutive elements as determined by a given argument.
    array.slice(index) 
    3.2.1 :186 > arr=Array(1..9)
     => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
    3.2.1 :187 > arr.slice(5,8)
     => [6, 7, 8, 9] 
     
     array.slice(range)
     3.2.1 :188 > arr.slice(5..8)
     => [6, 7, 8, 9] 
     
    
    sort and sort!: Returns all elements in an order determined by <=> or a given block.

    a = 'abcde'.split('').shuffle
    a # => ["e", "b", "d", "a", "c"]
    a1 = a.sort
    a1 # => ["a", "b", "c", "d", "e"]

    a1 = a.sort {|a, b| a <=> b }
    a1 # => ["a", "b", "c", "d", "e"]
    a2 = a.sort {|a, b| b <=> a }
    a2 # => ["e", "d", "c", "b", "a"]

    //sort_by
    a = ['aaaa', 'bbb', 'cc', 'd']
    a.sort_by! {|element| element.size }
    a # => ["d", "cc", "bbb", "aaaa"]

    a = ['aaaa', 'bbb', 'cc', 'd']
    a.sort_by! # => #<Enumerator: ["aaaa", "bbb", "cc", "d"]:sort_by!>

    reverse and reverse!: Returns all elements in reverse order.
    a = ['foo', 'bar', 'two']
    a1 = a.reverse
    a1 # => ["two", "bar", "foo"]

    a = [:foo, 'bar', 2]
    a.reverse_each {|element|  puts "#{element.class} #{element}" }
    Output:

    Integer 2
    String bar
    Symbol foo
    
    a = [:foo, 'bar', 2]
    a.reverse_each {|element| puts element; a.clear if element.to_s.start_with?('b') }
    Output:

    2
    bar
    

    compact: Returns an array containing all non-nil elements.
    ########## array.compact & array.compact! (inplace)  ###########
    array.compact
    Returns a copy of self with all nil elements removed.
    
    array.compact!
    Removes nil elements from array. Returns nil if no changes were made.
    
    3.2.1 :132 > arr=Array(1..18)
     => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
    3.2.1 :133 > arr.map!{|i| 
    3.2.1 :134 >   if i%2==0
    3.2.1 :135 >     i
    3.2.1 :136 >   end
    3.2.1 :137 > }.compact
     => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
    3.2.1 :138 > arr
     => 
    [nil,2,nil,4,nil,6,nil,8,nil,10,nil,12,nil,14,nil,16,nil,18] 
    3.2.1 :139 > arr.compact!
     => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
    3.2.1 :140 > arr
     => [2, 4, 6, 8, 10, 12, 14, 16, 18]
     
//compact and compact! 
A useful method if you need to remove nil values from an array is compact:
3.2.1 :072 > arr.compact
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :073 > arr
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen"] 
3.2.1 :074 > arr.compact!
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :075 > arr
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 


    select, filter: Returns an array containing elements selected by a given block.
    3.2.1 :094 > num
    => [1, 2, 3, 4, 5] 
    //select
   3.2.1 :095 > num.select {|i| i>3}
    => [4, 5]

    a = [:foo, 'bar', 2, :bam]
    a.select # => #<Enumerator: [:foo, "bar", 2, :bam]:select>

    uniq and uniq! : Returns an array containing non-duplicate elements.
    a = [0, 0, 1, 1, 2, 2]
    a.uniq # => [0, 1, 2]

    a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
    a.uniq {|element| element.size } # => ["a", "aa", "aaa"]


    rotate and rotate!: Returns all elements with some rotated from one end to the other.

    When no argument given, returns a new Array that is like self, except that the first element has been rotated to the last position:

    a = [:foo, 'bar', 2, 'bar']
    a1 = a.rotate
    a1 # => ["bar", 2, "bar", :foo]
    
    When given a non-negative Integer count, returns a new Array with count elements rotated from the beginning to the end:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(2)
    a1 # => [2, :foo, "bar"]
    
    If count is large, uses count % array.size as the count:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(20)
    a1 # => [2, :foo, "bar"]
    
    If count is zero, returns a copy of self, unmodified:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(0)
    a1 # => [:foo, "bar", 2]
    
    When given a negative Integer count, rotates in the opposite direction, from end to beginning:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(-2)
    a1 # => ["bar", 2, :foo]
    
    If count is small (far from zero), uses count % array.size as the count:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(-5)
    a1 # => ["bar", 2, :foo]
    

    bsearch: Returns an element selected via a binary search as determined by a given block.
    
bsearch example->

arr = [1, 3, 5, 7, 9]

result = arr.bsearch {|x| x > 5}

if result
  puts "First element greater than 5: #{result}"
else
  puts "No elements greater than 5 found"
end

arr=Array(56..78)
 => [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78] 
arr.bsearch {|x| x>67}
 => 68 

    bsearch_index: Returns the index of an element selected via a binary search as determined by a given block.

arr.bsearch_index {|x| x>67}
 => 12 


    sample: Returns one or more random elements.

    Returns random elements from self.

    When no arguments are given, returns a random element from self:
    
    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    a.sample # => 3
    a.sample # => 8
    
    If self is empty, returns nil.
    
    When argument n is given, returns a new Array containing n random elements from self:
    
    a.sample(3) # => [8, 9, 2]
    a.sample(6) # => [9, 6, 10, 3, 1, 4]
    
    Returns no more than a.size elements (because no new duplicates are introduced):
    
    a.sample(a.size * 2) # => [6, 4, 1, 8, 5, 9, 10, 2, 3, 7]
    
    But self may contain duplicates:
    
    a = [1, 1, 1, 2, 2, 3]
    a.sample(a.size * 2) # => [1, 1, 3, 2, 1, 2]
    
    The argument n must be a non-negative numeric value. The order of the result array is unrelated to the order of self. Returns a new empty Array if self is empty.
    
    The optional random argument will be used as the random number generator:
    
    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    a.sample(random: Random.new(1))     #=> 6
    a.sample(4, random: Random.new(1))  #=> [6, 10, 9, 2]
    

    shuffle and shuffle!: Returns elements in a random order.
    a = [1, 2, 3] #=> [1, 2, 3]
    a.shuffle     #=> [2, 3, 1]
    a             #=> [1, 2, 3]

    The optional random argument will be used as the random number generator:

    a.shuffle(random: Random.new(1))  #=> [1, 3, 2]
    
 
########## Methods for Assigning ###########

    []=: Assigns specified elements with a given object.
a = [:foo, 'bar', 2]
a[0] = 'foo' # => "foo"
a # => ["foo", "bar", 2]

If index is greater than self.length, extends the array:

a = [:foo, 'bar', 2]
a[7] = 'foo' # => "foo"
a # => [:foo, "bar", 2, nil, nil, nil, nil, "foo"]

If index is negative, counts backwards from the end of the array:

a = [:foo, 'bar', 2]
a[-1] = 'two' # => "two"
a # => [:foo, "bar", "two"]
    
 a = [:foo, 'bar', 2]  # => [:foo, "bar", 2] 
 a[-2, 0]=200  # => 200 
 a       # => [:foo, 200, "bar", 2] 
 
When Integer arguments start and length are given and object is not an Array, removes length - 1 elements beginning at offset start, and assigns object at offset start:

a = [:foo, 'bar', 2]
a[0, 2] = 'foo' # => "foo"
a # => ["foo", 2]

If start is negative, counts backwards from the end of the array:

a = [:foo, 'bar', 2]
a[-2, 2] = 'foo' # => "foo"
a # => [:foo, "foo"]

If start is non-negative and outside the array ( >= self.size), extends the array with nil, assigns object at offset start, and ignores length:

a = [:foo, 'bar', 2]
a[6, 50] = 'foo' # => "foo"
a # => [:foo, "bar", 2, nil, nil, nil, "foo"]

If length is zero, shifts elements at and following offset start and assigns object at offset start:

a = [:foo, 'bar', 2]
a[1, 0] = 'foo' # => "foo"
a # => [:foo, "foo", "bar", 2]

If length is too large for the existing array, does not extend the array:

a = [:foo, 'bar', 2]
a[1, 5] = 'foo' # => "foo"
a # => [:foo, "foo"]

When Range argument range is given and object is an Array, removes length - 1 elements beginning at offset start, and assigns object at offset start:

a = [:foo, 'bar', 2]
a[0..1] = 'foo' # => "foo"
a # => ["foo", 2]

if range.begin is negative, counts backwards from the end of the array:

a = [:foo, 'bar', 2]
a[-2..2] = 'foo' # => "foo"
a # => [:foo, "foo"]

If the array length is less than range.begin, assigns object at offset range.begin, and ignores length:

a = [:foo, 'bar', 2]
a[6..50] = 'foo' # => "foo"
a # => [:foo, "bar", 2, nil, nil, nil, "foo"]

If range.end is zero, shifts elements at and following offset start and assigns object at offset start:

a = [:foo, 'bar', 2]
a[1..0] = 'foo' # => "foo"
a # => [:foo, "foo", "bar", 2]

If range.end is negative, assigns object at offset start, retains range.end.abs -1 elements past that, and removes those beyond:

a = [:foo, 'bar', 2]
a[1..-1] = 'foo' # => "foo"
a # => [:foo, "foo"]
a = [:foo, 'bar', 2]
a[1..-2] = 'foo' # => "foo"
a # => [:foo, "foo", 2]
a = [:foo, 'bar', 2]
a[1..-3] = 'foo' # => "foo"
a # => [:foo, "foo", "bar", 2]
a = [:foo, 'bar', 2]

If range.end is too large for the existing array, replaces array elements, but does not extend the array with nil values:

a = [:foo, 'bar', 2]
a[1..5] = 'foo' # => "foo"
a # => [:foo, "foo"]



    push, append, <<: Appends trailing elements.

a = [:foo, 'bar', 2]
a.push(:baz, :bat) # => [:foo, "bar", 2, :baz, :bat]

Appends each argument as one element, even if it is another Array:

//push & append
a = [:foo, 'bar', 2]
a1 = a.push([:baz, :bat], [:bam, :bad])
a1 # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]

//<<
a = [:foo, 'bar', 2]
a << :baz # => [:foo, "bar", 2, :baz]

a = [:foo, 'bar', 2]	#=> [:foo, "bar", 2] 
a1=a<<[3,4]	# => [:foo, "bar", 2, [3, 4]] 
a	# => [:foo, "bar", 2, [3, 4]] 
a1	# => [:foo, "bar", 2, [3, 4]] 



    unshift, prepend: add obj at start of array.
Prepends the given objects to self:

a = [:foo, 'bar', 2]
a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]



    insert: Inserts given objects at a given offset; does not replace elements.
a = [:foo, 'bar', 2]
a.insert(1, :bat, :bam) # => [:foo, :bat, :bam, "bar", 2]

Extends the array if index is beyond the array (index >= self.size):

a = [:foo, 'bar', 2]
a.insert(5, :bat, :bam)
a # => [:foo, "bar", 2, nil, nil, :bat, :bam]

Does nothing if no objects given:

a = [:foo, 'bar', 2]
a.insert(1)
a.insert(50)
a.insert(-50)
a # => [:foo, "bar", 2]

When index is negative, inserts all given objects after the element at offset index+self.size:

a = [:foo, 'bar', 2]
a.insert(-2, :bat, :bam)
a # => [:foo, "bar", :bat, :bam, 2]

    concat: Appends all elements from given arrays.
a = [0, 1]
a.concat([2, 3], [4, 5]) # => [0, 1, 2, 3, 4, 5]


    fill: Replaces specified elements with specified objects.
########## arr.fill ###########
array.ﬁll(obj) [or]
array.ﬁll(obj, start , length) [or]
array.ﬁll(obj, range) [or]
array.ﬁll { |index| block } [or]
array.ﬁll([start , length] ) { |index| block } [or]
array.ﬁll(range) { |index| block }
The ﬁrst three forms set the selected elements of self to obj. A start of
nil is equivalent to zero. A length of nil is equivalent to self.length. The
last three forms ﬁll the array with the value of the block. The block is
passed with the absolute index of each element to be ﬁlled.
 
array.ﬁll(obj)
3.2.1 :019 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :020 > arr.fill(404)
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404] 
3.2.1 :021 > arr
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404]
 
 
array.ﬁll(obj, start , length)
3.2.1 :029 > arr.fill(404,3 ,4)
 => [1, 2, 3, 404, 404, 404, 404, 8, 9, 10, 11] 
 
  
array.ﬁll(obj, range)
3.2.1 :031 > arr.fill(404,3..4)
 => [1, 2, 3, 404, 404, 6, 7, 8, 9, 10, 11] 
 

array.ﬁll { |index| block } 
3.2.1 :044 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 

3.2.1 :045 > arr.fill{|i|
3.2.1 :046 >   if i%2==0
3.2.1 :047 >     404
3.2.1 :048 >   else 
3.2.1 :049 >     i
3.2.1 :050 >   end
3.2.1 :051 > }
 => [404, 1, 404, 3, 404, 5, 404, 7, 404, 9, 404] 
 

array.ﬁll(start , length) { |index| block }
3.2.1 :059 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :060 > arr.fill(3,4){|i|
3.2.1 :061 >   if i%2==0
3.2.1 :062 >     404
3.2.1 :063 >   else 
3.2.1 :064 >     i
3.2.1 :065 >   end
3.2.1 :066 > }
 => [1, 2, 3, 3, 404, 5, 404, 8, 9, 10, 11] 


array.ﬁll(range) { |index| block }
3.2.1 :067 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :068 > arr.fill(3..4){|i|
3.2.1 :069 >   if i%2==0
3.2.1 :070 >     404
3.2.1 :071 >   else 
3.2.1 :072 >     i
3.2.1 :073 >   end
3.2.1 :074 > }
 => [1, 2, 3, 3, 404, 6, 7, 8, 9, 10, 11] 
3.2.1 :075 > 
 


    replace: Replaces the content of self with the content of a given array.

a = [:foo, 'bar', 2]
a.replace(['foo', :bar, 3]) # => ["foo", :bar, 3]
a # => ["foo", :bar, 3] 

    reverse!: Replaces self with its elements reversed.
==> inplace version of Replace method

    rotate!: Replaces self with its elements rotated.
==> inplace version of rotate method

    shuffle!: Replaces self with its elements in random order.
==> inplace version of shuffle method

    sort!: Replaces self with its elements sorted, as determined by <=> or a given block.
==> inplace version of sort method

    sort_by!: Replaces self with its elements sorted, as determined by a given block.
==> inplace version of sort_by method

 
 
########## Methods for Deleting ###########


    pop: Removes and returns the last element.
a = [:foo, 'bar', 2]
a.pop # => 2
a # => [:foo, "bar"]

a = [:foo, 'bar', 2]
a.pop(2) # => ["bar", 2]

a = [:foo, 'bar', 2]
a.pop(50) # => [:foo, "bar", 2]

   

    shift: Removes and returns the first element.
a = [:foo, 'bar', 2]
a.shift # => :foo
a # => ['bar', 2]

a = [:foo, 'bar', 2]
a.shift(2) # => [:foo, 'bar']
a # => [2]

a = [:foo, 'bar', 2]	# => [:foo, "bar", 2] 
a.shift(10)	# => [:foo, "bar", 2]  
a	# => [] 
a.shift		# => nil 
a.shift(10)	# => [] 

a = [:foo, 'bar', 2]	# => [:foo, "bar", 2] 
a.shift(0)	# => [] 
a	# => [:foo, "bar", 2] 


    compact!: Removes all nil elements.
==>>in place version of compact method

    delete: Removes elements equal to a given object.
s1 = 'bar'; s2 = 'bar'
a = [:foo, s1, 2, s2]
a.delete('bar') # => "bar"
a # => [:foo, 2]

If any such elements are found, ignores the block and returns the last deleted element:

s1 = 'bar'; s2 = 'bar'
a = [:foo, s1, 2, s2]
deleted_obj = a.delete('bar') {|obj| fail 'Cannot happen' }
a # => [:foo, 2]

If no such elements are found, returns the block’s return value:

a = [:foo, 'bar', 2]
a.delete(:nosuch) {|obj| "#{obj} not found" } # => "nosuch not found"


    delete_at: Removes the element at a given offset.
a = [:foo, 'bar', 2]
a.delete_at(1) # => "bar"
a # => [:foo, 2]

a = [:foo, 'bar', 2]  	# => [:foo, "bar", 2] 
a.delete_at(5)		# => nil 


    delete_if: Removes elements specified by a given block.

3.2.1 :103 > num.delete_if {|i| i>3}
 => [1, 2, 3] 
3.2.1 :104 > num
 => [1, 2, 3]
  
array.delete_if { |item| block }

Deletes every element of self for which block evaluates to true.
3.2.1 :161 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :162 > arr.delete_if{|i| i%2==1}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 


    keep_if: Removes elements not specified by a given block.
 
num.keep_if {|i| i>3}	# => []  
num	# => [] 

a = [:foo, 'bar', 2, :bam]
a.keep_if {|element| element.to_s.start_with?('b') } # => ["bar", :bam]

    reject!: Removes elements specified by a given block.
==> inplace version of reject method

    select!, filter!: Removes elements not specified by a given block.
==> inplace version of select method

    slice!: Removes and returns a sequence of elements.
==> inplace version of slice method

    uniq!: Removes duplicates.
==> inplace version of uniq method

 
########## Methods for Combining ###########


    &: (interseection of arrays) Returns an array containing elements found both in self and a given array.
   ########## array & other_array ###########
Returns a new array containing elements common to the two arrays, with no duplicates.

[0, 1, 2, 3] & [1, 2] # => [1, 2]
[0, 1, 0, 1] & [0, 1] # => [0, 1]

Preserves order from array:

[0, 1, 2] & [3, 2, 1, 0] # => [0, 1, 2]


arr=[1,2,3,4,5] 	# => [1, 2, 3, 4, 5] 
arr2=[1,3,6,3,6,7,5]	# => [1, 3, 6, 3, 6, 7, 5] 
arr & arr2	# => [1, 3, 5]  


    intersection: Returns an array containing elements found both in self and in each given array.
==> same as & method but it preserve order according to self
[0, 1, 2].intersection([2, 1, 0]) # => [0, 1, 2]


    +: Returns an array containing all elements of self followed by all elements of a given array.
########## array + other_array ###########
Returns a new array built by concatenating the two arrays together to produce a third array.
arr3= arr + str	   # => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
arr4 = arr + arr2	# => [1, 2, 3, 4, 5, 1, 3, 6, 3, 6, 7, 5] 
 
a = [0, 1] + [2, 3]
a # => [0, 1, 2, 3]



    -: Returns an array containing all elements of self that are not found in a given array.

########## array - other_array ###########
Returns a new array that is a copy of the original array, removing any items that also appear in other_array.
arr3	# => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
arr3-arr	# => ["Ram", "Shayam", "Radha"] 



    |: Returns an array containing all elements of self and all elements of a given array, duplicates removed.

########## array | other_array ###########
Returns a new array by joining array with other_array, removing
duplicates.
arr	# => [1, 2, 3, 4, 5] 
arr2	# => [1, 3, 6, 3, 6, 7, 5] 
arr | arr2	# => [1, 2, 3, 4, 5, 6, 7]



    union: Returns an array containing all elements of self and all elements of given arrays, duplicates removed.

[0, 1, 2, 3].union([4, 5], [6, 7]) # => [0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 1].union([2, 1], [3, 1]) # => [0, 1, 2, 3]
[0, 1, 2, 3].union([3, 2], [1, 0]) # => [0, 1, 2, 3]

Returns a copy of self if no arguments given.


    difference: (self - intersection) Returns an array containing all elements of self that are not found in any of the given arrays..
    
[0, 1, 1, 2, 1, 1, 3, 1, 1].difference([1]) # => [0, 2, 3]
[0, 1, 2, 3].difference([3, 0], [1, 3]) # => [2]
[0, 1, 2].difference([4]) # => [0, 1, 2]

Returns a copy of self if no arguments given.



    product:(cross product or arrays) Returns or yields all combinations of elements from self and given arrays.
a=Array(1..3)	# => [1, 2, 3] 
b=Array(4..7)	# => [4, 5, 6, 7] 
c=Array(11..15)	# => [11, 12, 13, 14, 15] 

p= a.product(b)	# => [[1, 4], [1, 5], [1, 6], [1, 7], [2, 4], [2, 5], [2, 6], [2, 7], [3, 4], [3, 5], [3, 6], [3, 7]] 

q= b.product(a)	# => [[4, 1], [4, 2], [4, 3], [5, 1], [5, 2], [5, 3], [6, 1], [6, 2], [6, 3], [7, 1], [7, 2], [7, 3]] 

r=a.product(b,c)	# => 
[[1, 4, 11],                                 
...                                          

s=a.product(b,b) # => 
[[1, 4, 4],                                  
...    
 
If no argument is given, returns an Array of 1-element Arrays, each containing an element of self:

a.product # => [[0], [1], [2]]

When a block is given, yields each combination as an Array; returns self:

a.product(a1) {|combination| p combination }

Output:

[0, 3]
[0, 4]
[1, 3]
[1, 4]
[2, 3]
[2, 4]

If any argument is an empty Array, does not call the block:

a.product(a1, a2, []) {|combination| fail 'Cannot happen' }

If no argument is given, yields each element of self as a 1-element Array:

a.product {|combination| p combination }

Output:

[0]
[1]
[2]
  
########## Methods for Iterating ###########

    each: Passes each element to a given block.
    			&
    each_index: Passes each element index to a given block.
    
########## array.each { |item| block } and array.each_index { |index| block } ###########

array.each { |item| block }
Calls block once for each element in self, passing that element as a
parameter.

array.each_index { |index| block }
Same as Array#each, but passes the index of the element instead of the
element itself.

arr.each {|i| print "#{i} "}
66 67 68 69 70 71  => [66, 67, 68, 69, 70, 71] 

arr.each_index {|i| print "#{i} "}
0 1 2 3 4 5  => [66, 67, 68, 69, 70, 71] 


arr.each {|i| print i.to_s + " :"}
2 :4 :6 :8 :10 :12 :14 :16 :18 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 

arr.each_index {|i| print i.to_s + " :"}
0 :1 :2 :3 :4 :5 :6 :7 :8 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 


Allows the array to be modified during iteration:

a = [:foo, 'bar', 2]
a.each {|element| puts element; a.clear if element.to_s.start_with?('b') } 
Output:
foo
bar

a = [:foo, 'bar', 2]
a.each_index {|index| puts index; a.clear if index > 0 }
Output:
0
1



    reverse_each: Passes each element, in reverse order, to a given block.

arr.reverse_each {|i| print i, " "}
sixteen Apple 6 200 5 4 3 2 1 one 404  => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"]                                               

words=%w[hello world ruby]
 => ["hello", "world", "ruby"] 
str=""
 => "" 
words.reverse_each {|i| str += "#{i}"}
 => ["hello", "world", "ruby"] 
str
 => "rubyworldhello" 

str=""
 => "" 
words.reverse_each {|i| str += "#{i} "}
 => ["hello", "world", "ruby"]  
words.reverse_each {|i| str += "#{i} "}
 => ["hello", "world", "ruby"] 
a = [:foo, 'bar', 2]

a.reverse_each {|element|  puts "#{element.class} #{element}" }
Output:
    Integer 2
    String bar
    Symbol foo
    
    a = [:foo, 'bar', 2]
    a.reverse_each {|element| puts element; a.clear if element.to_s.start_with?('b') }
    Output:

    2
    bar
    

    cycle: Calls a given block with each element, then does so again, for a specified number of times, or forever.

output = []
[0, 1].cycle(2) {|element| output.push(element) } # => nil
output # => [0, 1, 0, 1]

If count is zero or negative, does not call the block:

[0, 1].cycle(0) {|element| fail 'Cannot happen' } # => nil
[0, 1].cycle(-1) {|element| fail 'Cannot happen' } # => nil

When a block is given, and argument is omitted or nil, cycles forever:

# Prints 0 and 1 forever.
[0, 1].cycle {|element| puts element }
[0, 1].cycle(nil) {|element| puts element }

When no block is given, returns a new Enumerator:

[0, 1].cycle(2) # => #<Enumerator: [0, 1]:cycle(2)>
[0, 1].cycle # => # => #<Enumerator: [0, 1]:cycle>
[0, 1].cycle.first(5) # => [0, 1, 0, 1, 0]



    combination: Calls a given block with combinations of elements of self; a combination does not use the same element more than once.
a = [0, 1, 2]
a.combination(2) {|combination| p combination }
Output:
[0, 1]
[0, 2]
[1, 2]

Another example:
a = [0, 1, 2]
a.combination(3) {|combination| p combination }
Output:
[0, 1, 2]

When n is zero, calls the block once with a new empty Array:
a = [0, 1, 2]
a1 = a.combination(0) {|combination| p combination }
Output:
[]


When n is out of range (negative or larger than self.size), does not call the block:
a = [0, 1, 2]
a.combination(-1) {|combination| fail 'Cannot happen' }
a.combination(4) {|combination| fail 'Cannot happen' }


Returns a new Enumerator if no block given:
a = [0, 1, 2]
a.combination(2) # => #<Enumerator: [0, 1, 2]:combination(2)>


When a block given but no argument, it throws error
a.combination {|combination| p combination }
(irb):148:in `combination': wrong number of arguments (given 0, expected 1) (ArgumentError) 



    permutation: Calls a given block with permutations of elements of self; a permutation does not use the same element more than once.
a = [0, 1, 2]
a.permutation(2) {|permutation| p permutation }
Output:
[0, 1]
[0, 2]
[1, 0]
[1, 2]
[2, 0]
[2, 1]

Another example:
a = [0, 1, 2]
a.permutation(3) {|permutation| p permutation }
Output:
[0, 1, 2]
[0, 2, 1]
[1, 0, 2]
[1, 2, 0]
[2, 0, 1]
[2, 1, 0]


When n is zero, calls the block once with a new empty Array:
a = [0, 1, 2]
a.permutation(0) {|permutation| p permutation }
Output:
[]


When n is out of range (negative or larger than self.size), does not call the block:
a = [0, 1, 2]
a.permutation(-1) {|permutation| fail 'Cannot happen' }
a.permutation(4) {|permutation| fail 'Cannot happen' }


When a block given but no argument, behaves the same as a.permutation(a.size):
a = [0, 1, 2]
a.permutation {|permutation| p permutation }
Output:
[0, 1, 2]
[0, 2, 1]
[1, 0, 2]
[1, 2, 0]
[2, 0, 1]
[2, 1, 0]


Returns a new Enumerator if no block given:
a = [0, 1, 2]
a.permutation # => #<Enumerator: [0, 1, 2]:permutation>
a.permutation(2) # => #<Enumerator: [0, 1, 2]:permutation(2)>





============== the difference it that the can be called with itself also in repeated P or C i.e 00,11,22, etc if n=2 =============


    repeated_combination: Calls a given block with combinations of elements of self; a combination may use the same element more than once.

a = [0, 1, 2]
a.repeated_combination(1) {|combination| p combination }

Output:

[0]
[1]
[2]

n = 2:

a.repeated_combination(2) {|combination| p combination }

Output:

[0, 0]
[0, 1]
[0, 2]
[1, 1]
[1, 2]
[2, 2]

If n is zero, calls the block once with an empty Array.

If n is negative, does not call the block:

a.repeated_combination(-1) {|combination| fail 'Cannot happen' }

Returns a new Enumerator if no block given:

a = [0, 1, 2]
a.repeated_combination(2) # => #<Enumerator: [0, 1, 2]:combination(2)>

Using Enumerators, it’s convenient to show the combinations and counts for some values of n:

e = a.repeated_combination(0)
e.size # => 1
e.to_a # => [[]]
e = a.repeated_combination(1)
e.size # => 3
e.to_a # => [[0], [1], [2]]
e = a.repeated_combination(2)
e.size # => 6
e.to_a # => [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]


    repeated_permutation: Calls a given block with permutations of elements of self; a permutation may use the same element more than once.

a = [0, 1, 2]
a.repeated_permutation(1) {|permutation| p permutation }

Output:

[0]
[1]
[2]

n = 2:

a.repeated_permutation(2) {|permutation| p permutation }

Output:

[0, 0]
[0, 1]
[0, 2]
[1, 0]
[1, 1]
[1, 2]
[2, 0]
[2, 1]
[2, 2]

If n is zero, calls the block once with an empty Array.

If n is negative, does not call the block:

a.repeated_permutation(-1) {|permutation| fail 'Cannot happen' }

Returns a new Enumerator if no block given:

a = [0, 1, 2]
a.repeated_permutation(2) # => #<Enumerator: [0, 1, 2]:permutation(2)>

Using Enumerators, it’s convenient to show the permutations and counts for some values of n:

e = a.repeated_permutation(0)
e.size # => 1
e.to_a # => [[]]
e = a.repeated_permutation(1)
e.size # => 3
e.to_a # => [[0], [1], [2]]
e = a.repeated_permutation(2)
e.size # => 9
e.to_a # => [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]


########## Methods for Converting ###########

    map, collect: Returns an array containing the block return-value for each element.
    				&
    map!, collect!: Replaces each element with a block return-value.

arr.map {|i| i*2}	#=> [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
arr	#=> [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
arr.map! {|i| i*2}	# => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
arr	# => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
 
Returns a new Enumerator if no block given:
a = [:foo, 'bar', 2]
a1 = a.map
a1 # => #<Enumerator: [:foo, "bar", 2]:map>

########## array.collect { |item| block } [or]
array.map { |item| block } (return new array) ###########

arr=Array(1..18)	# => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
arr.map{|i| 
  if i%2==0
    i
  end
}	# => [nil,2,nil,4,nil,6,nil,8,nil,10,nil,12,nil,14,nil,16,nil,18] 

arr.map{|i| 
  if i%2==0
    i
  end
}	#=>[nil,2,nil,4,nil,6,nil,8,nil,10,nil,12,nil,14,nil,16,nil,18] 


########## array.collect! { |item| block } [or]
array.map! { |item| block } (it will change the original value of arr #inplace) ###########
arr=Array(1..18)	# => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
arr.map!{|i| 
  if i%2==0
    i
  end
}	# => [nil,2,nil,4,nil,6,nil,8,nil,10,nil,12,nil,14,nil,16,nil,18]
 
arr.map!{|i| 
  if i%2==0
    i
  end
}
(irb):105:in `block in <top (required)>': undefined method `%' for nil:NilClass (NoMethodError)



    flatten: Returns an array that is a recursive flattening of self.
				&
    flatten!: Replaces each nested array in self with the elements from that array.

array.ﬂatten
arr=Array(1..5)		# => [1, 2, 3, 4, 5] 
arr1=Array(6..8)	# => [6, 7, 8] 
arr[5]=arr1		# => [6, 7, 8] 
arr		# => [1, 2, 3, 4, 5, [6, 7, 8]] 
arr.flatten	# => [1, 2, 3, 4, 5, 6, 7, 8] 
arr	# => [1, 2, 3, 4, 5, [6, 7, 8]] 
 
array.ﬂatten!
arr.flatten!	# => [1, 2, 3, 4, 5, 6, 7, 8] 
arr	# => [1, 2, 3, 4, 5, 6, 7, 8] 


With non-negative Integer argument level, flattens recursively through level levels:
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(0) # => [0, [1, [2, 3], 4], 5]

a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(1) # => [0, 1, [2, 3], 4, 5]

a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(2) # => [0, 1, 2, 3, 4, 5]

a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(3) # => [0, 1, 2, 3, 4, 5]

With no argument, a nil argument, or with negative argument level, flattens all levels:
a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten # => [0, 1, 2, 3, 4, 5]

[0, 1, 2].flatten # => [0, 1, 2]

a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(nil) # => [0, 1, 2, 3, 4, 5]

a = [ 0, [ 1, [2, 3], 4 ], 5 ]
a.flatten(-2) # => [0, 1, 2, 3, 4, 5]

[0, 1, 2].flatten(-1) # => [0, 1, 2]



    inspect, to_s: Returns a new String containing the elements.

a = [:foo, 'bar', 2]
a.inspect # => "[:foo, \"bar\", 2]"



    join: Returns a newsString containing the elements joined by the field separator.

With no argument, joins using the output field separator, $,:

a = [:foo, 'bar', 2]
$, # => nil
a.join # => "foobar2"

With string argument separator, joins using that separator:

a = [:foo, 'bar', 2]
a.join("\n") # => "foo\nbar\n2"

Joins recursively for nested Arrays:

a = [:foo, [:bar, [:baz, :bat]]]
a.join # => "foobarbazbat"


    to_a: Returns self or a new array containing all elements.

When self is an instance of Array, returns self:

a = [:foo, 'bar', 2]
a.to_a # => [:foo, "bar", 2]

Otherwise, returns a new Array containing the elements of self:

class MyArray < Array; end
a = MyArray.new(['foo', 'bar', 'two'])
a.instance_of?(Array) # => false
a.kind_of?(Array) # => true
a1 = a.to_a
a1 # => ["foo", "bar", "two"]
a1.class # => Array # Not MyArray


    to_ary: (similar to to_a but different in working) Returns self.
    

==>>to_ary allows an object to be treated as an array, whereas to_a actually tries to convert the parameter into an array.

==>>to_ary can be useful for parallel assignment, whereas to_a is more suited for an actual conversion.

==>>Calling #to_a will convert the receiver to an Array, while #to_ary will not.

ruby-1.9.2-p290 :001 > class A < Array; end

ruby-1.9.2-p290 :004 > A[].to_a.class
 => Array

ruby-1.9.2-p290 :005 > A[].to_ary.class
 => A 
    
    to_h: Returns a new hash formed from the elements.

[].to_h # => {}
a = [['foo', 'zero'], ['bar', 'one'], ['baz', 'two']]
h = a.to_h
h # => {"foo"=>"zero", "bar"=>"one", "baz"=>"two"}

When a block is given, calls the block with each array element; the block must return a 2-element Array whose two elements form a key-value pair in the returned Hash:
a = ['foo', :bar, 1, [2, 3], {baz: 4}]
h = a.to_h {|item| [item, item] }
h # => {"foo"=>"foo", :bar=>:bar, 1=>1, [2, 3]=>[2, 3], {:baz=>4}=>{:baz=>4}}

    transpose: Transposes self, which must be an array of arrays.
Transposes the rows and columns in an Array of Arrays; the nested Arrays must all be the same size:

a = [[:a0, :a1], [:b0, :b1], [:c0, :c1]]
a.transpose # => [[:a0, :b0, :c0], [:a1, :b1, :c1]]


    zip: Returns a new array of arrays containing self and given arrays;
    
If all other_arrays and self are the same size:

a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3]
c = [:c0, :c1, :c2, :c3]
d = a.zip(b, c)
d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]

If any array in other_arrays is smaller than self, fills to self.size with nil:

a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2]
c = [:c0, :c1]
d = a.zip(b, c)
d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]

If any array in other_arrays is larger than self, its trailing elements are ignored:

a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3, :b4]
c = [:c0, :c1, :c2, :c3, :c4, :c5]
d = a.zip(b, c)
d # => [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]

When a block is given, calls the block with each of the sub-arrays (formed as above); returns nil:

a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3]
c = [:c0, :c1, :c2, :c3]
a.zip(b, c) {|sub_array| p sub_array} # => nil

Output:

[:a0, :b0, :c0]
[:a1, :b1, :c1]
[:a2, :b2, :c2]
[:a3, :b3, :c3]

 
########## Other Methods ###########


    *: Returns one of the following:

        With integer argument n, a new array that is the concatenation of n copies of self.

        With string argument field_separator, a new string that is equivalent to join(field_separator).

########## array * int ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

arr3 = arr*1
 => [1, 2, 3, 4, 5] 

arr3 = arr*2
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 

arr3 = arr*3
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
 
str * 1
 => ["Ram", "Shayam", "Radha"] 
str * 2
 => ["Ram", "Shayam", "Radha", "Ram", "Shayam", "Radha"] 

########## array * str ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to array.join(string_separator: str):

str =['Ram','Shayam','Radha']
 => ["Ram", "Shayam", "Radha"] 

str * ","
 => "Ram,Shayam,Radha" 

str * "R"
 => "RamRShayamRRadha" 

str * "<+>"
 => "Ram<+>Shayam<+>Radha" 
 
arr*","
 => "1,2,3,4,5" 

arr*"=>"
 => "1=>2=>3=>4=>5" 

  
    abbrev: Returns a hash of unambiguous abbreviations for elements.
    ########## array.abbrev(pattern = nil) ###########


require 'abbrev'
 => true 

str=['Neeraj','Kumar']
 => ["Neeraj", "Kumar"] 

str.abbrev
 => 
{"Neeraj"=>"Neeraj",                             
 "Neera"=>"Neeraj",                              
 "Neer"=>"Neeraj",                               
 "Nee"=>"Neeraj",                                
 "Ne"=>"Neeraj",                                 
 "N"=>"Neeraj",                                  
 "Kumar"=>"Kumar",                               
 "Kuma"=>"Kumar",                                
 "Kum"=>"Kumar",                                 
 "Ku"=>"Kumar",                                  
 "K"=>"Kumar"}  

%w{ car cone }.abbrev
#=> {"car"=>"car", "ca"=>"car", "cone"=>"cone", "con"=>"cone", "co"=>"cone"}



The optional pattern parameter is a pattern or a string. Only input strings that match the pattern or start with the string are included in the output hash.
%w{ fast boat day }.abbrev(/^.a/)
#=> {"fast"=>"fast", "fas"=>"fast", "fa"=>"fast", "day"=>"day", "da"=>"day"}

Abbrev.abbrev(%w{car box cone}, "ca")
#=> {"car"=>"car", "ca"=>"car"}
    
    sum: Returns a sum of elements according to either + or a given block.
  
sum(init = 0) → object
sum(init = 0) {|element| ... } → object

For example, [e1, e2, e3].sum returns init + e1 + e2 + e3.

Examples:

a = [0, 1, 2, 3]
a.sum # => 6
a.sum(100) # => 106

The elements need not be numeric, but must be +-compatible with each other and with init:

a = ['abc', 'def', 'ghi']
a.sum('jkl') # => "jklabcdefghi"

When a block is given, it is called with each element and the block’s return value (instead of the element itself) is used as the addend:

a = ['zero', 1, :two]
s = a.sum('Coerced and concatenated: ') {|element| element.to_s }
s # => "Coerced and concatenated: zero1two"

Notes:

    Array#join and Array#flatten may be faster than Array#sum for an Array of Strings or an Array of Arrays.

    Array#sum method may not respect method redefinition of “+” methods such as Integer#+.

 
########## Array.reduce  ###########
The ‘reduce’ method can be used to take an array and reduce it to a single value. Lets start with a simple demonstration of this method.

Lets say we want write a method to find the sum of all numbers in an array of numbers. You may be inclined to write your code in this manner:

def sum(array)
  sum = 0
  array.each do |number|
    sum += number
  end
  return sum 
end p sum([5, 10, 20])
# => 35

Using the reduce method however, we can reduce the code inside the sum method into a single line:

def sum(array)
  array.reduce(0) { |sum, num| sum + num }
endp sum([5, 10, 20])
# => 35

Looking at the above, the ‘0’ in ‘array.reduce(0) sets the initial value.

After that, we have two parameters in the method (|sum, num|). The first parameter, which we call ‘sum’ here is the total that will eventually be returned. The second parameter, which we call ‘num’ is the current number as we iterate through the array. After that, with ‘sum + num’ we are essentially telling the method that we we want to add the current number to the sum each time we iterate through. In the example above, the sum would increase from 0, to 5, to 15, and finally to 35.

We can refactor the code even more by using this shortcut:

def sum(array)
  array.reduce(:+)
endp sum([5, 10, 20])
# => 35

Note that ‘reduce’ method is often called ‘inject’.

In Ruby, the reduce method can be written using several shorthand methods. Here are a few examples:
1=> array.reduce(:+) - calculates the sum of all elements in the array using the addition operator.
2=> array.reduce(:*) - calculates the product of all elements in the array using the multiplication operator.
3=> array.reduce(:-) or array.reduce(:subtract) - calculates the difference between all elements in the array using the subtraction operator.
4=> array.reduce(:/) or array.reduce(:divide) - calculates the quotient of all elements in the array using the division operator.
5=> array.reduce(:**) or array.reduce(:pow) - calculates the result of raising all elements in the array to the power of the previous element.
6=> array.reduce(&:method_name) - calculates the result of calling a specific method on each element in the array.

