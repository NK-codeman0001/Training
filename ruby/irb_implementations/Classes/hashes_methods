_____________________________________________________________________________________
Hashes (map in C++, dictonary in python)
_____________________________________________________________________________________
########## [] ###########
states = {
	:PN => "Punjab"
	"DL" => "Delhi"
	1 => "Haryana"
	}
	
Alternatively, but only for a Hash key that’s a Symbol, you can use a newer JSON-style syntax, where each bareword becomes a Symbol:
**BEST**
h = {foo: 0, bar: 1, baz: 2}
h # => {:foo=>0, :bar=>1, :baz=>2}

But it’s an error to try the JSON-style syntax for a key that’s not a bareword or a String:

# Raises SyntaxError (syntax error, unexpected ':', expecting =>):
h = {0: 'zero'}

h = {foo: 0, bar: 1, baz: 2}
h[:bat] = 3 # => 3
h # => {:foo=>0, :bar=>1, :baz=>2, :bat=>3}
h[:foo] = 4 # => 4
h # => {:foo=>4, :bar=>1, :baz=>2, :bat=>3}

The simplest way to delete a Hash entry (instance method delete):

h = {foo: 0, bar: 1, baz: 2}
h.delete(:bar) # => 1
h # => {:foo=>0, :baz=>2}

########## puts ###########
puts states
puts states[1]
puts states["DL"]
puts states[:PN]

########## Default Values ###########
counts = {foo: 42}
counts.default # => nil (default)
counts[:foo] = 42
counts[:bar] # => nil
counts.default = 0
counts[:bar] # => 0
counts.values_at(:foo, :bar, :baz) # => [42, 0, 0]
counts.dig(:bar) # => 0


########## Methods for Creating a Hash ###########

    ::[]: Returns a new hash populated with given objects.
    
(*)=> 	Hash[] → new_empty_hash
With no argument, returns a new empty Hash.

(*)=> 	Hash[hash] → new_hash
h = {foo: 0, bar: 1, baz: 2}
Hash[h] # => {:foo=>0, :bar=>1, :baz=>2}

(*)=> 	Hash[ [*2_element_arrays] ] → new_hash
Hash[ [ [:foo, 0], [:bar, 1] ] ] # => {:foo=>0, :bar=>1}

(*)=> 	Hash[*objects] → new_hash
Hash[:foo, 0, :bar, 1] # => {:foo=>0, :bar=>1}
_____________________________________________________________________
      
    ::new: Returns a new empty hash.

(*)=> 	Hash.new(default_value = nil) → new_hash
h = Hash.new
h.default # => nil
h.default_proc # => nil

h = Hash.new(false)
h.default # => false
h.default_proc # => nil
h.default_proc.class	# => NilClass
h[:nosuch] 	# => false 

If a block given but no argument, stores the block as the default proc and sets the default value to nil:

(*)=> 	Hash.new {|hash, key| ... } → new_hash

Example
h = Hash.new {|hash, key| "Default value for #{key}" }
h.default # => nil
h.default_proc	# => #<Proc:0x00007f31d92c9400 (irb):1>
h.default_proc.class # => Proc
h[:nosuch] # => "Default value for nosuch"
_______________________________________________________________________


    ::try_convert: Returns a new hash created from a given object.

If obj is a Hash object, returns obj.
Otherwise if obj responds to :to_hash, calls obj.to_hash and returns the result.
Returns nil if obj does not respond to :to_hash
Raises an exception unless obj.to_hash returns a Hash object.
_______________________________________________________________________


########## Methods for Setting Hash State ###########


    compare_by_identity: Sets self to consider only identity in comparing keys.

(*)=> 	hash.compare_by_identity → self

s0 = 'x'
s1 = 'x'
h = {}
h.compare_by_identity? # => false
h[s0] = 0
h[s1] = 1
h # => {"x"=>1}

***After calling #compare_by_identity, the keys are considered to be different, and therefore do not overwrite each other:***

Example
h = {}
h.compare_by_identity # => {}
h.compare_by_identity? # => true
h[s0] = 0
h[s1] = 1
h # => {"x"=>0, "x"=>1}
_______________________________________________________________________


    default=: Sets the default to a given value.

(*)=> 	hash.default = value → object

Sets the default value to value; returns value:
Example
h = {}
h.default # => nil
h.default = false # => false
h.default # => false
_______________________________________________________________________

    default_proc=: Sets the default proc to a given proc.

(*)=> 	hash.default_proc = proc → proc

Sets the default proc for self to proc: (see Default Values):
Example
h = {}
h.default_proc # => nil
h.default_proc = proc { |hash, key| "Default value for #{key}" }
h.default_proc.class # => Proc

h.default_proc = nil
h.default_proc # => nil
_______________________________________________________________________

    rehash: Rebuilds the hash table by recomputing the hash index for each key. 
Modifying a Hash key while it is in use damages the hash’s index.

This Hash has keys that are Arrays:
Example

a0 = [ :foo, :bar ]
a1 = [ :baz, :bat ]
h = {a0 => 0, a1 => 1}
h.include?(a0) # => true
h[a0] # => 0
a0.hash # => 110002110

Modifying array element a0[0] changes its hash value:
Example

a0[0] = :bam
a0.hash # => 1069447059

And damages the Hash index:
Example

h.include?(a0) # => false
h[a0] # => nil

You can repair the hash index using method rehash:
Example

h.rehash # => {[:bam, :bar]=>0, [:baz, :bat]=>1}
h.include?(a0) # => true
h[a0] # => 0

A String key is always safe. That’s because an unfrozen String passed as a key will be replaced by a duplicated and frozen String:
Example

s = 'foo'
s.frozen? # => false
h = {s => 0}
first_key = h.keys.first
first_key.frozen? # => true
_______________________________________________________________________

########## Methods for Querying ###########


    any?: Returns whether any element satisfies a given criterion.

(*)=> hash.any? → true or false

With no argument and no block, returns true if self is non-empty; false if empty.

(*)=> hash.any?(object) → true or false

With argument object and no block, returns true if for any key key h.assoc(key) == object:

h = {foo: 0, bar: 1, baz: 2}
h.any?([:bar, 1]) # => true
h.any?([:bar, 0]) # => false
h.any?([:baz, 1]) # => false

(*)=> hash.any? {|key, value| ... } → true or false

With no argument and a block, calls the block with each key-value pair; returns true if the block returns any truthy value, false otherwise:

Example
h = {foo: 0, bar: 1, baz: 2}
h.any? {|key, value| value < 3 } # => true
h.any? {|key, value| value > 3 } # => false	
_____________________________________________________________________
      
    compare_by_identity?: Returns whether the hash considers only identity when comparing keys.

Returns true if compare_by_identity has been called, false otherwise.

Example
s0 = 'x'
s1 = 'x'
h = {}
h.compare_by_identity? # => false
h[s0] = 0
h[s1] = 1
h # => {"x"=>1}

After calling #compare_by_identity, the keys are considered to be different, and therefore do not overwrite each other:

Example
h = {}
h.compare_by_identity # => {}
h.compare_by_identity? # => true
h[s0] = 0
h[s1] = 1
h # => {"x"=>0, "x"=>1}	
_____________________________________________________________________
      

    default: Returns the default value, or the default value for a given key.

(*)=> hash.default → object
h = {}
h.default # => nil

(*)=> hash.default(key) → object

h = Hash.new { |hash, key| hash[key] = "No key #{key}"}
h[:foo] = "Hello"
h.default(:foo) # => "No key foo"	
_____________________________________________________________________
      

    default_proc: Returns the default proc.

(*)=> hash.default_proc → proc or nil
h = {}
h.default_proc # => nil
h.default_proc = proc {|hash, key| "Default value for #{key}" }
h.default_proc.class # => Proc
_____________________________________________________________________
      
    empty?: Returns whether there are no entries.
	
{}.empty? # => true
{foo: 0, bar: 1, baz: 2}.empty? # => false
_____________________________________________________________________
      
    eql?: Returns whether a given object is equal to self.

    Returns true if all of the following are true:
    object is a Hash object.
    hash and object have the same keys (regardless of order).
    For each key key, h[key] eql? object[key]. 

Otherwise, returns false.

h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1, baz: 2}
h1.eql? h2 # => true
h3 = {baz: 2, bar: 1, foo: 0}
h1.eql? h3 # => true

_____________________________________________________________________
      

    hash: Returns the integer hash code.

Two Hash objects have the same hash-code if their content is the same (regardless or order):

Example
h1 = {foo: 0, bar: 1, baz: 2}
h2 = {baz: 2, bar: 1, foo: 0}
h2.hash == h1.hash # => true
h2.eql? h1 # => true
	
_____________________________________________________________________
      
    has_value?: Returns whether a given object is a value in self.

h			# => {:foo=>0, :bar=>1, :baz=>2} 
h.has_value?(2)		# => true 
h.has_value?(22)	# => false 
_____________________________________________________________________
      
    include?, has_key?, member?, key?: Returns whether a given object is a key in self.
h	 		#=> {:foo=>0, :bar=>1, :baz=>2} 
h.include?(2)		# => false 
h.include?(22)		# => false  
h.include?(:foo)	# => true  

h.has_key?(2)		# => false 
h.has_key?(22)		# => false  
h.has_key?(:foo)	# => true 

h.member?(:foo)	# => true

h.key?(:foo)	# => true    
_____________________________________________________________________
      
    length, size: Returns the count of entries.

{foo: 0, bar: 1, baz: 2}.length # => 3	
_____________________________________________________________________
      
    value?: Returns whether a given object is a value in self. 

h.value?(2)	# => true 
h.value?(:foo)	# => false 
_____________________________________________________________________
      
########## Methods for Comparing ###########


    <: Returns whether self is a proper subset of a given object.
h1 = {foo: 0, bar: 1}
h2 = {foo: 0, bar: 1, baz: 2}
h1 < h2 # => true
h2 < h1 # => false
**h1 < h1 # => false	**
_____________________________________________________________________
      
    <=: Returns whether self is a subset of a given object.
h1 = {foo: 0, bar: 1}
h2 = {foo: 0, bar: 1, baz: 2}
h1 <= h2 # => true
h2 <= h1 # => false
**h1 <= h1 # => true**
_____________________________________________________________________
      
    ==: Returns whether a given object is equal to self.
Returns true if all of the following are true:
    object is a Hash object.
    hash and object have the same keys (regardless of order).
    For each key key, hash[key] == object[key]. 

Otherwise, returns false.	

h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1, baz: 2}
h1 == h2 # => true
h3 = {baz: 2, bar: 1, foo: 0}
h1 == h3 # => true

_____________________________________________________________________

    >: Returns whether self is a proper superset of a given object

h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1}
h1 > h2 # => true
h2 > h1 # => false
h1 > h1 # => false	
_____________________________________________________________________

    >=: Returns whether self is a superset of a given object. 

h1 = {foo: 0, bar: 1, baz: 2}
h2 = {foo: 0, bar: 1}
h1 >= h2 # => true
h2 >= h1 # => false
h1 >= h1 # => true	
_____________________________________________________________________

##########  ###########
##########  ###########
##########  ###########
##########  ###########
