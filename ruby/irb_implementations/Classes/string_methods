emp_name = "Neeraj Kumar"   # => "Neeraj Kumar" 
puts emp_name   #=>Neeraj Kumar
                                       
########## Using indexes in String ###########
puts emp_name.length    #=>12
                                                     
puts emp_name[0]    #=>N
                                                     
> puts emp_name[12]    #=>nil
> puts emp_name[11] #=>r
> puts emp_name[1,4]         #it will print 4 char from index 1
eera
> puts emp_name[2,4]	    #it will print 4 char from index 2
eraj

> puts emp_name.index("N")    #it return index of first matching char from left to right
    #=>0
> puts emp_name.index("E")    #=>nil
> puts emp_name.index("e")    #=>1
> puts emp_name.index("a")    #=>4
> puts emp_name.index("K")    #=>7
 > puts emp_name.index("ee")    #=>1
  

########## Escape Characters in String ###########
emp_name = "Neeraj-Kumar"    #=> => "Neeraj-Kumar" 
puts emp_name    #=>Neeraj-Kumar
                                       
emp_name = "Neeraj/nKumar"    #=> => "Neeraj/nKumar" 
puts emp_name    #=>Neeraj/nKumar

emp_name = "Neeraj\nKumar"     #=> => "Neeraj\nKumar" 
puts emp_name
#=>
Neeraj
Kumar
 
puts "Neeraj\nKumar" 			#to print in newline
#=>
Neeraj
Kumar                                        

emp_name = "Neeraj\"Kumar"		#'\' escape charater to print '"'
#=> => "Neeraj\"Kumar" 
puts emp_name    #=>Neeraj"Kumar


########## Upper Case the String ###########
emp_name = "Neeraj Kumar"    #=> => "Neeraj Kumar" 
puts emp_name.upcase    #=>NEERAJ KUMAR                       
puts emp_name.upcase()    #=>NEERAJ KUMAR

########## Down Case the String ###########
> puts emp_name.downcase    #=>neeraj kumar

########## Stripe Function ###########
emp_name = "     Neeraj Kumar     "    #=> => "     Neeraj Kumar     " 
puts emp_name    #=>     Neeraj Kumar     
puts emp_name.strip		# remove extra spaces at start and end of string
    #=>Neeraj Kumar

emp_name = "     Neeraj     Kumar     "     #=> => "     Neeraj     Kumar     " 
puts emp_name.strip    #=>Neeraj     Kumar
 
########## Length of String ###########
emp_name = "     Neeraj     Kumar     " #=> => "     Neeraj     Kumar     " 
 puts emp_name.length    #=>26
puts emp_name.strip.length    #=>16
                                                                                          
########## Include Method in String ###########
puts emp_name.include? "kumar"    #=>false                                                                
puts emp_name.include? "Kumar"    #=>true
  
##########  Methods for Creating a String ###########
::new: Returns a new string.
s = String.new
s # => ""
s.encoding # => #<Encoding:ASCII-8BIT>

String.new('foo')               # => "foo"
String.new('тест')              # => "тест"
String.new('こんにちは')          # => "こんにちは"

String.new('foo', encoding: Encoding::US_ASCII).encoding # => #<Encoding:US-ASCII>
String.new('foo', encoding: 'US-ASCII').encoding         # => #<Encoding:US-ASCII>
String.new('foo', encoding: 'ASCII').encoding            # => #<Encoding:US-ASCII>

With keyword capacity, returns a copy of str; the given capacity may set the size of the internal buffer, which may affect performance:
String.new(capacity: 1)
String.new('foo', capacity: 4096)


The string, encoding, and capacity arguments may all be used together:
String.new('hello', encoding: 'UTF-8', capacity: 25)

Note that these are equivalent:
s0 = String.new('foo', encoding: 'ASCII')
s1 = 'foo'.force_encoding('ASCII')
s0.encoding == s1.encoding # => true



::try_convert: Returns a new string created from a given object.
If object is a String object, returns object.
Otherwise if object responds to :to_str, calls object.to_str and returns the result.
Returns nil if object does not respond to :to_str.
Raises an exception unless object.to_str returns a String object.

str     #=> "Neeraj Kumar"
String.try_convert(str)    #=> "Neeraj Kumar"
String.try_convert([9,9])    #=> nil
String.try_convert(9)    #=> nil
String.try_convert(true)   #=> nil

##########  Methods for a Frozen/Unfrozen String ###########
  freeze: Prevents further modifications to obj. A FrozenError will be raised if modification is attempted. There is no way to unfreeze a frozen object. To check if a string is freeze or not use:
  string.frozen?.

This method returns self.
a="Neeraj"
a.frozen?	# => false
a.freeze
a.frozen?	# => true 
a << "z"

produces:
prog.rb:3:in `<<': can't modify frozen Array (FrozenError)
 from prog.rb:3


Objects of the following classes are always frozen: Integer, Float, Symbol.


+string → new_string or self
Returns self if self is not frozen.
Otherwise. returns self.dup, which is not frozen.
+a<<"z"		# => "Neerajz" 
a		# => "Neeraj" 

-string → frozen_string
-a<<"z"
(irb):53:in `<main>': can't modify frozen String: "Neeraj" (FrozenError) 

Returns a frozen, possibly pre-existing copy of the string.
The returned String will be deduplicated as long as it does not have any instance variables set on it.


##########  Methods for Querying ###########
Counts

    length, size: Returns the count of characters (not bytes).
    bytesize: Returns the count of bytes (not characters) in self.
'foo'.length        # => 3
'foo'.bytesize        # => 3

    empty?: Returns true if self.length is zero; false otherwise.
"hello".empty? # => false
" ".empty? # => false
"".empty? # => true

    count: Returns the count of substrings matching given strings.
Returns the total number of characters in self that are specified by the given selectors
a = "hello world"
a.count "lo"                   #=> 5
a.count "lo", "o"              #=> 2
a.count "hello", "^l"          #=> 4
a.count "ej-m"                 #=> 4

"hello^world".count "\\^aeiou" #=> 4
"hello-world".count "a\\-eo"   #=> 4

c = "hello world\\r\\n"
c.count "\\"                   #=> 2
c.count "\\A"                  #=> 0
c.count "X-\\w"                #=> 3



=>A leading caret ('^') functions as a “not” operator for the characters to its right: 
'abracadabra'.delete('^bc') # => "bcb"
'0123456789'.delete('^852') # => "258"
=>A hyphen ('-') between two other characters defines a range of characters instead of a plain string of characters:

'abracadabra'.delete('a-d') # => "rr"
'0123456789'.delete('4-7')  # => "012389"
'!@#$%&*()_+'.delete(' -/') # => "@^_"

# May contain more than one range.
'abracadabra'.delete('a-cq-t') # => "d"   ===('abcqrst')

# Ranges may be mixed with plain characters.
'0123456789'.delete('67-950-23') # => "4"  ===('678950123')

# Ranges may be mixed with negations.
'abracadabra'.delete('^a-c') # => "abacaaba"  ===('^abc')

=>A backslash ('\') acts as an escape for a caret, a hyphen, or another backslash:

'abracadabra^'.delete('\^bc')   # => "araadara"
'abracadabra-'.delete('a\-d')   # => "brcbr"
"hello\r\nworld".delete("\r")   # => "hello\nworld"
"hello\r\nworld".delete("\\r")  # => "hello\r\nwold"
"hello\r\nworld".delete("\\\r") # => "hello\nworld"

Multiple Character Selectors

These instance methods accept multiple character selectors:

In effect, the given selectors are formed into a single selector consisting of only those characters common to all of the given selectors.

All forms of selectors may be used, including negations, ranges, and escapes.

Each of these pairs of method calls is equivalent:

s.delete('abcde', 'dcbfg')	# => "araaara"

--------------------------------------------------------------------

--------------------------------------------------------------------
Substrings

    =~: Returns the index of the first substring that matches a given Regexp or other object; returns nil if no match is found.

'foo' =~ /f/ # => 0
'foo' =~ /o/ # => 1
'foo' =~ /x/ # => nil


    index: Returns the index of the first occurrence of a given substring; returns nil if none found.
    'foo'.index('f')         # => 0
'foo'.index('o')         # => 1
'foo'.index('oo')        # => 1
'foo'.index('ooo')       # => nil
'тест'.index('с')        # => 2
'こんにちは'.index('ち')   # => 3

With Regexp argument regexp, returns the index of the first match in self:
'foo'.index(/o./) # => 1
'foo'.index(/.o/) # => 0

With positive integer offset, begins the search at position offset:

'foo'.index('o', 1)        # => 1
'foo'.index('o', 2)        # => 2
'foo'.index('o', 3)        # => nil
'тест'.index('с', 1)       # => 2
'こんにちは'.index('ち', 2)  # => 3

With negative integer offset, selects the search position by counting backward from the end of self:

'foo'.index('o', -1)  # => 2
'foo'.index('o', -2)  # => 1
'foo'.index('o', -3)  # => 1
'foo'.index('o', -4)  # => nil
'foo'.index(/o./, -2) # => 1
'foo'.index(/.o/, -2) # => 1

    rindex: Returns the index of the last occurrence of a given substring; returns nil if none found.
'foo'.rindex(/o+/) # => 2
$~ #=> #<MatchData "o">

    include?: Returns true if the string contains a given substring; false otherwise.
s = 'foo'
s.include?('f')    # => true
s.include?('fo')   # => true
s.include?('food') # => false


    match: Returns a MatchData object if the string matches a given Regexp; nil otherwise.

'foo'.match('f') # => #<MatchData "f">
'foo'.match('o') # => #<MatchData "o">
'foo'.match('x') # => nil

If Integer argument offset is given, the search begins at index offset:

'foo'.match('f', 1) # => nil
'foo'.match('o', 1) # => #<MatchData "o">

With a block given, calls the block with the computed matchdata and returns the block’s return value:

'foo'.match(/o/) {|matchdata| matchdata } # => #<MatchData "o">
'foo'.match(/x/) {|matchdata| matchdata } # => nil
'foo'.match(/f/, 1) {|matchdata| matchdata } # => nil


    match?: Returns true if the string matches a given Regexp; false otherwise.
'foo'.match?(/o/) # => true
'foo'.match?('o') # => true
'foo'.match?(/x/) # => false

If Integer argument offset is given, the search begins at index offset:

'foo'.match?('f', 1) # => false
'foo'.match?('o', 1) # => true


    start_with?: Returns true if the string begins with any of the given substrings.
hello'.start_with?('hell')               # => true
'hello'.start_with?(/H/i)                 # => true
'hello'.start_with?('heaven', 'hell')     # => true
'hello'.start_with?('heaven', 'paradise') # => false
'тест'.start_with?('т')                   # => true
'こんにちは'.start_with?('こ')              # => true


    end_with?: Returns true if the string ends with any of the given substrings.
'hello'.end_with?('ello')               #=> true
'hello'.end_with?('heaven', 'ello')     #=> true
'hello'.end_with?('heaven', 'paradise') #=> false
'тест'.end_with?('т')                   # => true
'こんにちは'.end_with?('は')              # => true



Encodings

    encoding: Returns the Encoding object that represents the encoding of the string.

    unicode_normalized?: Returns true if the string is in Unicode normalized form; false otherwise.

    valid_encoding?: Returns true if the string contains only characters that are valid for its encoding.

    ascii_only?: Returns true if the string has only ASCII characters; false otherwise.
'abc'.ascii_only?         # => true
"abc\u{6666}".ascii_only? # => false


Other

    sum: Returns a basic checksum for the string: the sum of each byte.


    hash: Returns the integer hash code.
 
 
  
##########  Methods for Comparing ###########


    ==, ===: Returns true if a given other string has the same content as self.
    
string == object → true or false
Also aliased as: ===
string === object → true or false

Returns true if object has the same length and content; as self; false otherwise:

s = 'foo'
s == 'foo' # => true
s == 'food' # => false
s == 'FOO' # => false

Returns false if the two strings’ encodings are not compatible


    eql?: Returns true if the content is the same as the given other string.
s = 'foo'
s.eql?('foo') # => true
s.eql?('food') # => false
s.eql?('FOO') # => false


    <=>: Returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than self.
Compares self and other_string, returning:

    -1 if other_string is larger.

    0 if the two are equal.

    1 if other_string is smaller.

    nil if the two are incomparable.

Examples:

'foo' <=> 'foo' # => 0
'foo' <=> 'food' # => -1
'food' <=> 'foo' # => 1
'FOO' <=> 'foo' # => -1
'foo' <=> 'FOO' # => 1
'foo' <=> 1 # => nil


    casecmp: Ignoring case, returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than self.
Compares self.downcase and other_string.downcase; returns:

    -1 if other_string.downcase is larger.

    0 if the two are equal.

    1 if other_string.downcase is smaller.

    nil if the two are incomparable.

Examples:

'foo'.casecmp('foo') # => 0
'foo'.casecmp('food') # => -1
'food'.casecmp('foo') # => 1
'FOO'.casecmp('foo') # => 0
'foo'.casecmp('FOO') # => 0
'foo'.casecmp(1) # => nil


    casecmp?: Returns true if the string is equal to a given string after Unicode case folding; false otherwise.
Returns true if self and other_string are equal after Unicode case folding, otherwise false:

'foo'.casecmp?('foo') # => true
'foo'.casecmp?('food') # => false
'food'.casecmp?('foo') # => false
'FOO'.casecmp?('foo') # => true
'foo'.casecmp?('FOO') # => true

Returns nil if the two values are incomparable:

'foo'.casecmp?(1) # => nil

  
########## Methods for Modifying a String  ###########
@@@@Insertion
_________________

    insert: Returns self with a given string inserted at a given offset.
    
insert(index, other_string) → self

'foo'.insert(1, 'bar') # => "fbaroo"
'foo'.insert(-2, 'bar') # => "fobaro"

__________________________________________________________________________
    <<: Returns self concatenated with a given string or integer.

string << object → string

s = 'foo'
s << 'bar' # => "foobar"
s          # => "foobar"

If object is an Integer, the value is considered a codepoint and converted to a character before concatenation:

s = 'foo'
s << 33 	# => "foo!"

__________________________________________________________________________
@@@@Substitution
________________

    sub!: Replaces the first substring that matches a given pattern with a given replacement string; returns self if any changes, nil otherwise.

sub!(pattern, replacement) → self or nil
sub!(pattern) {|match| ... } → self or nil

s = 'hello'
s.sub(/[aeiou]/, '*')# => "h*llo"
s.sub(/ell/, 'al')   # => "halo"

Hash replacement
If argument replacement is a hash, and pattern matches one of its keys, the replacing string is the value for that key:

h = {'foo' => 'bar', 'baz' => 'bat'}
'food'.sub('foo', h) # => "bard"


Note that a symbol key does not match:
h = {foo: 'bar', baz: 'bat'}
'food'.sub('foo', h) # => "d"


__________________________________________________________________________
    gsub!: Replaces each substring that matches a given pattern with a given replacement string; returns self if any changes, nil otherwise.

s.gsub(/[aeiou]/, '*') # => "h*ll*"
s.gsub(/[aeiou]/, '')# => "hll"
s.gsub(/xyzzy/, '*') # => "hello"
'THX1138'.gsub(/\d/, '00')  # => "THX00000000"
'THX1138'.gsub('\d+', '00') # => "THX1138"
'THX1138'.gsub(/\d+/, '00') # => "THX00"

Block

In the block form, the current match string is passed to the block; the block’s return value becomes the replacing string:

 s = '@'
'1234'.gsub(/\d/) {|match| s.succ! } # => "ABCD"

__________________________________________________________________________
    succ!, next!: Returns self modified to become its own successor.

succ → new_str

Returns the successor to self. The successor is calculated by incrementing characters.
'THX1138'.succ # => "THX1139"
'<<koala>>'.succ # => "<<koalb>>"
'***'.succ # => '**+'

'00'.succ # => "01"
'09'.succ # => "10"
'99'.succ # => "100"

'aa'.succ # => "ab"
'az'.succ # => "ba"
'zz'.succ # => "aaa"
'AA'.succ # => "AB"
'AZ'.succ # => "BA"
'ZZ'.succ # => "AAA"

The successor to a non-alphanumeric character is the next character in the underlying character set’s collating sequence, carrying to the next-left character for a rollover, and prepending another character if necessary:

s = 0.chr * 3
s # => "\x00\x00\x00"
s.succ # => "\x00\x00\x01"
s = 255.chr * 3
s # => "\xFF\xFF\xFF"
s.succ # => "\x01\x00\x00\x00"

Carrying can occur between and among mixtures of alphanumeric characters:

s = 'zz99zz99'
s.succ # => "aaa00aa00"
s = '99zz99zz'
s.succ # => "100aa00aa"

The successor to an empty String is a new empty String:

''.succ # => ""

__________________________________________________________________________
    replace: Returns self with its entire content replaced by a given string.


replace(other_string) → self

Replaces the contents of self with the contents of other_string:

s = 'foo'        # => "foo"
s.replace('bar') # => "bar"
__________________________________________________________________________
    reverse!: Returns self with its characters in reverse order.

reverse → string

Returns a new string with the characters from self in reverse order.

'stressed'.reverse # => "desserts"

reverse! → self

Returns self with its characters reversed:

s = 'stressed'
s.reverse! # => "desserts"
s          # => "desserts"

__________________________________________________________________________
    setbyte: Sets the byte at a given integer offset to a given value; returns the argument.

Sets the byte at zero-based index to integer; returns integer:

s = 'abcde'      # => "abcde"
s.setbyte(0, 98) # => 98
s                # => "bbcde"

__________________________________________________________________________
    tr!: Replaces specified characters in self with specified replacement characters; returns self if any changes, nil otherwise.


str.tr(from_str, to_str) => new_str
"hello".tr('el', 'ip')      #=> "hippo"
"hello".tr('aeiou', '*')    #=> "h*ll*"
"hello".tr('aeiou', 'AA*')  #=> "hAll*"

"hello".tr('a-y', 'b-z')    #=> "ifmmp"
"hello".tr('^aeiou', '*')   #=> "*e**o"

"hello^world\\".tr("^aeiou", "*")	#=> "*e**o**o****" 
"hello^world\\".tr("\^aeiou", "*")	# => "*e**o**o****" 
"hello^world\\".tr("\\^aeiou", "*")	# => "h*ll**w*rld\\" 
"hello^world\\".tr("\\\^aeiou", "*")	# => "h*ll**w*rld\\" 
"hello^world\\".tr("\\\\^aeiou", "*")	# => "h*ll**w*rld*" 

"X['\\b']".tr("X\\", "")   #=> "['b']"
"X['\\b']".tr("X-\\]", "") #=> "'b'"

__________________________________________________________________________
    tr_s!: Replaces specified characters in self with specified replacement characters, removing duplicates from the substrings that were modified; returns self if any changes, nil otherwise.

"hello".tr_s('l', 'r')     #=> "hero"
 "hello".tr('l', 'r')	   #=> "herro"
 
"hello".tr_s('el', '*')    #=> "h*o"
"hello".tr('el', '*')	   #=> "h***o"
 
"hello".tr_s('el', 'hx')   #=> "hhxo"
"hello".tr('el', 'hx')	   #=> "hhxxo" 

__________________________________________________________________________
@@@@Casing
___________

    capitalize!: Upcases the initial character and downcases all others; returns self if any changes, nil otherwise.
s = 'hello World!' # => "hello World!"
s.capitalize!      # => "Hello world!"
s                  # => "Hello world!"
s.capitalize!      # => nil
__________________________________________________________________________
    downcase!: Downcases all characters; returns self if any changes, nil otherwise.
s = 'Hello World!' # => "Hello World!"
s.downcase!        # => "hello world!"
s                  # => "hello world!"
s.downcase!        # => nil
__________________________________________________________________________
    upcase!: Upcases all characters; returns self if any changes, nil otherwise.
s = 'Hello World!' # => "Hello World!"
s.upcase!          # => "HELLO WORLD!"
s                  # => "HELLO WORLD!"
s.upcase!          # => nil
__________________________________________________________________________
    swapcase!: Upcases each downcase character and downcases each upcase character; returns self if any changes, nil otherwise.
s = 'Hello World!' # => "Hello World!"
s.swapcase!        # => "hELLO wORLD!"
s                  # => "hELLO wORLD!"
s.swapcase!	   # => "Hello World!"
''.swapcase!       # => nil
__________________________________________________________________________
@@@@Encoding
____________

    encode!: Returns self with all characters transcoded from one given encoding into another.

__________________________________________________________________________
    unicode_normalize!: Unicode-normalizes self; returns self.
    
__________________________________________________________________________
    scrub!: Replaces each invalid byte with a given character; returns self.

__________________________________________________________________________
    force_encoding: Changes the encoding to a given encoding; returns self.

__________________________________________________________________________
@@@@Deletion
____________

    clear: Removes all content, so that self is empty; returns self.
s = 'foo' # => "foo"
s.clear   # => ""
__________________________________________________________________________
    slice!, []=: Removes a substring determined by a given index, start/length, range, regexp, or substring.
string = "This is a string"
string.slice!(2)        #=> "i"
string.slice!(3..6)     #=> " is "
string.slice!(/s.*t/)   #=> "sa st"
string.slice!("r")      #=> "r"
string                  #=> "Thing"

__________________________________________________________________________
    squeeze!: Removes contiguous duplicate characters; returns self.

Builds a set of characters from the other_str parameter(s) using the procedure described for String#count. Returns a new string where runs of the same character that occur in this set are replaced by a single character. If no arguments are given, all runs of identical characters are replaced by a single character.
Example

"yellow moon".squeeze                  #=> "yelow mon"
"  now   is  the".squeeze(" ")         #=> " now is the"
"  now   isss  ttthe".squeeze(" ")     # => " now isss ttthe"
"putters shoot balls".squeeze("m-z")   #=> "puters shot balls"
"putteeeers shoot bbaalls".squeeze("m-z")	# => "puteeeers shot bbaalls" 
__________________________________________________________________________
    delete!: Removes characters as determined by the intersection of substring arguments.

str.delete([other_str]+) → new_str

"hello".delete "l","lo"        #=> "heo"
"hello".delete "lo"            #=> "he"
"hello".delete "aeiou", "^e"   #=> "hell"
"hello".delete "ej-m"          #=> "ho"
_______________________________________________________________________
    lstrip!: Removes leading whitespace; returns self if any changes, nil otherwise.
"  hello  ".lstrip!  #=> "hello  "
"hello  ".lstrip!    #=> nil
"hello".lstrip!      #=> nil
__________________________________________________________________________
    rstrip!: Removes trailing whitespace; returns self if any changes, nil otherwise.

__________________________________________________________________________
    strip!: Removes leading and trailing whitespace; returns self if any changes, nil otherwise.
"  hello  ".rstrip!  #=> "  hello"
"  hello".rstrip!    #=> nil
"hello".rstrip!      #=> nil
__________________________________________________________________________
    chomp!: Removes trailing record separator, if found; returns self if any changes, nil otherwise.

Returns a new String with the given record separator removed from the end of str (if present). If $/ has not been changed from the default Ruby record separator, then chomp also removes carriage return characters (that is it will remove \n, \r, and \r\n). If $/ is an empty string, it will remove all trailing newlines from the string.
Example

"hello".chomp                #=> "hello"
"hello\n".chomp              #=> "hello"
"hello\r\n".chomp            #=> "hello"
"hello\n\r".chomp            #=> "hello\n"
"hello\r".chomp              #=> "hello"
"hello \n there".chomp       #=> "hello \n there"
"hello".chomp("llo")         #=> "he"
"hello\r\n\r\n".chomp('')    #=> "hello"
"hello\r\n\r\r\n".chomp('')  #=> "hello\r\n\r"
__________________________________________________________________________
    chop!: Removes trailing newline characters if found; otherwise removes the last character; returns self if any changes, nil otherwise.
    
"string\r\n".chop   #=> "string"
"string\n\r".chop   #=> "string\n"
"string\n".chop     #=> "string"
"string".chop       #=> "strin"
"x".chop.chop       #=> ""
    

__________________________________________________________________________

  
##########   ###########
  
##########   ###########
  
##########   ###########
  
##########   ###########
  
##########   ###########
  
##########   ###########
  
##########   ###########
  
##########   ###########
  
##########   ###########
  
##########   ###########
