emp_name = "Neeraj Kumar"   # => "Neeraj Kumar" 
puts emp_name   #=>Neeraj Kumar
                                       
########## Using indexes in String ###########
puts emp_name.length    #=>12
                                                     
puts emp_name[0]    #=>N
                                                     
> puts emp_name[12]    #=>nil
> puts emp_name[11] #=>r
> puts emp_name[1,4]         #it will print 4 char from index 1
eera
> puts emp_name[2,4]	    #it will print 4 char from index 2
eraj

> puts emp_name.index("N")    #it return index of first matching char from left to right
    #=>0
> puts emp_name.index("E")    #=>nil
> puts emp_name.index("e")    #=>1
> puts emp_name.index("a")    #=>4
> puts emp_name.index("K")    #=>7
 > puts emp_name.index("ee")    #=>1
  

########## Escape Characters in String ###########
emp_name = "Neeraj-Kumar"    #=> => "Neeraj-Kumar" 
puts emp_name    #=>Neeraj-Kumar
                                       
emp_name = "Neeraj/nKumar"    #=> => "Neeraj/nKumar" 
puts emp_name    #=>Neeraj/nKumar

emp_name = "Neeraj\nKumar"     #=> => "Neeraj\nKumar" 
puts emp_name
#=>
Neeraj
Kumar
 
puts "Neeraj\nKumar" 			#to print in newline
#=>
Neeraj
Kumar                                        

emp_name = "Neeraj\"Kumar"		#'\' escape charater to print '"'
#=> => "Neeraj\"Kumar" 
puts emp_name    #=>Neeraj"Kumar


########## Upper Case the String ###########
emp_name = "Neeraj Kumar"    #=> => "Neeraj Kumar" 
puts emp_name.upcase    #=>NEERAJ KUMAR                       
puts emp_name.upcase()    #=>NEERAJ KUMAR

########## Down Case the String ###########
> puts emp_name.downcase    #=>neeraj kumar

########## Stripe Function ###########
emp_name = "     Neeraj Kumar     "    #=> => "     Neeraj Kumar     " 
puts emp_name    #=>     Neeraj Kumar     
puts emp_name.strip		# remove extra spaces at start and end of string
    #=>Neeraj Kumar

emp_name = "     Neeraj     Kumar     "     #=> => "     Neeraj     Kumar     " 
puts emp_name.strip    #=>Neeraj     Kumar
 
########## Length of String ###########
emp_name = "     Neeraj     Kumar     " #=> => "     Neeraj     Kumar     " 
 puts emp_name.length    #=>26
puts emp_name.strip.length    #=>16
                                                                                          
########## Include Method in String ###########
puts emp_name.include? "kumar"    #=>false                                                                
puts emp_name.include? "Kumar"    #=>true
  
##########  Methods for Creating a String ###########
::new: Returns a new string.
s = String.new
s # => ""
s.encoding # => #<Encoding:ASCII-8BIT>

String.new('foo')               # => "foo"
String.new('тест')              # => "тест"
String.new('こんにちは')          # => "こんにちは"

String.new('foo', encoding: Encoding::US_ASCII).encoding # => #<Encoding:US-ASCII>
String.new('foo', encoding: 'US-ASCII').encoding         # => #<Encoding:US-ASCII>
String.new('foo', encoding: 'ASCII').encoding            # => #<Encoding:US-ASCII>

With keyword capacity, returns a copy of str; the given capacity may set the size of the internal buffer, which may affect performance:
String.new(capacity: 1)
String.new('foo', capacity: 4096)


The string, encoding, and capacity arguments may all be used together:
String.new('hello', encoding: 'UTF-8', capacity: 25)

Note that these are equivalent:
s0 = String.new('foo', encoding: 'ASCII')
s1 = 'foo'.force_encoding('ASCII')
s0.encoding == s1.encoding # => true



::try_convert: Returns a new string created from a given object.
If object is a String object, returns object.
Otherwise if object responds to :to_str, calls object.to_str and returns the result.
Returns nil if object does not respond to :to_str.
Raises an exception unless object.to_str returns a String object.

str     #=> "Neeraj Kumar"
String.try_convert(str)    #=> "Neeraj Kumar"
String.try_convert([9,9])    #=> nil
String.try_convert(9)    #=> nil
String.try_convert(true)   #=> nil

##########  Methods for a Frozen/Unfrozen String ###########
  freeze: Prevents further modifications to obj. A FrozenError will be raised if modification is attempted. There is no way to unfreeze a frozen object. To check if a string is freeze or not use:
  string.frozen?.

This method returns self.
a="Neeraj"
a.frozen?	# => false
a.freeze
a.frozen?	# => true 
a << "z"

produces:
prog.rb:3:in `<<': can't modify frozen Array (FrozenError)
 from prog.rb:3


Objects of the following classes are always frozen: Integer, Float, Symbol.


+string → new_string or self
Returns self if self is not frozen.
Otherwise. returns self.dup, which is not frozen.
+a<<"z"		# => "Neerajz" 
a		# => "Neeraj" 

-string → frozen_string
-a<<"z"
(irb):53:in `<main>': can't modify frozen String: "Neeraj" (FrozenError) 

Returns a frozen, possibly pre-existing copy of the string.
The returned String will be deduplicated as long as it does not have any instance variables set on it.


##########  Methods for Querying ###########
Counts

    length, size: Returns the count of characters (not bytes).
    bytesize: Returns the count of bytes (not characters) in self.
'foo'.length        # => 3
'foo'.bytesize        # => 3

    empty?: Returns true if self.length is zero; false otherwise.
"hello".empty? # => false
" ".empty? # => false
"".empty? # => true

    count: Returns the count of substrings matching given strings.
Returns the total number of characters in self that are specified by the given selectors
a = "hello world"
a.count "lo"                   #=> 5
a.count "lo", "o"              #=> 2
a.count "hello", "^l"          #=> 4
a.count "ej-m"                 #=> 4

"hello^world".count "\\^aeiou" #=> 4
"hello-world".count "a\\-eo"   #=> 4

c = "hello world\\r\\n"
c.count "\\"                   #=> 2
c.count "\\A"                  #=> 0
c.count "X-\\w"                #=> 3



=>A leading caret ('^') functions as a “not” operator for the characters to its right: 
'abracadabra'.delete('^bc') # => "bcb"
'0123456789'.delete('^852') # => "258"
=>A hyphen ('-') between two other characters defines a range of characters instead of a plain string of characters:

'abracadabra'.delete('a-d') # => "rr"
'0123456789'.delete('4-7')  # => "012389"
'!@#$%&*()_+'.delete(' -/') # => "@^_"

# May contain more than one range.
'abracadabra'.delete('a-cq-t') # => "d"   ===('abcqrst')

# Ranges may be mixed with plain characters.
'0123456789'.delete('67-950-23') # => "4"  ===('678950123')

# Ranges may be mixed with negations.
'abracadabra'.delete('^a-c') # => "abacaaba"  ===('^abc')

=>A backslash ('\') acts as an escape for a caret, a hyphen, or another backslash:

'abracadabra^'.delete('\^bc')   # => "araadara"
'abracadabra-'.delete('a\-d')   # => "brcbr"
"hello\r\nworld".delete("\r")   # => "hello\nworld"
"hello\r\nworld".delete("\\r")  # => "hello\r\nwold"
"hello\r\nworld".delete("\\\r") # => "hello\nworld"

Multiple Character Selectors

These instance methods accept multiple character selectors:

In effect, the given selectors are formed into a single selector consisting of only those characters common to all of the given selectors.

All forms of selectors may be used, including negations, ranges, and escapes.

Each of these pairs of method calls is equivalent:

s.delete('abcde', 'dcbfg')	# => "araaara"

--------------------------------------------------------------------

--------------------------------------------------------------------
Substrings

    =~: Returns the index of the first substring that matches a given Regexp or other object; returns nil if no match is found.

'foo' =~ /f/ # => 0
'foo' =~ /o/ # => 1
'foo' =~ /x/ # => nil


    index: Returns the index of the first occurrence of a given substring; returns nil if none found.
    'foo'.index('f')         # => 0
'foo'.index('o')         # => 1
'foo'.index('oo')        # => 1
'foo'.index('ooo')       # => nil
'тест'.index('с')        # => 2
'こんにちは'.index('ち')   # => 3

With Regexp argument regexp, returns the index of the first match in self:
'foo'.index(/o./) # => 1
'foo'.index(/.o/) # => 0

With positive integer offset, begins the search at position offset:

'foo'.index('o', 1)        # => 1
'foo'.index('o', 2)        # => 2
'foo'.index('o', 3)        # => nil
'тест'.index('с', 1)       # => 2
'こんにちは'.index('ち', 2)  # => 3

With negative integer offset, selects the search position by counting backward from the end of self:

'foo'.index('o', -1)  # => 2
'foo'.index('o', -2)  # => 1
'foo'.index('o', -3)  # => 1
'foo'.index('o', -4)  # => nil
'foo'.index(/o./, -2) # => 1
'foo'.index(/.o/, -2) # => 1

    rindex: Returns the index of the last occurrence of a given substring; returns nil if none found.
'foo'.rindex(/o+/) # => 2
$~ #=> #<MatchData "o">

    include?: Returns true if the string contains a given substring; false otherwise.
s = 'foo'
s.include?('f')    # => true
s.include?('fo')   # => true
s.include?('food') # => false


    match: Returns a MatchData object if the string matches a given Regexp; nil otherwise.

'foo'.match('f') # => #<MatchData "f">
'foo'.match('o') # => #<MatchData "o">
'foo'.match('x') # => nil

If Integer argument offset is given, the search begins at index offset:

'foo'.match('f', 1) # => nil
'foo'.match('o', 1) # => #<MatchData "o">

With a block given, calls the block with the computed matchdata and returns the block’s return value:

'foo'.match(/o/) {|matchdata| matchdata } # => #<MatchData "o">
'foo'.match(/x/) {|matchdata| matchdata } # => nil
'foo'.match(/f/, 1) {|matchdata| matchdata } # => nil


    match?: Returns true if the string matches a given Regexp; false otherwise.
'foo'.match?(/o/) # => true
'foo'.match?('o') # => true
'foo'.match?(/x/) # => false

If Integer argument offset is given, the search begins at index offset:

'foo'.match?('f', 1) # => false
'foo'.match?('o', 1) # => true


    start_with?: Returns true if the string begins with any of the given substrings.
hello'.start_with?('hell')               # => true
'hello'.start_with?(/H/i)                 # => true
'hello'.start_with?('heaven', 'hell')     # => true
'hello'.start_with?('heaven', 'paradise') # => false
'тест'.start_with?('т')                   # => true
'こんにちは'.start_with?('こ')              # => true


    end_with?: Returns true if the string ends with any of the given substrings.
'hello'.end_with?('ello')               #=> true
'hello'.end_with?('heaven', 'ello')     #=> true
'hello'.end_with?('heaven', 'paradise') #=> false
'тест'.end_with?('т')                   # => true
'こんにちは'.end_with?('は')              # => true



Encodings

    encoding: Returns the Encoding object that represents the encoding of the string.

    unicode_normalized?: Returns true if the string is in Unicode normalized form; false otherwise.

    valid_encoding?: Returns true if the string contains only characters that are valid for its encoding.

    ascii_only?: Returns true if the string has only ASCII characters; false otherwise.
'abc'.ascii_only?         # => true
"abc\u{6666}".ascii_only? # => false


Other

    sum: Returns a basic checksum for the string: the sum of each byte.


    hash: Returns the integer hash code.
 
 
  
##########  Methods for Comparing ###########


    ==, ===: Returns true if a given other string has the same content as self.
    
string == object → true or false
Also aliased as: ===
string === object → true or false

Returns true if object has the same length and content; as self; false otherwise:

s = 'foo'
s == 'foo' # => true
s == 'food' # => false
s == 'FOO' # => false

Returns false if the two strings’ encodings are not compatible


    eql?: Returns true if the content is the same as the given other string.
s = 'foo'
s.eql?('foo') # => true
s.eql?('food') # => false
s.eql?('FOO') # => false


    <=>: Returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than self.
Compares self and other_string, returning:

    -1 if other_string is larger.

    0 if the two are equal.

    1 if other_string is smaller.

    nil if the two are incomparable.

Examples:

'foo' <=> 'foo' # => 0
'foo' <=> 'food' # => -1
'food' <=> 'foo' # => 1
'FOO' <=> 'foo' # => -1
'foo' <=> 'FOO' # => 1
'foo' <=> 1 # => nil


    casecmp: Ignoring case, returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than self.
Compares self.downcase and other_string.downcase; returns:

    -1 if other_string.downcase is larger.

    0 if the two are equal.

    1 if other_string.downcase is smaller.

    nil if the two are incomparable.

Examples:

'foo'.casecmp('foo') # => 0
'foo'.casecmp('food') # => -1
'food'.casecmp('foo') # => 1
'FOO'.casecmp('foo') # => 0
'foo'.casecmp('FOO') # => 0
'foo'.casecmp(1) # => nil


    casecmp?: Returns true if the string is equal to a given string after Unicode case folding; false otherwise.
Returns true if self and other_string are equal after Unicode case folding, otherwise false:

'foo'.casecmp?('foo') # => true
'foo'.casecmp?('food') # => false
'food'.casecmp?('foo') # => false
'FOO'.casecmp?('foo') # => true
'foo'.casecmp?('FOO') # => true

Returns nil if the two values are incomparable:

'foo'.casecmp?(1) # => nil

  
########## Methods for Modifying a String  ###########
@@@@Insertion
_________________

    insert: Returns self with a given string inserted at a given offset.
    
insert(index, other_string) → self

'foo'.insert(1, 'bar') # => "fbaroo"
'foo'.insert(-2, 'bar') # => "fobaro"

__________________________________________________________________________
    <<: Returns self concatenated with a given string or integer.

string << object → string

s = 'foo'
s << 'bar' # => "foobar"
s          # => "foobar"

If object is an Integer, the value is considered a codepoint and converted to a character before concatenation:

s = 'foo'
s << 33 	# => "foo!"

__________________________________________________________________________
@@@@Substitution
________________

    sub!: Replaces the first substring that matches a given pattern with a given replacement string; returns self if any changes, nil otherwise.

sub!(pattern, replacement) → self or nil
sub!(pattern) {|match| ... } → self or nil

s = 'hello'
s.sub(/[aeiou]/, '*')# => "h*llo"
s.sub(/ell/, 'al')   # => "halo"

Hash replacement
If argument replacement is a hash, and pattern matches one of its keys, the replacing string is the value for that key:

h = {'foo' => 'bar', 'baz' => 'bat'}
'food'.sub('foo', h) # => "bard"


Note that a symbol key does not match:
h = {foo: 'bar', baz: 'bat'}
'food'.sub('foo', h) # => "d"


__________________________________________________________________________
    gsub!: Replaces each substring that matches a given pattern with a given replacement string; returns self if any changes, nil otherwise.

s.gsub(/[aeiou]/, '*') # => "h*ll*"
s.gsub(/[aeiou]/, '')# => "hll"
s.gsub(/xyzzy/, '*') # => "hello"
'THX1138'.gsub(/\d/, '00')  # => "THX00000000"
'THX1138'.gsub('\d+', '00') # => "THX1138"
'THX1138'.gsub(/\d+/, '00') # => "THX00"

Block

In the block form, the current match string is passed to the block; the block’s return value becomes the replacing string:

 s = '@'
'1234'.gsub(/\d/) {|match| s.succ! } # => "ABCD"

__________________________________________________________________________
    succ!, next!: Returns self modified to become its own successor.

succ → new_str

Returns the successor to self. The successor is calculated by incrementing characters.
'THX1138'.succ # => "THX1139"
'<<koala>>'.succ # => "<<koalb>>"
'***'.succ # => '**+'

'00'.succ # => "01"
'09'.succ # => "10"
'99'.succ # => "100"

'aa'.succ # => "ab"
'az'.succ # => "ba"
'zz'.succ # => "aaa"
'AA'.succ # => "AB"
'AZ'.succ # => "BA"
'ZZ'.succ # => "AAA"

The successor to a non-alphanumeric character is the next character in the underlying character set’s collating sequence, carrying to the next-left character for a rollover, and prepending another character if necessary:

s = 0.chr * 3
s # => "\x00\x00\x00"
s.succ # => "\x00\x00\x01"
s = 255.chr * 3
s # => "\xFF\xFF\xFF"
s.succ # => "\x01\x00\x00\x00"

Carrying can occur between and among mixtures of alphanumeric characters:

s = 'zz99zz99'
s.succ # => "aaa00aa00"
s = '99zz99zz'
s.succ # => "100aa00aa"

The successor to an empty String is a new empty String:

''.succ # => ""

__________________________________________________________________________
    replace: Returns self with its entire content replaced by a given string.


replace(other_string) → self

Replaces the contents of self with the contents of other_string:

s = 'foo'        # => "foo"
s.replace('bar') # => "bar"
__________________________________________________________________________
    reverse!: Returns self with its characters in reverse order.

reverse → string

Returns a new string with the characters from self in reverse order.

'stressed'.reverse # => "desserts"

reverse! → self

Returns self with its characters reversed:

s = 'stressed'
s.reverse! # => "desserts"
s          # => "desserts"

__________________________________________________________________________
    setbyte: Sets the byte at a given integer offset to a given value; returns the argument.

Sets the byte at zero-based index to integer; returns integer:

s = 'abcde'      # => "abcde"
s.setbyte(0, 98) # => 98
s                # => "bbcde"

__________________________________________________________________________
    tr!: Replaces specified characters in self with specified replacement characters; returns self if any changes, nil otherwise.


str.tr(from_str, to_str) => new_str
"hello".tr('el', 'ip')      #=> "hippo"
"hello".tr('aeiou', '*')    #=> "h*ll*"
"hello".tr('aeiou', 'AA*')  #=> "hAll*"

"hello".tr('a-y', 'b-z')    #=> "ifmmp"
"hello".tr('^aeiou', '*')   #=> "*e**o"

"hello^world\\".tr("^aeiou", "*")	#=> "*e**o**o****" 
"hello^world\\".tr("\^aeiou", "*")	# => "*e**o**o****" 
"hello^world\\".tr("\\^aeiou", "*")	# => "h*ll**w*rld\\" 
"hello^world\\".tr("\\\^aeiou", "*")	# => "h*ll**w*rld\\" 
"hello^world\\".tr("\\\\^aeiou", "*")	# => "h*ll**w*rld*" 

"X['\\b']".tr("X\\", "")   #=> "['b']"
"X['\\b']".tr("X-\\]", "") #=> "'b'"

__________________________________________________________________________
    tr_s!: Replaces specified characters in self with specified replacement characters, removing duplicates from the substrings that were modified; returns self if any changes, nil otherwise.

"hello".tr_s('l', 'r')     #=> "hero"
 "hello".tr('l', 'r')	   #=> "herro"
 
"hello".tr_s('el', '*')    #=> "h*o"
"hello".tr('el', '*')	   #=> "h***o"
 
"hello".tr_s('el', 'hx')   #=> "hhxo"
"hello".tr('el', 'hx')	   #=> "hhxxo" 

__________________________________________________________________________
@@@@Casing
___________

    capitalize!: Upcases the initial character and downcases all others; returns self if any changes, nil otherwise.
s = 'hello World!' # => "hello World!"
s.capitalize!      # => "Hello world!"
s                  # => "Hello world!"
s.capitalize!      # => nil
__________________________________________________________________________
    downcase!: Downcases all characters; returns self if any changes, nil otherwise.
s = 'Hello World!' # => "Hello World!"
s.downcase!        # => "hello world!"
s                  # => "hello world!"
s.downcase!        # => nil
__________________________________________________________________________
    upcase!: Upcases all characters; returns self if any changes, nil otherwise.
s = 'Hello World!' # => "Hello World!"
s.upcase!          # => "HELLO WORLD!"
s                  # => "HELLO WORLD!"
s.upcase!          # => nil
__________________________________________________________________________
    swapcase!: Upcases each downcase character and downcases each upcase character; returns self if any changes, nil otherwise.
s = 'Hello World!' # => "Hello World!"
s.swapcase!        # => "hELLO wORLD!"
s                  # => "hELLO wORLD!"
s.swapcase!	   # => "Hello World!"
''.swapcase!       # => nil
__________________________________________________________________________
@@@@Encoding
____________

    encode!: Returns self with all characters transcoded from one given encoding into another.

__________________________________________________________________________
    unicode_normalize!: Unicode-normalizes self; returns self.
    
__________________________________________________________________________
    scrub!: Replaces each invalid byte with a given character; returns self.

__________________________________________________________________________
    force_encoding: Changes the encoding to a given encoding; returns self.

__________________________________________________________________________
@@@@Deletion
____________

    clear: Removes all content, so that self is empty; returns self.
s = 'foo' # => "foo"
s.clear   # => ""
__________________________________________________________________________
    slice!, []=: Removes a substring determined by a given index, start/length, range, regexp, or substring.
string = "This is a string"
string.slice!(2)        #=> "i"
string.slice!(3..6)     #=> " is "
string.slice!(/s.*t/)   #=> "sa st"
string.slice!("r")      #=> "r"
string                  #=> "Thing"

__________________________________________________________________________
    squeeze!: Removes contiguous duplicate characters; returns self.

Builds a set of characters from the other_str parameter(s) using the procedure described for String#count. Returns a new string where runs of the same character that occur in this set are replaced by a single character. If no arguments are given, all runs of identical characters are replaced by a single character.
Example

"yellow moon".squeeze                  #=> "yelow mon"
"  now   is  the".squeeze(" ")         #=> " now is the"
"  now   isss  ttthe".squeeze(" ")     # => " now isss ttthe"
"putters shoot balls".squeeze("m-z")   #=> "puters shot balls"
"putteeeers shoot bbaalls".squeeze("m-z")	# => "puteeeers shot bbaalls" 
__________________________________________________________________________
    delete!: Removes characters as determined by the intersection of substring arguments.

str.delete([other_str]+) → new_str

"hello".delete "l","lo"        #=> "heo"
"hello".delete "lo"            #=> "he"
"hello".delete "aeiou", "^e"   #=> "hell"
"hello".delete "ej-m"          #=> "ho"
_______________________________________________________________________
    lstrip!: Removes leading whitespace; returns self if any changes, nil otherwise.
"  hello  ".lstrip!  #=> "hello  "
"hello  ".lstrip!    #=> nil
"hello".lstrip!      #=> nil
__________________________________________________________________________
    rstrip!: Removes trailing whitespace; returns self if any changes, nil otherwise.

__________________________________________________________________________
    strip!: Removes leading and trailing whitespace; returns self if any changes, nil otherwise.
"  hello  ".rstrip!  #=> "  hello"
"  hello".rstrip!    #=> nil
"hello".rstrip!      #=> nil
__________________________________________________________________________
    chomp!: Removes trailing record separator, if found; returns self if any changes, nil otherwise.

Returns a new String with the given record separator removed from the end of str (if present). If $/ has not been changed from the default Ruby record separator, then chomp also removes carriage return characters (that is it will remove \n, \r, and \r\n). If $/ is an empty string, it will remove all trailing newlines from the string.
Example

"hello".chomp                #=> "hello"
"hello\n".chomp              #=> "hello"
"hello\r\n".chomp            #=> "hello"
"hello\n\r".chomp            #=> "hello\n"
"hello\r".chomp              #=> "hello"
"hello \n there".chomp       #=> "hello \n there"
"hello".chomp("llo")         #=> "he"
"hello\r\n\r\n".chomp('')    #=> "hello"
"hello\r\n\r\r\n".chomp('')  #=> "hello\r\n\r"
__________________________________________________________________________
    chop!: Removes trailing newline characters if found; otherwise removes the last character; returns self if any changes, nil otherwise.
    
"string\r\n".chop   #=> "string"
"string\n\r".chop   #=> "string\n"
"string\n".chop     #=> "string"
"string".chop       #=> "strin"
"x".chop.chop       #=> ""
    

__________________________________________________________________________

  
##########  Methods for Converting to New String ###########

Extension
__________

    *: Returns the concatenation of multiple copies of self,
"Ho! " * 3 # => "Ho! Ho! Ho! "
"Ho! " * 0 # => ""
____________________________________________________________________
    +: Returns the concatenation of self and a given other string.

"Hello from " + self.to_s # => "Hello from main"
"Hello from " + 5.to_s		# => "Hello from 5" 
"Hello from " + "Beryl Systems"	# => "Hello from Beryl Systems"
____________________________________________________________________
    concat: Returns the concatenation of self with given other strings.
s = 'foo'
s.concat('bar', 'baz') # => "foobarbaz"
s                      # => "foobarbaz"

For each given object object that is an Integer, the value is considered a codepoint and converted to a character before concatenation:

s = 'foo'
s.concat(32, 'bar', 32, 'baz') # => "foo bar baz"
____________________________________________________________________
    prepend: Returns the concatenation of a given other string with self.
s = 'foo'
s.prepend('bar', 'baz') # => "barbazfoo"
s                       # => "barbazfoo"
____________________________________________________________________
    center: Returns a copy of self centered between pad substring.

center(size, pad_string = ' ') → new_string

Returns a centered copy of self.

If integer argument size is greater than the size (in characters) of self, returns a new string of length size that is a copy of self, centered and padded on both ends with pad_string:

'hello'.center(10)       	# => "  hello   "
'  hello'.center(10)     	# => "   hello  "
'hello'.center(10,'_') 		# => "__hello___" 
'hello'.center(11,'_') 		# => "___hello___" 
'hello'.center(10, 'ab') 	# => "abhelloaba"

If size is not greater than the size of self, returns a copy of self:

'hello'.center(5)  # => "hello"
'hello'.center(1)  # => "hello"
'hello'.center(3,'_') 	# => "hello" 
____________________________________________________________________

    ljust: (Returns a left-justified copy of self.) Returns a copy of self of a given length, right-padded with a given other string.

'hello'.ljust(10)       # => "hello     "
'  hello'.ljust(10)     # => "  hello   "
'hello'.ljust(10, 'ab') # => "helloababa"
'тест'.ljust(10)        # => "тест      "
'こんにちは'.ljust(10)    # => "こんにちは     "

If size is not greater than the size of self, returns a copy of self:

'hello'.ljust(5)  # => "hello"
'hello'.ljust(1)  # => "hello"
____________________________________________________________________
    rjust: (Returns a right-justified copy of self) Returns a copy of self of a given length, left-padded with a given other string.
'hello'.rjust(10)       # => "     hello"
'hello  '.rjust(10)     # => "   hello  "

If size is not greater than the size of self, returns a copy of self:

'hello'.rjust(5, 'ab')  # => "hello"
'hello'.rjust(1, 'ab')  # => "hello"
____________________________________________________________________

Encoding
_________

    b: Returns a copy of self with ASCII-8BIT encoding.

____________________________________________________________________
    scrub: Returns a copy of self with each invalid byte replaced with a given character.

____________________________________________________________________
    unicode_normalize: Returns a copy of self with each character Unicode-normalized.

____________________________________________________________________
    encode: Returns a copy of self with all characters transcoded from one given encoding into another.

____________________________________________________________________

Substitution
_______________

    dump: Returns a copy of self with all non-printing characters replaced by xHH notation and all special characters escaped.

dump → string
"hello \n ''".dump    # => "\"hello \\n ''\""
"\f\x00\xff\\\"".dump # => "\"\\f\\x00\\xFF\\\\\\\"\""

____________________________________________________________________
    undump: Returns a copy of self with all \xNN notation replace by \uNNNN notation and all escaped characters unescaped.

undump → string

Returns an unescaped version of self:

s_orig = "\f\x00\xff\\\""    # => "\f\u0000\xFF\\\""
s_dumped = s_orig.dump       # => "\"\\f\\x00\\xFF\\\\\\\"\""
s_undumped = s_dumped.undump # => "\f\u0000\xFF\\\""
s_undumped == s_orig         # => true

____________________________________________________________________
    sub: Returns a copy of self with the first substring matching a given pattern replaced with a given replacement string;.

at line: 449
____________________________________________________________________
    gsub: Returns a copy of self with each substring that matches a given pattern replaced with a given replacement string.

at line: 471
____________________________________________________________________
    succ, next: Returns the string that is the successor to self.

at line : 488
____________________________________________________________________
    reverse: Returns a copy of self with its characters in reverse order.

at line : 539
____________________________________________________________________
    tr: Returns a copy of self with specified characters replaced with specified replacement characters.

at line: 565
____________________________________________________________________
    tr_s: Returns a copy of self with specified characters replaced with specified replacement characters, removing duplicates from the substrings that were modified.

at line: 586
____________________________________________________________________
    %: Returns the string resulting from formatting a given object into self

(doubt)
____________________________________________________________________
Casing (at line: 598)
_______

    capitalize: Returns a copy of self with the first character upcased and all other characters downcased.

____________________________________________________________________
    downcase: Returns a copy of self with all characters downcased.

____________________________________________________________________
    upcase: Returns a copy of self with all characters upcased.

____________________________________________________________________
    swapcase: Returns a copy of self with all upcase characters downcased and all downcase characters upcased.

____________________________________________________________________
Deletion
_________

    delete: Returns a copy of self with characters removed

at line: 668
____________________________________________________________________
    delete_prefix: Returns a copy of self with a given prefix removed.
    
Returns a copy of self with leading substring prefix removed:
'hello'.delete_prefix('hel')      # => "lo"
'hello'.delete_prefix('llo')      # => "hello"

____________________________________________________________________
    delete_suffix: Returns a copy of self with a given suffix removed.

Returns a copy of self with trailing substring suffix removed:
'hello'.delete_suffix('llo')      # => "he"
'hello'.delete_suffix('hel')      # => "hello"
____________________________________________________________________
    lstrip: Returns a copy of self with leading whitespace removed.

at line: 677
____________________________________________________________________
    rstrip: Returns a copy of self with trailing whitespace removed.

at line: 682
____________________________________________________________________
    strip: Returns a copy of self with leading and trailing whitespace removed.

at line: 685
____________________________________________________________________
    chomp: Returns a copy of self with a trailing record separator removed, if found.

at line: 690
____________________________________________________________________
    chop: Returns a copy of self with trailing newline characters or the last character removed.

at line: 705
____________________________________________________________________
    squeeze: Returns a copy of self with contiguous duplicate characters removed.

at line: 657
____________________________________________________________________
    [], slice: Returns a substring determined by a given index, start/length, or range, or string.

at line: 648
____________________________________________________________________
    byteslice: Returns a substring determined by a given index, start/length, or range.

With integer arguments index and length given, returns the substring beginning at the given index of the given length (if possible), or nil if length is negative or index falls outside of self:

s = '0123456789' # => "0123456789"
s.byteslice(2)   # => "2"
s.byteslice(200) # => nil
s.byteslice(4, 3)  # => "456"
s.byteslice(4, 30) # => "456789"
s.byteslice(4, -1) # => nil
s.byteslice(40, 2) # => nil

In either case above, counts backwards from the end of self if index is negative:

s = '0123456789'   # => "0123456789"
s.byteslice(-4)    # => "6"
s.byteslice(-4, 3) # => "678"

With Range argument range given, returns byteslice(range.begin, range.size):

s = '0123456789'    # => "0123456789"
s.byteslice(4..6)   # => "456"
s.byteslice(-6..-4) # => "456"
s.byteslice(5..2)   # => "" # range.size is zero.
s.byteslice(40..42) # => nil
____________________________________________________________________
    chr: Returns the first character.
s = 'foo' # => "foo"
s.chr     # => "f"
____________________________________________________________________

Duplication
____________

    to_s, $to_str: If self is a subclass of String, returns self copied into a String; otherwise, returns self.

same as in Array Class.
____________________________________________________________________

  
########## Methods for Iterating  ###########

    each_byte: Calls the given block with each successive byte in self.
'hello'.each_byte {|byte| print byte, ' ' } 	#=> 104 101 108 108 111

##Note it is printing the ASCII value of each character.


str.bytes → an_array

Returns an array of bytes in str. This is a shorthand for str.each_byte.to_a.
____________________________________________________________________

    each_char: Calls the given block with each successive character in self.

'hello'.each_char {|char| print char, ' ' } 	#=> h e l l o
____________________________________________________________________

    each_codepoint: Calls the given block with each successive integer codepoint in self.

Calls the given block with each successive codepoint from self; each codepoint is the integer value for a character; returns self:

'hello'.each_codepoint {|codepoint| print codepoint, ' ' } 	#=>104 101 108 108 111
____________________________________________________________________

(doubt)    each_grapheme_cluster: Calls the given block with each successive grapheme cluster in self.

Passes each grapheme cluster in str to the given block, or returns an enumerator if no block is given. Unlike String#each_char, this enumerates by grapheme clusters defined by Unicode Standard Annex #29 unicode.org/reports/tr29/

s = "\u0061\u0308-pqr-\u0062\u0308-xyz-\u0063\u0308" # => "ä-pqr-b̈-xyz-c̈"
s.each_grapheme_cluster {|gc| print gc, ' ' } 	#=>ä - p q r - b̈ - x y z - c̈
____________________________________________________________________

    each_line: Calls the given block with each successive line in self, as determined by a given record separator.


each_line(line_sep = $/, chomp: false) {|substring| ... } → self
each_line(line_sep = $/, chomp: false) → enumerator

With a block given, forms the substrings (“lines”) that are the result of splitting self at each occurrence of the given line separator line_sep; passes each line to the block; returns self:

s = <<~EOT
This is the first line.
This is line two.

This is line four.
This is line five.
EOT

s.each_line {|line| p line }

Output:

"This is the first line.\n"
"This is line two.\n"
"\n"
"This is line four.\n"
"This is line five.\n"

With a different line_sep:

s.each_line(' is ') {|line| p line }

Output:

"This is "
"the first line.\nThis is "
"line two.\n\nThis is "
"line four.\nThis is "
"line five.\n"

With chomp as true, removes the trailing line_sep from each line:

s.each_line(chomp: true) {|line| p line }

Output:

"This is the first line."
"This is line two."
""
"This is line four."
"This is line five."

With an empty string as line_sep, forms and passes “paragraphs” by splitting at each occurrence of two or more newlines:

s.each_line('') {|line| p line }

Output:

"This is the first line.\nThis is line two.\n\n"
"This is line four.\nThis is line five.\n"


With no block given, returns an enumerator.
____________________________________________________________________

    upto: Calls the given block with each string value returned by successive calls to succ.
   
upto(other_string, exclusive = false) {|string| ... } → self click to toggle source
upto(other_string, exclusive = false) → new_enumerator

With a block given, calls the block with each String value returned by successive calls to String#succ; the first value is self, the next is self.succ, and so on; the sequence terminates when value other_string is reached; returns self:

'a8'.upto('b6') {|s| print s, ' ' } # => "a8"

Output:

a8 a9 b0 b1 b2 b3 b4 b5 b6

If argument exclusive is given as a truthy object, the last value is omitted:

'a8'.upto('b6', true) {|s| print s, ' ' } # => "a8"

Output:

a8 a9 b0 b1 b2 b3 b4 b5

If other_string would not be reached, does not call the block:

'25'.upto('5') {|s| fail s }
'aa'.upto('a') {|s| fail s }

With no block given, returns a new Enumerator.
____________________________________________________________________
  
########## Methods for Converting to Non-String  ###########
@@@@Characters, Bytes, and Clusters
____________________________________

    bytes: Returns an array of the bytes in self.
'hello'.bytes # => [104, 101, 108, 108, 111]
____________________________________________________________________
    chars: Returns an array of the characters in self.
'hello'.chars     # => ["h", "e", "l", "l", "o"]
____________________________________________________________________
    codepoints:(same as bytes) Returns an array of the integer ordinals in self.
'hello'.codepoints     # => [104, 101, 108, 108, 111]
____________________________________________________________________
    getbyte: Returns an integer byte as determined by a given index.
Returns the byte at zero-based index as an integer, or nil if index is out of range:

s = 'abcde'   # => "abcde"
s.getbyte(0)  # => 97
s.getbyte(-1) # => 101
s.getbyte(5)  # => nil
____________________________________________________________________
(doubt)    grapheme_clusters: Returns an array of the grapheme clusters in self.

____________________________________________________________________

@@@@Splitting
______________

    lines: Returns an array of the lines in self, as determined by a given record separator.
 
 lines(Line_sep = $/, chomp: false) → array_of_strings
    
Returns an array of lines in str split using the supplied record separator ($/ by default). This is a shorthand for str.each_line(separator, getline_args).to_a.

If chomp is true, separator will be removed from the end of each line.

"hello\nworld\n".lines              #=> ["hello\n", "world\n"]
"hello  world".lines(' ')           #=> ["hello ", " ", "world"]
"hello\nworld\n".lines(chomp: true) #=> ["hello", "world"]

If a block is given, which is a deprecated form, works the same as each_line.
____________________________________________________________________
    partition: Returns a 3-element array determined by the first substring that matches a given substring or regexp,

Returns a 3-element array of substrings of self.
If the pattern is matched, returns pre-match, first-match, post-match:

'hello'.partition('l')      # => ["he", "l", "lo"]
'hello'.partition('ll')     # => ["he", "ll", "o"]
'hello'.partition('h')      # => ["", "h", "ello"]
'hello'.partition('o')      # => ["hell", "o", ""]
'hello'.partition(/l+/)     #=> ["he", "ll", "o"]
'hello'.partition('')       # => ["", "", "hello"]

If the pattern is not matched, returns a copy of self and two empty strings:
'hello'.partition('x') # => ["hello", "", ""]
____________________________________________________________________
    rpartition: (reverse of partition) Returns a 3-element array determined by the last substring that matches a given substring or regexp,
(simliar to partition but it search from end or we can say it find the last matched pattern)

If the pattern is matched, returns pre-match, last-match, post-match:

'hello'.rpartition('l')      # => ["hel", "l", "o"]
'hello'.rpartition('ll')     # => ["he", "ll", "o"]
'hello'.rpartition('h')      # => ["", "h", "ello"]
'hello'.rpartition('o')      # => ["hell", "o", ""]
'hello'.rpartition(/l+/)     # => ["hel", "l", "o"]
'hello'.rpartition('')       # => ["hello", "", ""]

If the pattern is not matched, returns two empty strings and a copy of self:
'hello'.rpartition('x') # => ["", "", "hello"]
____________________________________________________________________
    split: Returns an array of substrings determined by a given delimiter – regexp or string – or, if a block given, passes those substrings to the block.

Returns an array of substrings of self that are the result of splitting self at each occurrence of the given field separator field_sep.

When field_sep is $;:
    If $; is nil (its default value), the split occurs just as if field_sep were given as a space character (see below).
    If $; is a string, the split ocurs just as if field_sep were given as that string 

'abc def ghi'.split	# => ["abc", "def", "ghi"] 
'abc def ghi'.split('')	# => ["a", "b", "c", " ", "d", "e", "f", " ", "g", "h", "i"] 

When field_sep is ' ' and limit is nil, the split occurs at each sequence of whitespace:
'abc def ghi'.split(' ')         => ["abc", "def", "ghi"]
"abc \n\tdef\t\n  ghi".split(' ') # => ["abc", "def", "ghi"]
'abc  def   ghi'.split(' ')      => ["abc", "def", "ghi"]
''.split(' ')                    => []

When field_sep is a string different from ' ' and limit is nil, the split occurs at each occurrence of field_sep; trailing empty substrings are not returned:

'aaaaaa'.split('a')	#=> []
'abracadabra'.split('ab')  => ["", "racad", "ra"]
'abracadabrab'.split('ab')	#=> ["", "racad", "r"] 
'abracadabrababab'.split('ab')	# => ["", "racad", "r"] 
'aaabcdaaa'.split('a')     => ["", "", "", "bcd"]
''.split('a')              => []
'3.14159'.split('1')       => ["3.", "4", "59"]
'!@#$%^$&*($)_+'.split('$') # => ["!@#", "%^", "&*(", ")_+"]

When field_sep is a Regexp and limit is nil, the split occurs at each occurrence of a match; trailing empty substrings are not returned:

'abracadabra'.split(/ab/) # => ["", "racad", "ra"]
'aaabcdaaa'.split(/a/)   => ["", "", "", "bcd"]
'aaabcdaaa'.split(//)    => ["a", "a", "a", "b", "c", "d", "a", "a", "a"]
'1 + 1 == 2'.split(/\W+/) # => ["1", "1", "2"]

As seen above, if limit is nil, trailing empty substrings are not returned; the same is true if limit is zero:
basically (nil == 0 in this case)

'aaabcdaaa'.split('a')   => ["", "", "", "bcd"]
'aaabcdaaa'.split('a', 0) # => ["", "", "", "bcd"]

If limit is positive integer n, no more than n - 1- splits occur, so that at most n substrings are returned, and trailing empty substrings are included:
(basically n deifne max no. of time spitting charactor to remove or number of substring to make)
'aaabcdaaa'.split('a', 1) # => ["aaabcdaaa"]
'aaabcdaaa'.split('a', 2) # => ["", "aabcdaaa"]
'aaabcdaaa'.split('a', 5) # => ["", "", "", "bcd", "aa"]
'aaabcdaaa'.split('a', 7) # => ["", "", "", "bcd", "", "", ""]
'aaabcdaaa'.split('a', 8) # => ["", "", "", "bcd", "", "", ""]


'aaabcdaaa'.split(/a/, 1)	# => ["aaabcdaaa"] 
'aaabcdaaa'.split(/a/, 2)	# => ["", "aabcdaaa"] 
'aaabcdaaa'.split(/a/, 5)	# => ["", "", "", "bcd", "aa"] 
'aaabcdaaa'.split(/a/, 7)	# => ["", "", "", "bcd", "", "", ""] 
 
'aaabcdaaa'.split(/a+/, 7)	# => ["", "bcd", ""] 
'aaabcdaaa'.split(/a+/, 1)	# => ["aaabcdaaa"] 
'aaabcdaaa'.split(/a+/, 2)	# => ["", "bcdaaa"] 
'aaabcdaaa'.split(/a+/, 3)	# => ["", "bcd", ""] 
'aaabcdaaa'.split(/a+/, 5)	# => ["", "bcd", ""] 
'aaabcdaaa'.split(/a+/, 7)	# => ["", "bcd", ""] 
 
 'aaabcdaaa'.split(/\w/, 1)	# => ["aaabcdaaa"] 
'aaabcdaaa'.split(/\w/, 2)	# => ["", "aabcdaaa"] 
'aaabcdaaa'.split(/\w/, 5)	# => ["", "", "", "", "cdaaa"] 
'aaabcdaaa'.split(/\w/, 7)	# => ["", "", "", "", "", "", "aaa"] 


If limit is negative, it behaves the same as if limit was nil, meaning that there is no limit, and trailing empty substrings are included:
'aaabcdaaa'.split('a', -1) # => ["", "", "", "bcd", "", "", ""]


If a block is given, it is called with each substring:
'abc def ghi'.split(' ') {|substring| p substring }
Output:
"abc"
"def"
"ghi"

____________________________________________________________________
@@@@Matching

    scan: Returns an array of substrings matching a given regexp or string, or, if a block given, passes each matching substring to the block.

scan(string_or_regexp) → array
scan(string_or_regexp) {|matches| ... } → self

Iterates through self, generating a collection of matching results:

    If the pattern contains no groups, each result is the matched string, $&.

    If the pattern contains groups, each result is an array containing one entry per group.

With no block given, returns an array of the results:

s = 'cruel world'
s.scan(/\w+/)      # => ["cruel", "world"]
s.scan(/.../)      # => ["cru", "el ", "wor"]
s.scan(/(...)/)    # => [["cru"], ["el "], ["wor"]]
s.scan(/(..)(..)/) # => [["cr", "ue"], ["l ", "wo"]]

s = 'cruel world bad pollution'
s.scan(/\w+/)	# => ["cruel", "world", "bad", "pollution"] 

s = 'cruel worlde'	# => "cruel worlde"
s.scan(/\w+/)	# => ["cruel", "worlde"] 

s.scan(/.../) 	#=> ["cru", "el ", "wor", "lde"] 
s.scan(/../)	# => ["cr", "ue", "l ", "wo", "rl", "de"] 
s.scan(/./)	# => ["c", "r", "u", "e", "l", " ", "w", "o", "r", "l", "d", "e"] 
 
s.scan(/(...)/) 	# => [["cru"], ["el "], ["wor"], ["lde"]] 
s.scan(/(..)/) 	# => [["cr"], ["ue"], ["l "], ["wo"], ["rl"], ["de"]] 
s.scan(/(.)/)	#=> [["c"], ["r"], ["u"], ["e"], ["l"], [" "], ["w"], ["o"], ["r"], ["l"], ["d"], ["e"]] 

s.scan(/(..)(..)/)	# => [["cr", "ue"], ["l ", "wo"], ["rl", "de"]] 
s.scan(/(.)(.)/)	# => [["c", "r"], ["u", "e"], ["l", " "], ["w", "o"], ["r", "l"], ["d", "e"]] 
s.scan(/(...)(...)/)	# => [["cru", "el "], ["wor", "lde"]] 
s.scan(/()()/)	# => [["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""]] 

s.scan(/(.).(.)/)	# => [["c", "u"], ["e", " "], ["w", "r"], ["l", "e"]] 
s.scan(/.(.)(.)/)	# => [["r", "u"], ["l", " "], ["o", "r"], ["d", "e"]] 
s.scan(/(.)(.)./)	# => [["c", "r"], ["e", "l"], ["w", "o"], ["l", "d"]] 


With a block given, calls the block with each result; returns self:
s.scan(/\w+/) {|w| print "<<#{w}>> " }
print "\n"
s.scan(/(.)(.)/) {|x,y| print y, x }
print "\n"

Output:
<<cruel>> <<world>>
rceu lowlr
____________________________________________________________________
(doubt)    unpack: Returns an array of substrings extracted from self according to a given format.

____________________________________________________________________
(doubt)    unpack1: Returns the first substring extracted from self according to a given format.

____________________________________________________________________
@@@@Numerics
_____________

    hex: Returns the integer value of the leading characters, interpreted as hexadecimal digits.

Interprets the leading substring of self as a string of hexadecimal digits (with an optional sign and an optional 0x) and returns the corresponding number; returns zero if there is no such leading substring:

'0x0a'.hex        # => 10
'-1234'.hex       # => -4660
'0'.hex           # => 0
'non-numeric'.hex # => 0
____________________________________________________________________
    oct: Returns the integer value of the leading characters, interpreted as octal digits.
    
'123'.oct             # => 83
'-377'.oct            # => -255
'0377non-numeric'.oct # => 255
'non-numeric'.oct     # => 0
____________________________________________________________________
    ord: Returns the integer ordinal of the first character in self.
'h'.ord         # => 104
'hello'.ord     # => 104
____________________________________________________________________
    to_i: Returns the integer value of leading characters, interpreted as an integer.

to_i(base = 10) → integer

Returns the result of interpreting leading characters in self as an integer in the given base (which must be in (0, 2..36)):

'123456'.to_i     # => 123456
'123def'.to_i(16) # => 1195503 (it is a hexadecimal represtion to integer)

With base zero, string object may contain leading characters to specify the actual base:

'123def'.to_i(0)   # => 123
'0123def'.to_i(0)  # => 83
'0b123def'.to_i(0) # => 1
'0o123def'.to_i(0) # => 83
'0d123def'.to_i(0) # => 123
'0x123def'.to_i(0) # => 1195503

Characters past a leading valid number (in the given base) are ignored:

'12.345'.to_i   # => 12
'12345'.to_i(2) # => 1

'a'.to_i(16)	#=> 10 
'a'.to_i(10)	#=> 0 
'a'.to_i(0)	#=> 0 
'1'.to_i(16)	# => 1 
'1'.to_i(10)	# => 1 
'1'.to_i(0)	#=> 1 
'1'.to_i(a)
(irb):106:in `<main>': undefined local variable or method `a' for main:Object (NameError)

'111111'.to_i(10)	# => 111111 
'111111'.to_i(0)	# => 111111 
'111111'.to_i(8)	# => 37449 
'111111'.to_i(16)	#=> 1118481 

Returns zero if there is no leading valid number:

'abcdef'.to_i # => 0
'2'.to_i(2)   # => 0
____________________________________________________________________
    to_f: Returns the floating-point value of leading characters, interpreted as a floating-point number.
(simiiar to to_i but it will return float value)

'3.14159'.to_f  # => 3.14159
'1.234e-2'.to_f # => 0.01234

Characters past a leading valid number (in the given base) are ignored:
'3.14 (pi to two places)'.to_f # => 3.14
'3.14333 (pi to two places)'.to_f	#=> 3.14333

Returns zero if there is no leading valid number:
'abcdef'.to_f # => 0.0
____________________________________________________________________
@@@@Strings and Symbols
________________________

    inspect: Returns copy of self, enclosed in double-quotes, with special characters escaped.
s = "foo\tbar\tbaz\n"
s.inspect
# => "\"foo\\tbar\\tbaz\\n\""
____________________________________________________________________
    to_sym, intern: Returns the symbol corresponding to self.
intern → symbol


Returns the Symbol corresponding to str, creating the symbol if it did not previously exist. See Symbol#id2name.

"Koala".intern          #=> :Koala
"Koala".to_sym		#=> :Koala 

s = 'cat'.to_sym       #=> :cat
s = '@cat'.to_sym      #=> :@cat

This can also be used to create symbols that cannot be represented using the :xxx notation.

'cat and dog'.to_sym   #=> :"cat and dog"
____________________________________________________________________
  
########## END ###########

