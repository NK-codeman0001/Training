Arrays
_____________________________________________________________________________________
########## [] ###########
friends = Array[1,2.3,"Ram"]
or
friends = Array.new
friends[0]=1
friends[1]=3.3
friends[2] ="Ram"

########## Array literal ###########
3.2.1 :002 > arr=[1, 'one', :one, [2, 'two', :two]]
 => [1, "one", :one, [2, "two", :two]] 
3.2.1 :003 > arr
 => [1, "one", :one, [2, "two", :two]] 
 
3.2.1 :004 > %w[neeraj kumar, graduate engineer trainee]
 => ["neeraj", "kumar,", "graduate", "engineer", "trainee"] 

3.2.1 :005 > %i[neeraj kumar, graduate engineer trainee]
 => [:neeraj, :"kumar,", :graduate, :engineer, :trainee] 
 
 3.2.1 :006 > Array(key: :value)   
 => [[:key, :value]] 

3.2.1 :008 > Array({:a => "a", :b => "b"})
 => [[:a, "a"], [:b, "b"]] 

3.2.1 :009 > Array(nil) 
 => []

3.2.1 :013 > Array.new 
 => [] 
 
3.2.1 :010 > Array.new(3) 
 => [nil, nil, nil] 
 
3.2.1 :011 > Array.new(4) {Hash.new}
 => [{}, {}, {}, {}] 

3.2.1 :012 > Array.new(3, true) 
 => [true, true, true] 
 
3.2.1 :014 > Array.new(4) {|i| i.to_s }
 => ["0", "1", "2", "3"] 
 
3.2.1 :015 > Array.new(3) {Array.new(3)}
 => [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]] 

########## array information ###########

3.2.1 :001 > arr=Array(1..5)
 => [1, 2, 3, 4, 5]
 3.2.1 :030 > arr.length
 => 5 
3.2.1 :031 > arr.size
 => 5 
3.2.1 :032 > arr.count
 => 5 
3.2.1 :034 > arr.empty?
 => false 
 
 
3.2.1 :035 > arr[6]=nil
 => nil 
3.2.1 :036 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :037 > arr.length
 => 7 
3.2.1 :038 > arr.size
 => 7 
3.2.1 :039 > arr.count
 => 7 
3.2.1 :040 > arr.empty?
 => false 

3.2.1 :041 > arr.include?5
 => true 
3.2.1 :042 > arr.include?(5)
 => true 
 3.2.1 :044 > arr.include?nil
 => true 
 

########## puts ###########
puts friends   	##prints every element of array in new line
puts friends[0]  ##prints 1st element of array in
puts friends[0,2] 	##prints 2 element from 0 index of array in new line

########## methods ###########
friends.length()
friends.include? "Ram"     #case sensitive
friends.reverse()
friends.sort()       ##it will work only when all element have same data types

########## Adding Items to Arrays ###########
3.2.1 :045 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :046 > arr.push(200)
 => [1, 2, 3, 4, 5, nil, nil, 200] 
3.2.1 :047 > arr<<6
 => [1, 2, 3, 4, 5, nil, nil, 200, 6] 

//unshift
unshift will add a new item to the beginning of an array.

3.2.1 :048 > arr.unshift(404)
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6] 
 
//insert
With insert you can add a new element to an array at any position.
If there is already an element at that position then new element will be added at that index only shifting the other elements

3.2.1 :049 > arr.size
 => 10 
3.2.1 :050 > arr.insert(10,'Apple')
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple"] 
3.2.1 :051 > arr.insert(15,'A2')
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A2"] 

3.2.1 :055 > arr
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A3", nil] 
3.2.1 :056 > arr.insert(1,'one')
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A3", nil] 
3.2.1 :057 > arr[16]
 => "A2" 
3.2.1 :058 > arr.insert(16,'sixteen') //it will shift the other elements
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen", "A2", "A3", nil] 

3.2.1 :059 > arr.insert(0,'0','1','2')  //adding multiple element at a time.
 => ["0", "1", "2", 404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen", "A2", "A3", nil] 

########## Removing Items from an Array ###########
//pop (remove last element and return it)
The method pop removes the last element in an array and returns it:

3.2.1 :062 > arr.pop
 => "A3" 
3.2.1 :063 > d=arr.pop
 => "A2" 
3.2.1 :064 > d
 => "A2" 
//shift (remove first element and return it)
To retrieve and at the same time remove the first item, use shift:
3.2.1 :065 > d=arr.shift
 => "0" 
3.2.1 :066 > d
 => "0" 

//delete_at(index)  
To delete an element at a particular index:
3.2.1 :067 > d=arr.delete_at(0)
 => "1" 
3.2.1 :068 > d
 => "1" 
 
//delete(value)
To delete a particular element anywhere in an array, use delete
3.2.1 :069 > d=arr.delete(0)
 => nil 
3.2.1 :070 > d=arr.delete('2')
 => "2" 
3.2.1 :071 > d
 => "2" 

//compact and compact! 
A useful method if you need to remove nil values from an array is compact:
3.2.1 :072 > arr.compact
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :073 > arr
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen"] 
3.2.1 :074 > arr.compact!
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :075 > arr
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 

########## Iterating over Arrays ###########
3.2.1 :081 > num=Array(1..5)
 => [1, 2, 3, 4, 5] 
 
//.each
In case of Array’s each, all elements in the Array instance are yielded to the supplied block in sequence.
Note that this operation leaves the array unchanged.

3.2.1 :082 > num.each {|i| print i -= 10, " "}
-9 -8 -7 -6 -5  => [1, 2, 3, 4, 5] 

//.reverse_each
reverse_each which will iterate over the elements in the array in reverse order.

3.2.1 :083 > arr.reverse_each {|i| print i, " "}
sixteen Apple 6 200 5 4 3 2 1 one 404  => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"]                                               
3.2.1 :084 > words=%w[hello world ruby]
 => ["hello", "world", "ruby"] 
3.2.1 :085 > str=""
 => "" 
3.2.1 :086 > words.reverse_each {|i| str += "#{i}"}
 => ["hello", "world", "ruby"] 
3.2.1 :087 > str
 => "rubyworldhello" 
3.2.1 :088 > str=""
 => "" 
3.2.1 :089 > words.reverse_each {|i| str += "#{i} "}
 => ["hello", "world", "ruby"] 
 
//map
The map method can be used to create a new array based on the original array, but with the values modified by the supplied block

3.2.1 :090 > arr.map {|i| i*2}
 => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
3.2.1 :091 > arr
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :092 > arr.map! {|i| i*2}
 => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
3.2.1 :093 > arr
 => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 

########## Selecting Items from an Array ###########
select! and reject! are the corresponding destructive methods to select and reject

Similar to select vs. reject, delete_if and keep_if have the exact opposite result when supplied with the same block

3.2.1 :094 > num
 => [1, 2, 3, 4, 5] 
 //select
3.2.1 :095 > num.select {|i| i>3}
 => [4, 5] 
 
//reject
3.2.1 :096 > num.reject {|i| i>3}
 => [1, 2, 3]
 
//drop_while  (it is similar to use while loop with drop function)
 
3.2.1 :097 > num.drop_while {|i| i>3}  (the while loop breaks since the initial condition is not meet for first element)
 => [1, 2, 3, 4, 5] 
3.2.1 :101 > num.drop_while { |i| i < 3}
 => [3, 4, 5] 
 
//delete_if
3.2.1 :103 > num.delete_if {|i| i>3}
 => [1, 2, 3] 
3.2.1 :104 > num
 => [1, 2, 3]
 
 //keep_if 
3.2.1 :105 > num.keep_if {|i| i>3}
 => []  
3.2.1 :107 > num
 => [] 


########## array & other_array ###########
Returns a new array containing elements common to the two arrays, with no duplicates.

3.2.1 :128 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :129 > arr2=[1,3,6,3,6,7,5]
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :130 > arr & arr2
 => [1, 3, 5] 

########## array * int ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :143 > arr3 = arr*1
 => [1, 2, 3, 4, 5] 
3.2.1 :144 > arr3 = arr*2
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
3.2.1 :145 > arr3 = arr*3
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
 
 3.2.1 :152 > str * 1
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :153 > str * 2
 => ["Ram", "Shayam", "Radha", "Ram", "Shayam", "Radha"] 

########## array * str ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :146 > str =['Ram','Shayam','Radha']
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :147 > str *,
3.2.1 :148 > 
^C                                      
3.2.1 :147 > str * ","
 => "Ram,Shayam,Radha" 
3.2.1 :148 > str * "R"
 => "RamRShayamRRadha" 
3.2.1 :149 > str * "<+>"
 => "Ram<+>Shayam<+>Radha" 
 
 3.2.1 :150 > arr*","
 => "1,2,3,4,5" 
3.2.1 :151 > arr*"=>"
 => "1=>2=>3=>4=>5" 

 
########## array + other_array ###########
Returns a new array built by concatenating the two arrays together to produce a third array.
3.2.1 :155 > arr3= arr + str
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :156 > arr4 = arr + arr2
 => [1, 2, 3, 4, 5, 1, 3, 6, 3, 6, 7, 5] 


########## array - other_array ###########
Returns a new array that is a copy of the original array, removing any items that also appear in other_array.
3.2.1 :157 > arr3
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :158 > arr3-arr
 => ["Ram", "Shayam", "Radha"] 


########## array | other_array ###########
Returns a new array by joining array with other_array, removing
duplicates.
3.2.1 :161 > arr
 => [1, 2, 3, 4, 5] 
3.2.1 :162 > arr2
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :163 > arr | arr2
 => [1, 2, 3, 4, 5, 6, 7] 
3.2.1 :164 > 


########## array << obj ###########
Pushes the given object onto the end of array. This expression returns the array itself, so several appends may be chained together.
//push_back
3.2.1 :175 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :176 > arr<<404
 => [1, 2, 3, 4, 5, 404] 
 
 //recuring values (bad practice)
 3.2.1 :039 > arr<<arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :040 > arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :041 > arr[5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :042 > arr[5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :043 > arr[5][5][5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :044 > str
 => ["Neeraj", "Kumar"] 
3.2.1 :045 > str[1]
 => "Kumar" 
3.2.1 :046 > str[1][1]
 => "u" 
3.2.1 :047 > str[1][1][1]
 => nil 

 
########## range,slice,index ###########
array[range]
3.2.1 :180 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9]

array.slice(index) 
3.2.1 :186 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
3.2.1 :187 > arr.slice(5,8)
 => [6, 7, 8, 9] 
 
 array.slice(range)
 3.2.1 :188 > arr.slice(5..8)
 => [6, 7, 8, 9] 
 
 array[start, length]
 3.2.1 :189 > arr[2,3]
 => [3, 4, 5]
 
########## input values in array ###########
3.2.1 :005 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
 
 array[index] = obj
3.2.1 :006 > arr[10]=100
 => 100 
3.2.1 :007 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100] 
3.2.1 :008 > arr<<200
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100, 200] 
 
 array[start, length] = obj or an_array or nil [or]
3.2.1 :009 > arr[3,6]=404
 => 404 
3.2.1 :010 > arr
 => [1, 2, 3, 404, nil, 100, 200] 
 
array[range] = obj or an_array or nil
3.2.1 :011 > arr[0..2]=500
 => 500 
3.2.1 :012 > arr
 => [500, 404, nil, 100, 200] 

########## array.abbrev(pattern = nil) ###########
Calculates the set of unambiguous abbreviations for the strings in self. If passed a pattern or a string, only the strings matching the pattern or starting with the string are considered.

3.2.1 :023 > require 'abbrev'
 => true 
3.2.1 :024 > arr.abbrev
/usr/share/rvm/rubies/ruby-3.2.1/lib/ruby/3.2.0/abbrev.rb:82:in `block in abbrev': undefined method `empty?' for 500:Integer (NoMethodError)

      next if word.empty?
      
3.2.1 :020 > str=['Neeraj','Kumar']
 => ["Neeraj", "Kumar"] 
3.2.1 :021 > str.abbrev
 => 
{"Neeraj"=>"Neeraj",                             
 "Neera"=>"Neeraj",                              
 "Neer"=>"Neeraj",                               
 "Nee"=>"Neeraj",                                
 "Ne"=>"Neeraj",                                 
 "N"=>"Neeraj",                                  
 "Kumar"=>"Kumar",                               
 "Kuma"=>"Kumar",                                
 "Kum"=>"Kumar",                                 
 "Ku"=>"Kumar",                                  
 "K"=>"Kumar"}  

########## array.assoc(obj) ###########
Searches through an array whose elements are also arrays comparing obj with the ﬁrst element of each contained array using obj.==. Returns the ﬁrst contained array that matches or nil if no match is found.
3.2.1 :062 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :063 > arr.assoc(1)
 => [1, 2, 3, 4] 
3.2.1 :064 > arr.assoc(500)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :065 > arr.rassoc(500)
 => nil 
3.2.1 :066 > arr.rassoc(404)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :067 > arr.rassoc(1)
 => nil 
3.2.1 :068 > arr.rassoc(2)
 => [1, 2, 3, 4] 

########## array.clear ###########
Removes all elements from array.
3.2.1 :070 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :071 > arr.clear
 => [] 
3.2.1 :072 > arr
 => [] 


########## array.collect { |item| block } [or]
array.map { |item| block } (return new array) ###########

3.2.1 :087 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :088 > arr.map{|i| 
3.2.1 :089 >   if i%2==0
3.2.1 :090 >     i
3.2.1 :091 >   end
3.2.1 :092 > }
 => 
[nil,                                               
 2,                                                 
 nil,                                               
 4,                                                 
 nil,                                               
 6,                                                 
 nil,                                               
 8,                                                 
 nil,                                           
 10,                                           
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :093 > arr.map{|i| 
3.2.1 :094 >   if i%2==0
3.2.1 :095 >     i
3.2.1 :096 >   end
3.2.1 :097 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 


########## array.collect! { |item| block } [or]
array.map! { |item| block } (it will change the original value of arr #inplace) ###########
3.2.1 :098 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :099 > arr.map!{|i| 
3.2.1 :100 >   if i%2==0
3.2.1 :101 >     i
3.2.1 :102 >   end
3.2.1 :103 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :104 > arr.map!{|i| 
3.2.1 :105 >   if i%2==0
3.2.1 :106 >     i
3.2.1 :107 >   end
3.2.1 :108 > }
(irb):105:in `block in <top (required)>': undefined method `%' for nil:NilClass (NoMethodError)

########## array.compact & array.compact! (inplace)  ###########
array.compact
Returns a copy of self with all nil elements removed.

array.compact!
Removes nil elements from array. Returns nil if no changes were made.

3.2.1 :132 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :133 > arr.map!{|i| 
3.2.1 :134 >   if i%2==0
3.2.1 :135 >     i
3.2.1 :136 >   end
3.2.1 :137 > }.compact
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :138 > arr
 => 
[nil,                                                                 
 2,                                                                   
 nil,                 
 4,                   
 nil,                 
 6,                   
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :139 > arr.compact!
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :140 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18]
 
########## array.concat(other_array) ###########
Appends the elements in other_array to self.
3.2.1 :142 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :143 > arr1= Array(19..25)
 => [19, 20, 21, 22, 23, 24, 25] 
3.2.1 :144 > arr.concat(arr1)
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :145 > 
 
########## array.delete(obj) [or]
array.delete(obj) { block } ###########

Deletes items from self that are equal to obj. If the item is not found,
returns nil. If the optional code block is given, returns the result of block
if the item is not found.

3.2.1 :151 > arr
 => [2, 4, 6, 8, 10, 12, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :152 > arr.delete(12){"not found"}
 => 12 
3.2.1 :153 > arr.delete(12){"not found"}
 => "not found" 
3.2.1 :154 > arr.delete(12)
 => nil 
3.2.1 :155 > arr.delete(16)
 => 16 


array.delete_at(index)
Deletes the element at the speciﬁed index, returning that element, or
nil if the index is out of range.
3.2.1 :156 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :157 > arr.delete_at(10)
 => 23 
3.2.1 :158 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 24, 25] 

array.delete_if { |item| block }

Deletes every element of self for which block evaluates to true.
3.2.1 :161 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :162 > arr.delete_if{|i| i%2==1}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 
########## array.empty?  and array.eql?(other)###########
array.empty?
Returns true if the self array contains no elements.

array.eql?(other)
Returns true if array and other are the same object, or are both arrays
with the same content.
 
########## array.each { |item| block } and array.each_index { |index| block } ###########

array.each { |item| block }
Calls block once for each element in self, passing that element as a
parameter.

array.each_index { |index| block }
Same as Array#each, but passes the index of the element instead of the
element itself.

3.2.1 :170 > arr.each {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :171 > arr.each_index {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 3.2.1 :173 > arr.each_index {|i| print i.to_s + " :"}
0 :1 :2 :3 :4 :5 :6 :7 :8 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :174 > arr.each {|i| print i.to_s + " :"}
2 :4 :6 :8 :10 :12 :14 :16 :18 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
########## array.fetch ###########
array.fetch(index) [or]
array.fetch(index, default) [or]
array.fetch(index) { |index| block }
Tries to return the element at position index. If index lies outside the array, the ﬁrst form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking block, passing in index. Negative values of index count from the end of the array.
 
array.fetch(index) 
3.2.1 :011 > arr.fetch(10)
 => 11 
3.2.1 :012 > arr.fetch(11)
(irb):12:in `fetch': index 11 outside of array bounds: -11...11 (IndexError)         


array.fetch(index, default) 
3.2.1 :013 > arr.fetch(11,404)
 => 404 

array.fetch(index) { |index| block }
3.2.1 :015 > arr.fetch(10){|i| put i}
 => 11 
3.2.1 :016 > arr.fetch(11){|i|}
 => nil 
3.2.1 :017 > arr.fetch(11){|i| i*2}
 => 22 
3.2.1 :018 > arr.fetch(11){|i| i}
 => 11 

########## arr.fill ###########
array.ﬁll(obj) [or]
array.ﬁll(obj, start , length) [or]
array.ﬁll(obj, range) [or]
array.ﬁll { |index| block } [or]
array.ﬁll(start [, length] ) { |index| block } [or]
array.ﬁll(range) { |index| block }
The ﬁrst three forms set the selected elements of self to obj. A start of
nil is equivalent to zero. A length of nil is equivalent to self.length. The
last three forms ﬁll the array with the value of the block. The block is
passed with the absolute index of each element to be ﬁlled.
 
array.ﬁll(obj)
3.2.1 :019 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :020 > arr.fill(404)
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404] 
3.2.1 :021 > arr
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404]
 
 
array.ﬁll(obj, start , length)
3.2.1 :029 > arr.fill(404,3 ,4)
 => [1, 2, 3, 404, 404, 404, 404, 8, 9, 10, 11] 
 
  
array.ﬁll(obj, range)
3.2.1 :031 > arr.fill(404,3..4)
 => [1, 2, 3, 404, 404, 6, 7, 8, 9, 10, 11] 
 

array.ﬁll { |index| block } 
3.2.1 :044 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 

3.2.1 :045 > arr.fill{|i|
3.2.1 :046 >   if i%2==0
3.2.1 :047 >     404
3.2.1 :048 >   else 
3.2.1 :049 >     i
3.2.1 :050 >   end
3.2.1 :051 > }
 => [404, 1, 404, 3, 404, 5, 404, 7, 404, 9, 404] 
 

array.ﬁll(start , length) { |index| block }
3.2.1 :059 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :060 > arr.fill(3,4){|i|
3.2.1 :061 >   if i%2==0
3.2.1 :062 >     404
3.2.1 :063 >   else 
3.2.1 :064 >     i
3.2.1 :065 >   end
3.2.1 :066 > }
 => [1, 2, 3, 3, 404, 5, 404, 8, 9, 10, 11] 


array.ﬁll(range) { |index| block }
3.2.1 :067 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :068 > arr.fill(3..4){|i|
3.2.1 :069 >   if i%2==0
3.2.1 :070 >     404
3.2.1 :071 >   else 
3.2.1 :072 >     i
3.2.1 :073 >   end
3.2.1 :074 > }
 => [1, 2, 3, 3, 404, 6, 7, 8, 9, 10, 11] 
3.2.1 :075 > 

  
########## array.first  ###########
array.ﬁrst [or]
array.ﬁrst(n)
Returns the ﬁrst element, or the ﬁrst n elements, of the array. If the
array is empty, the ﬁrst form returns nil, and the second form returns an
empty array.

array.ﬁrst
3.2.1 :078 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :079 > arr.first
 => 1 

3.2.1 :082 > arr1=[]
 => [] 
3.2.1 :084 > arr1.first
 => nil 

array.ﬁrst(n)
3.2.1 :080 > arr.first(5)
 => [1, 2, 3, 4, 5] 
3.2.1 :085 > arr1.first(5)
 => [] 
 
########## array.last(n) , take(n) , drop(n)  ###########
//last(n)

3.2.1 :026 > arr
 => [1, 2, 3, 4, 5] 
3.2.1 :027 > arr.last
 => 5 
3.2.1 :028 > arr.last(3)
 => [3, 4, 5] 
 
//take(n) 
to return the first n elements of an array, use take

3.2.1 :020 > arr.take(5)
 => [1, 2, 3, 4, 5] 
3.2.1 :021 > arr.take(6)
 => [1, 2, 3, 4, 5] 
3.2.1 :022 > arr.take(10)
 => [1, 2, 3, 4, 5] 

//drop(n)
drop does the opposite of take, by returning the elements after n elements have been dropped:
3.2.1 :024 > arr.drop(1)
 => [2, 3, 4, 5] 
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5]

########## array.ﬂatten ###########
array.ﬂatten
Returns a new array that is a one-dimensional ﬂattening of this array
(recursively).

array.ﬂatten!
Flattens array in place. Returns nil if no modiﬁcations were made. (array
contains no subarrays.)

array.ﬂatten
 3.2.1 :018 > arr=Array(1..5)
 => [1, 2, 3, 4, 5] 
3.2.1 :019 > arr1=Array(6..8)
 => [6, 7, 8] 
3.2.1 :020 > arr[5]=arr1
 => [6, 7, 8] 
3.2.1 :021 > arr
 => [1, 2, 3, 4, 5, [6, 7, 8]] 
3.2.1 :022 > arr.flatten
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :023 > arr
 => [1, 2, 3, 4, 5, [6, 7, 8]] 
 
array.ﬂatten!
3.2.1 :024 > arr.flatten!
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
 
########## array.hash ###########
Computes a hash-code for array. Two arrays with the same content will
have the same hash code.

3.2.1 :027 > arr.hash
 => -4241591116995688593 
3.2.1 :028 > arr1.hash
 => 3624524072152072368
 
########## array.frozen? ###########
array.frozen?
Returns true if array is frozen (or temporarily frozen while being sorted)
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :026 > arr.frozen?
 => false 

 
########## finding ###########
array.include?(obj)
Returns true if obj is present in self, false otherwise.
 
array.index(obj)
Returns the index of t 

array.include?(obj)
3.2.1 :033 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :034 > arr.include?(7)
 => true 
3.2.1 :035 > arr.include?(10)
 => false 
 
array.index(obj)
3.2.1 :036 > arr.index(7)
 => 6 
3.2.1 :037 > arr.index(10)
 => nil 
 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########


