Arrays
_____________________________________________________________________________________
########## [] ###########
friends = Array[1,2.3,"Ram"]
or
friends = Array.new
friends[0]=1
friends[1]=3.3
friends[2] ="Ram"

########## Array literal ###########
3.2.1 :002 > arr=[1, 'one', :one, [2, 'two', :two]]
 => [1, "one", :one, [2, "two", :two]] 
3.2.1 :003 > arr
 => [1, "one", :one, [2, "two", :two]] 




########## puts ###########
puts friends   	##prints every element of array in new line
puts friends[0]  ##prints 1st element of array in
puts friends[0,2] 	##prints 2 element from 0 index of array in new line

########## methods ###########
friends.length()
friends.include? "Ram"     #case sensitive
friends.reverse()
friends.sort()       ##it will work only when all element have same data types

########## array & other_array ###########
Returns a new array containing elements common to the two arrays, with no duplicates.

3.2.1 :128 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :129 > arr2=[1,3,6,3,6,7,5]
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :130 > arr & arr2
 => [1, 3, 5] 

########## array * int ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :143 > arr3 = arr*1
 => [1, 2, 3, 4, 5] 
3.2.1 :144 > arr3 = arr*2
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
3.2.1 :145 > arr3 = arr*3
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
 
 3.2.1 :152 > str * 1
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :153 > str * 2
 => ["Ram", "Shayam", "Radha", "Ram", "Shayam", "Radha"] 

########## array * str ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :146 > str =['Ram','Shayam','Radha']
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :147 > str *,
3.2.1 :148 > 
^C                                      
3.2.1 :147 > str * ","
 => "Ram,Shayam,Radha" 
3.2.1 :148 > str * "R"
 => "RamRShayamRRadha" 
3.2.1 :149 > str * "<+>"
 => "Ram<+>Shayam<+>Radha" 
 
 3.2.1 :150 > arr*","
 => "1,2,3,4,5" 
3.2.1 :151 > arr*"=>"
 => "1=>2=>3=>4=>5" 

 
########## array + other_array ###########
Returns a new array built by concatenating the two arrays together to produce a third array.
3.2.1 :155 > arr3= arr + str
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :156 > arr4 = arr + arr2
 => [1, 2, 3, 4, 5, 1, 3, 6, 3, 6, 7, 5] 


########## array - other_array ###########
Returns a new array that is a copy of the original array, removing any items that also appear in other_array.
3.2.1 :157 > arr3
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :158 > arr3-arr
 => ["Ram", "Shayam", "Radha"] 


########## array | other_array ###########
Returns a new array by joining array with other_array, removing
duplicates.
3.2.1 :161 > arr
 => [1, 2, 3, 4, 5] 
3.2.1 :162 > arr2
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :163 > arr | arr2
 => [1, 2, 3, 4, 5, 6, 7] 
3.2.1 :164 > 


########## array << obj ###########
Pushes the given object onto the end of array. This expression returns the array itself, so several appends may be chained together.
//push_back
3.2.1 :175 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :176 > arr<<404
 => [1, 2, 3, 4, 5, 404] 
 
 //recuring values (bad practice)
 3.2.1 :039 > arr<<arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :040 > arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :041 > arr[5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :042 > arr[5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :043 > arr[5][5][5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :044 > str
 => ["Neeraj", "Kumar"] 
3.2.1 :045 > str[1]
 => "Kumar" 
3.2.1 :046 > str[1][1]
 => "u" 
3.2.1 :047 > str[1][1][1]
 => nil 

 
########## range,slice,index ###########
array[range]
3.2.1 :180 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9]

array.slice(index) 
3.2.1 :186 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
3.2.1 :187 > arr.slice(5,8)
 => [6, 7, 8, 9] 
 
 array.slice(range)
 3.2.1 :188 > arr.slice(5..8)
 => [6, 7, 8, 9] 
 
 array[start, length]
 3.2.1 :189 > arr[2,3]
 => [3, 4, 5]
 
########## input values in array ###########
3.2.1 :005 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
 
 array[index] = obj
3.2.1 :006 > arr[10]=100
 => 100 
3.2.1 :007 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100] 
3.2.1 :008 > arr<<200
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100, 200] 
 
 array[start, length] = obj or an_array or nil [or]
3.2.1 :009 > arr[3,6]=404
 => 404 
3.2.1 :010 > arr
 => [1, 2, 3, 404, nil, 100, 200] 
 
array[range] = obj or an_array or nil
3.2.1 :011 > arr[0..2]=500
 => 500 
3.2.1 :012 > arr
 => [500, 404, nil, 100, 200] 

########## array.abbrev(pattern = nil) ###########
Calculates the set of unambiguous abbreviations for the strings in self. If passed a pattern or a string, only the strings matching the pattern or starting with the string are considered.

3.2.1 :023 > require 'abbrev'
 => true 
3.2.1 :024 > arr.abbrev
/usr/share/rvm/rubies/ruby-3.2.1/lib/ruby/3.2.0/abbrev.rb:82:in `block in abbrev': undefined method `empty?' for 500:Integer (NoMethodError)

      next if word.empty?
      
3.2.1 :020 > str=['Neeraj','Kumar']
 => ["Neeraj", "Kumar"] 
3.2.1 :021 > str.abbrev
 => 
{"Neeraj"=>"Neeraj",                             
 "Neera"=>"Neeraj",                              
 "Neer"=>"Neeraj",                               
 "Nee"=>"Neeraj",                                
 "Ne"=>"Neeraj",                                 
 "N"=>"Neeraj",                                  
 "Kumar"=>"Kumar",                               
 "Kuma"=>"Kumar",                                
 "Kum"=>"Kumar",                                 
 "Ku"=>"Kumar",                                  
 "K"=>"Kumar"}  

########## array.assoc(obj) ###########
Searches through an array whose elements are also arrays comparing obj with the ﬁrst element of each contained array using obj.==. Returns the ﬁrst contained array that matches or nil if no match is found.
3.2.1 :062 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :063 > arr.assoc(1)
 => [1, 2, 3, 4] 
3.2.1 :064 > arr.assoc(500)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :065 > arr.rassoc(500)
 => nil 
3.2.1 :066 > arr.rassoc(404)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :067 > arr.rassoc(1)
 => nil 
3.2.1 :068 > arr.rassoc(2)
 => [1, 2, 3, 4] 

########## array.clear ###########
Removes all elements from array.
3.2.1 :070 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :071 > arr.clear
 => [] 
3.2.1 :072 > arr
 => [] 


########## array.collect { |item| block } [or]
array.map { |item| block } (return new array) ###########

3.2.1 :087 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :088 > arr.map{|i| 
3.2.1 :089 >   if i%2==0
3.2.1 :090 >     i
3.2.1 :091 >   end
3.2.1 :092 > }
 => 
[nil,                                               
 2,                                                 
 nil,                                               
 4,                                                 
 nil,                                               
 6,                                                 
 nil,                                               
 8,                                                 
 nil,                                           
 10,                                           
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :093 > arr.map{|i| 
3.2.1 :094 >   if i%2==0
3.2.1 :095 >     i
3.2.1 :096 >   end
3.2.1 :097 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 


########## array.collect! { |item| block } [or]
array.map! { |item| block } (it will change the original value of arr #inplace) ###########
3.2.1 :098 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :099 > arr.map!{|i| 
3.2.1 :100 >   if i%2==0
3.2.1 :101 >     i
3.2.1 :102 >   end
3.2.1 :103 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :104 > arr.map!{|i| 
3.2.1 :105 >   if i%2==0
3.2.1 :106 >     i
3.2.1 :107 >   end
3.2.1 :108 > }
(irb):105:in `block in <top (required)>': undefined method `%' for nil:NilClass (NoMethodError)

########## array.compact & array.compact! (inplace)  ###########
array.compact
Returns a copy of self with all nil elements removed.

array.compact!
Removes nil elements from array. Returns nil if no changes were made.

3.2.1 :132 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :133 > arr.map!{|i| 
3.2.1 :134 >   if i%2==0
3.2.1 :135 >     i
3.2.1 :136 >   end
3.2.1 :137 > }.compact
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :138 > arr
 => 
[nil,                                                                 
 2,                                                                   
 nil,                 
 4,                   
 nil,                 
 6,                   
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :139 > arr.compact!
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :140 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18]
 
########## array.concat(other_array) ###########
Appends the elements in other_array to self.
3.2.1 :142 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :143 > arr1= Array(19..25)
 => [19, 20, 21, 22, 23, 24, 25] 
3.2.1 :144 > arr.concat(arr1)
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :145 > 
 
########## array.delete(obj) [or]
array.delete(obj) { block } ###########

Deletes items from self that are equal to obj. If the item is not found,
returns nil. If the optional code block is given, returns the result of block
if the item is not found.

3.2.1 :151 > arr
 => [2, 4, 6, 8, 10, 12, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :152 > arr.delete(12){"not found"}
 => 12 
3.2.1 :153 > arr.delete(12){"not found"}
 => "not found" 
3.2.1 :154 > arr.delete(12)
 => nil 
3.2.1 :155 > arr.delete(16)
 => 16 


array.delete_at(index)
Deletes the element at the speciﬁed index, returning that element, or
nil if the index is out of range.
3.2.1 :156 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :157 > arr.delete_at(10)
 => 23 
3.2.1 :158 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 24, 25] 

array.delete_if { |item| block }

Deletes every element of self for which block evaluates to true.
3.2.1 :161 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :162 > arr.delete_if{|i| i%2==1}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 
########## array.empty?  and array.eql?(other)###########
array.empty?
Returns true if the self array contains no elements.

array.eql?(other)
Returns true if array and other are the same object, or are both arrays
with the same content.
 
########## array.each { |item| block } and array.each_index { |index| block } ###########

array.each { |item| block }
Calls block once for each element in self, passing that element as a
parameter.

array.each_index { |index| block }
Same as Array#each, but passes the index of the element instead of the
element itself.

3.2.1 :170 > arr.each {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :171 > arr.each_index {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 3.2.1 :173 > arr.each_index {|i| print i.to_s + " :"}
0 :1 :2 :3 :4 :5 :6 :7 :8 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :174 > arr.each {|i| print i.to_s + " :"}
2 :4 :6 :8 :10 :12 :14 :16 :18 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
########## array.fetch ###########
array.fetch(index) [or]
array.fetch(index, default) [or]
array.fetch(index) { |index| block }
Tries to return the element at position index. If index lies outside the array, the ﬁrst form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking block, passing in index. Negative values of index count from the end of the array.
 
array.fetch(index) 
3.2.1 :011 > arr.fetch(10)
 => 11 
3.2.1 :012 > arr.fetch(11)
(irb):12:in `fetch': index 11 outside of array bounds: -11...11 (IndexError)         


array.fetch(index, default) 
3.2.1 :013 > arr.fetch(11,404)
 => 404 

array.fetch(index) { |index| block }
3.2.1 :015 > arr.fetch(10){|i| put i}
 => 11 
3.2.1 :016 > arr.fetch(11){|i|}
 => nil 
3.2.1 :017 > arr.fetch(11){|i| i*2}
 => 22 
3.2.1 :018 > arr.fetch(11){|i| i}
 => 11 

########## arr.fill ###########
array.ﬁll(obj) [or]
array.ﬁll(obj, start , length) [or]
array.ﬁll(obj, range) [or]
array.ﬁll { |index| block } [or]
array.ﬁll(start [, length] ) { |index| block } [or]
array.ﬁll(range) { |index| block }
The ﬁrst three forms set the selected elements of self to obj. A start of
nil is equivalent to zero. A length of nil is equivalent to self.length. The
last three forms ﬁll the array with the value of the block. The block is
passed with the absolute index of each element to be ﬁlled.
 
array.ﬁll(obj)
3.2.1 :019 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :020 > arr.fill(404)
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404] 
3.2.1 :021 > arr
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404]
 
 
array.ﬁll(obj, start , length)
3.2.1 :029 > arr.fill(404,3 ,4)
 => [1, 2, 3, 404, 404, 404, 404, 8, 9, 10, 11] 
 
  
array.ﬁll(obj, range)
3.2.1 :031 > arr.fill(404,3..4)
 => [1, 2, 3, 404, 404, 6, 7, 8, 9, 10, 11] 
 

array.ﬁll { |index| block } 
3.2.1 :044 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 

3.2.1 :045 > arr.fill{|i|
3.2.1 :046 >   if i%2==0
3.2.1 :047 >     404
3.2.1 :048 >   else 
3.2.1 :049 >     i
3.2.1 :050 >   end
3.2.1 :051 > }
 => [404, 1, 404, 3, 404, 5, 404, 7, 404, 9, 404] 
 

array.ﬁll(start , length) { |index| block }
3.2.1 :059 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :060 > arr.fill(3,4){|i|
3.2.1 :061 >   if i%2==0
3.2.1 :062 >     404
3.2.1 :063 >   else 
3.2.1 :064 >     i
3.2.1 :065 >   end
3.2.1 :066 > }
 => [1, 2, 3, 3, 404, 5, 404, 8, 9, 10, 11] 


array.ﬁll(range) { |index| block }
3.2.1 :067 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :068 > arr.fill(3..4){|i|
3.2.1 :069 >   if i%2==0
3.2.1 :070 >     404
3.2.1 :071 >   else 
3.2.1 :072 >     i
3.2.1 :073 >   end
3.2.1 :074 > }
 => [1, 2, 3, 3, 404, 6, 7, 8, 9, 10, 11] 
3.2.1 :075 > 

  
########## array.first  ###########
array.ﬁrst [or]
array.ﬁrst(n)
Returns the ﬁrst element, or the ﬁrst n elements, of the array. If the
array is empty, the ﬁrst form returns nil, and the second form returns an
empty array.

array.ﬁrst
3.2.1 :078 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :079 > arr.first
 => 1 

3.2.1 :082 > arr1=[]
 => [] 
3.2.1 :084 > arr1.first
 => nil 

array.ﬁrst(n)
3.2.1 :080 > arr.first(5)
 => [1, 2, 3, 4, 5] 
3.2.1 :085 > arr1.first(5)
 => [] 
 
########## array.ﬂatten ###########
array.ﬂatten
Returns a new array that is a one-dimensional ﬂattening of this array
(recursively).

array.ﬂatten!
Flattens array in place. Returns nil if no modiﬁcations were made. (array
contains no subarrays.)

array.ﬂatten
 3.2.1 :018 > arr=Array(1..5)
 => [1, 2, 3, 4, 5] 
3.2.1 :019 > arr1=Array(6..8)
 => [6, 7, 8] 
3.2.1 :020 > arr[5]=arr1
 => [6, 7, 8] 
3.2.1 :021 > arr
 => [1, 2, 3, 4, 5, [6, 7, 8]] 
3.2.1 :022 > arr.flatten
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :023 > arr
 => [1, 2, 3, 4, 5, [6, 7, 8]] 
 
array.ﬂatten!
3.2.1 :024 > arr.flatten!
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
 
########## array.hash ###########
Computes a hash-code for array. Two arrays with the same content will
have the same hash code.

3.2.1 :027 > arr.hash
 => -4241591116995688593 
3.2.1 :028 > arr1.hash
 => 3624524072152072368
 
########## array.frozen? ###########
array.frozen?
Returns true if array is frozen (or temporarily frozen while being sorted)
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :026 > arr.frozen?
 => false 

 
########## finding ###########
array.include?(obj)
Returns true if obj is present in self, false otherwise.
 
array.index(obj)
Returns the index of t 

array.include?(obj)
3.2.1 :033 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :034 > arr.include?(7)
 => true 
3.2.1 :035 > arr.include?(10)
 => false 
 
array.index(obj)
3.2.1 :036 > arr.index(7)
 => 6 
3.2.1 :037 > arr.index(10)
 => nil 
 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########


