Arrays
_____________________________________________________________________________________
########## [] ###########
friends = Array[1,2.3,"Ram"]
or
friends = Array.new
friends[0]=1
friends[1]=3.3
friends[2] ="Ram"

########## Array literal ###########
3.2.1 :002 > arr=[1, 'one', :one, [2, 'two', :two]]
 => [1, "one", :one, [2, "two", :two]] 
3.2.1 :003 > arr
 => [1, "one", :one, [2, "two", :two]] 
 
3.2.1 :004 > %w[neeraj kumar, graduate engineer trainee]
 => ["neeraj", "kumar,", "graduate", "engineer", "trainee"] 

3.2.1 :005 > %i[neeraj kumar, graduate engineer trainee]
 => [:neeraj, :"kumar,", :graduate, :engineer, :trainee] 
 
 3.2.1 :006 > Array(key: :value)   
 => [[:key, :value]] 

3.2.1 :008 > Array({:a => "a", :b => "b"})
 => [[:a, "a"], [:b, "b"]] 

3.2.1 :009 > Array(nil) 
 => []

3.2.1 :013 > Array.new 
 => [] 
 
3.2.1 :010 > Array.new(3) 
 => [nil, nil, nil] 
 
3.2.1 :011 > Array.new(4) {Hash.new}
 => [{}, {}, {}, {}] 

3.2.1 :012 > Array.new(3, true) 
 => [true, true, true] 
 
3.2.1 :014 > Array.new(4) {|i| i.to_s }
 => ["0", "1", "2", "3"] 
 
3.2.1 :015 > Array.new(3) {Array.new(3)}
 => [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]] 

########## array information ###########

3.2.1 :001 > arr=Array(1..5)
 => [1, 2, 3, 4, 5]
 3.2.1 :030 > arr.length
 => 5 
3.2.1 :031 > arr.size
 => 5 
3.2.1 :032 > arr.count
 => 5 
3.2.1 :034 > arr.empty?
 => false 
 
 
3.2.1 :035 > arr[6]=nil
 => nil 
3.2.1 :036 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :037 > arr.length
 => 7 
3.2.1 :038 > arr.size
 => 7 
3.2.1 :039 > arr.count
 => 7 
3.2.1 :040 > arr.empty?
 => false 

3.2.1 :041 > arr.include?5
 => true 
3.2.1 :042 > arr.include?(5)
 => true 
 3.2.1 :044 > arr.include?nil
 => true 
 

########## puts ###########
puts friends   	##prints every element of array in new line
puts friends[0]  ##prints 1st element of array in
puts friends[0,2] 	##prints 2 element from 0 index of array in new line

########## methods ###########
friends.length()
friends.include? "Ram"     #case sensitive
friends.reverse()
friends.sort()       ##it will work only when all element have same data types

########## Adding Items to Arrays ###########
3.2.1 :045 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :046 > arr.push(200)
 => [1, 2, 3, 4, 5, nil, nil, 200] 
3.2.1 :047 > arr<<6
 => [1, 2, 3, 4, 5, nil, nil, 200, 6] 

//unshift
unshift will add a new item to the beginning of an array.

3.2.1 :048 > arr.unshift(404)
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6] 
 
//insert
With insert you can add a new element to an array at any position.
If there is already an element at that position then new element will be added at that index only shifting the other elements

3.2.1 :049 > arr.size
 => 10 
3.2.1 :050 > arr.insert(10,'Apple')
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple"] 
3.2.1 :051 > arr.insert(15,'A2')
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A2"] 

3.2.1 :055 > arr
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A3", nil] 
3.2.1 :056 > arr.insert(1,'one')
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A3", nil] 
3.2.1 :057 > arr[16]
 => "A2" 
3.2.1 :058 > arr.insert(16,'sixteen') //it will shift the other elements
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen", "A2", "A3", nil] 

3.2.1 :059 > arr.insert(0,'0','1','2')  //adding multiple element at a time.
 => ["0", "1", "2", 404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen", "A2", "A3", nil] 

########## Removing Items from an Array ###########
//pop (remove last element and return it)
The method pop removes the last element in an array and returns it:

3.2.1 :062 > arr.pop
 => "A3" 
3.2.1 :063 > d=arr.pop
 => "A2" 
3.2.1 :064 > d
 => "A2" 
//shift (remove first element and return it)
To retrieve and at the same time remove the first item, use shift:
3.2.1 :065 > d=arr.shift
 => "0" 
3.2.1 :066 > d
 => "0" 

//delete_at(index)  
To delete an element at a particular index:
3.2.1 :067 > d=arr.delete_at(0)
 => "1" 
3.2.1 :068 > d
 => "1" 
 
//delete(value)
To delete a particular element anywhere in an array, use delete
3.2.1 :069 > d=arr.delete(0)
 => nil 
3.2.1 :070 > d=arr.delete('2')
 => "2" 
3.2.1 :071 > d
 => "2" 

//compact and compact! 
A useful method if you need to remove nil values from an array is compact:
3.2.1 :072 > arr.compact
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :073 > arr
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen"] 
3.2.1 :074 > arr.compact!
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :075 > arr
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 

########## Iterating over Arrays ###########
3.2.1 :081 > num=Array(1..5)
 => [1, 2, 3, 4, 5] 
 
//.each
In case of Array’s each, all elements in the Array instance are yielded to the supplied block in sequence.
Note that this operation leaves the array unchanged.

3.2.1 :082 > num.each {|i| print i -= 10, " "}
-9 -8 -7 -6 -5  => [1, 2, 3, 4, 5] 

//.reverse_each
reverse_each which will iterate over the elements in the array in reverse order.

3.2.1 :083 > arr.reverse_each {|i| print i, " "}
sixteen Apple 6 200 5 4 3 2 1 one 404  => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"]                                               
3.2.1 :084 > words=%w[hello world ruby]
 => ["hello", "world", "ruby"] 
3.2.1 :085 > str=""
 => "" 
3.2.1 :086 > words.reverse_each {|i| str += "#{i}"}
 => ["hello", "world", "ruby"] 
3.2.1 :087 > str
 => "rubyworldhello" 
3.2.1 :088 > str=""
 => "" 
3.2.1 :089 > words.reverse_each {|i| str += "#{i} "}
 => ["hello", "world", "ruby"] 
 
//map
The map method can be used to create a new array based on the original array, but with the values modified by the supplied block

3.2.1 :090 > arr.map {|i| i*2}
 => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
3.2.1 :091 > arr
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :092 > arr.map! {|i| i*2}
 => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
3.2.1 :093 > arr
 => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 

########## Selecting Items from an Array ###########
select! and reject! are the corresponding destructive methods to select and reject

Similar to select vs. reject, delete_if and keep_if have the exact opposite result when supplied with the same block

3.2.1 :094 > num
 => [1, 2, 3, 4, 5] 
 //select
3.2.1 :095 > num.select {|i| i>3}
 => [4, 5] 
 
//reject
3.2.1 :096 > num.reject {|i| i>3}
 => [1, 2, 3]
 
//drop_while  (it is similar to use while loop with drop function)
 
3.2.1 :097 > num.drop_while {|i| i>3}  (the while loop breaks since the initial condition is not meet for first element)
 => [1, 2, 3, 4, 5] 
3.2.1 :101 > num.drop_while { |i| i < 3}
 => [3, 4, 5] 
 
//delete_if
3.2.1 :103 > num.delete_if {|i| i>3}
 => [1, 2, 3] 
3.2.1 :104 > num
 => [1, 2, 3]
 
 //keep_if 
3.2.1 :105 > num.keep_if {|i| i>3}
 => []  
3.2.1 :107 > num
 => [] 

######### Methods for Creating an Array ###########

    ::[]: Returns a new array populated with given objects.

3.2.1 :003 > Array.[](1,'2','three')
 => [1, "2", "three"] 
3.2.1 :004 > Array.[](1..6)
 => [1..6]        
3.2.1 :006 > Array[1..6]
 => [1..6] 
3.2.1 :007 > Array[1,'2','three']
 => [1, "2", "three"] 
3.2.1 :008 > [1..6]
 => [1..6] 
3.2.1 :009 > [1,'2','three']
 => [1, "2", "three"] 


    ::new: Returns a new array.
With no block and a single Array argument array, returns a new Array formed from array:

3.2.1 :017 > a=Array.new([1,:to,'three','5'])
 => [1, :to, "three", "5"] 

3.2.1 :018 > a.class # => Array

3.2.1 :018 > a 
 => [1, :to, "three", "5"] 
 

With no block and a single Integer argument size, returns a new Array of the given size whose elements are all nil:

3.2.1 :018 > Array.new(5)
 => [nil, nil, nil, nil, nil] 


With no block and arguments size and default_value, returns an Array of the given size; each element is that same default_value:

3.2.1 :019 > Array.new(5,404)
 => [404, 404, 404, 404, 404] 


With a block and argument size, returns an Array of the given size; the block is called with each successive integer index; the element for that index is the return value from the block:

3.2.1 :020 > Array.new(5) {|i| "item #{i}"}
 => ["item 0", "item 1", "item 2", "item 3", "item 4"] 


=>>Raises ArgumentError if size is negative.
=>>With a block and no argument, or a single argument 0, ignores the block and returns a new empty Array.


(unable to run)    ::try_convert: Returns a new array created from a given object.
Method: Array.try_convert

.try_convert(object) ⇒ Object?

If object is an Array object, returns object.

Otherwise if object responds to :to_ary, calls object.to_ary and returns the result.

Returns nil if object does not respond to :to_ary

Raises an exception unless object.to_ary returns an Array object.

Returns:

    (Object, nil)

static VALUE
rb_ary_s_try_convert(VALUE dummy, VALUE ary)
{
    return rb_check_array_type(ary);
}

########## Methods for Querying ###########


    length, size: Returns the count of elements.

    include?: Returns whether any element == a given object.

    empty?: Returns whether there are no elements.

    all?: Returns whether all elements meet a given criterion.

    any?: Returns whether any element meets a given criterion.

    none?: Returns whether no element == a given object.

    one?: Returns whether exactly one element == a given object.

    count: Returns the count of elements that meet a given criterion.

    find_index, index: Returns the index of the first element that meets a given criterion.

    rindex: Returns the index of the last element that meets a given criterion.

    hash: Returns the integer hash code.


3.2.1 :001 > arr=Array(1..5)
 => [1, 2, 3, 4, 5]
 
 //length , size, count, empty?, include?
 
 3.2.1 :030 > arr.length
 => 5 
3.2.1 :031 > arr.size
 => 5 
3.2.1 :032 > arr.count
 => 5 
3.2.1 :034 > arr.empty?
 => false 
 
 
3.2.1 :035 > arr[6]=nil
 => nil 
3.2.1 :036 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :037 > arr.length
 => 7 
3.2.1 :038 > arr.size
 => 7 
3.2.1 :039 > arr.count
 => 7 
3.2.1 :040 > arr.empty?
 => false 

3.2.1 :041 > arr.include?5
 => true 
3.2.1 :042 > arr.include?(5)
 => true 
 3.2.1 :044 > arr.include?nil
 => true 
 
//all?, any?, none?, one?, find_index, index, rindex, hash

#all?
Returns true if all elements of self meet a given criterion.

With no block given and no argument, returns true if self contains only truthy elements, false otherwise:

3.2.1 :034 > [0, 1, :foo].all?
 => true 
3.2.1 :035 > [0, 1, :foo].all?nil
 => false 
3.2.1 :036 > [0, nil, 2].all?
 => false 
3.2.1 :037 > [0, nil, 2].all?nil
 => false 
3.2.1 :038 > [].all?
 => true 
3.2.1 :039 > [].all?nil
 => true 

3.2.1 :041 > num=Array(1..8)
 => [1, 2, 3, 4, 5, 6, 7, 8] 
 
3.2.1 :043 > num.all? {|i| i>0}
 => true 
3.2.1 :044 > num.all? {|i| i<7}
 => false 

If argument obj is given, returns true if obj.=== every element, false otherwise:
3.2.1 :045 > ['food', 'fool', 'foot'].all?(/foo/)
 => true 
3.2.1 :046 > ['food', 'drink'].all?(/bar/)
 => false 
3.2.1 :047 > [].all?(/foo/)
 => true 
3.2.1 :048 > [].all?(/bar/)
 => true 
3.2.1 :049 > [0, 0, 0].all?(0)
 => true 
3.2.1 :050 > [0, 1, 2].all?(1)
 => false 


#any?
Returns true if any element of self meets a given criterion.

With no block given and no argument, returns true if self has any truthy element, false otherwise:

##similar to all?



#none?
Returns true if no element of self meet a given criterion.

With no block given and no argument, returns true if self has no truthy elements, false otherwise:

##similar to all?


#one?
Returns true if exactly one element of self meets a given criterion.

With no block given and no argument, returns true if self has exactly one truthy element, false otherwise:

3.2.1 :062 > num
 => [1, 2, 3, 4, 5, 5, 7, 8] 
3.2.1 :063 > num.one?
 => false 
3.2.1 :064 > [].one?
 => false 

3.2.1 :067 > num.one? {|i| i>0}
 => false 
3.2.1 :068 > num.one? {|i| i>7}
 => true 

3.2.1 :069 > ['food', 'drink'].one?(/bar/)
 => false 
3.2.1 :070 > ['food', 'drink'].one?(/foo/)
 => true 


#find_index or index

array.index(obj)
Returns the index of obj 

arr=[1,2,3,4,5,6,7,7,8]
3.2.1 :036 > arr.index(7)
 => 6 
3.2.1 :037 > arr.index(10)
 => nil 

#rindex
=> similar to index(obj) but it returns the last matching obj

#array.hash
Computes a hash-code for array. Two arrays with the same content will
have the same hash code.

3.2.1 :027 > arr.hash
 => -4241591116995688593 
3.2.1 :028 > arr1.hash
 => 3624524072152072368


########## Methods for Comparing ###########


    <=>: Returns -1, 0, or 1 * as self is less than, equal to, or greater than a given object.
Returns -1 if any result is -1
Returns 1 if any result is 1:
Returns 1 both are equal:

3.2.1 :071 > [0,1,2,3] <=> [0,1,2,3]
 => 0 
3.2.1 :072 > [0,1,2,3] <=> [0,1,2,3,4]
 => -1 
3.2.1 :073 > [0,1,2,3,4] <=> [0,1,2,3]
 => 1 
3.2.1 :074 > [0,1,2,3,5] <=> [0,1,2,3,6]
 => -1 
3.2.1 :075 > [0,1,2,3,5,8] <=> [0,1,2,3,6,7]
 => -1 

    ==: Returns whether each element in self is == to the corresponding element in a given object.
=>check if both array is same
syntax: arr1==arr2

    eql?: Returns whether each element in self is eql? to the corresponding element in a given object.

=>similar to ==
syntax: arr1.eql?(arr2)

########## array & other_array ###########
Returns a new array containing elements common to the two arrays, with no duplicates.

3.2.1 :128 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :129 > arr2=[1,3,6,3,6,7,5]
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :130 > arr & arr2
 => [1, 3, 5] 

########## array * int ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :143 > arr3 = arr*1
 => [1, 2, 3, 4, 5] 
3.2.1 :144 > arr3 = arr*2
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
3.2.1 :145 > arr3 = arr*3
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
 
 3.2.1 :152 > str * 1
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :153 > str * 2
 => ["Ram", "Shayam", "Radha", "Ram", "Shayam", "Radha"] 

########## array * str ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :146 > str =['Ram','Shayam','Radha']
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :147 > str *,
3.2.1 :148 > 
^C                                      
3.2.1 :147 > str * ","
 => "Ram,Shayam,Radha" 
3.2.1 :148 > str * "R"
 => "RamRShayamRRadha" 
3.2.1 :149 > str * "<+>"
 => "Ram<+>Shayam<+>Radha" 
 
 3.2.1 :150 > arr*","
 => "1,2,3,4,5" 
3.2.1 :151 > arr*"=>"
 => "1=>2=>3=>4=>5" 

 
########## array + other_array ###########
Returns a new array built by concatenating the two arrays together to produce a third array.
3.2.1 :155 > arr3= arr + str
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :156 > arr4 = arr + arr2
 => [1, 2, 3, 4, 5, 1, 3, 6, 3, 6, 7, 5] 


########## array - other_array ###########
Returns a new array that is a copy of the original array, removing any items that also appear in other_array.
3.2.1 :157 > arr3
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :158 > arr3-arr
 => ["Ram", "Shayam", "Radha"] 


########## array | other_array ###########
Returns a new array by joining array with other_array, removing
duplicates.
3.2.1 :161 > arr
 => [1, 2, 3, 4, 5] 
3.2.1 :162 > arr2
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :163 > arr | arr2
 => [1, 2, 3, 4, 5, 6, 7] 
3.2.1 :164 > 


########## array << obj ###########
Pushes the given object onto the end of array. This expression returns the array itself, so several appends may be chained together.
//push_back
3.2.1 :175 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :176 > arr<<404
 => [1, 2, 3, 4, 5, 404] 
 
 //recuring values (bad practice)
 3.2.1 :039 > arr<<arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :040 > arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :041 > arr[5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :042 > arr[5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :043 > arr[5][5][5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :044 > str
 => ["Neeraj", "Kumar"] 
3.2.1 :045 > str[1]
 => "Kumar" 
3.2.1 :046 > str[1][1]
 => "u" 
3.2.1 :047 > str[1][1][1]
 => nil 

 
########## range,slice,index ###########
array[range]
3.2.1 :180 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9]

array.slice(index) 
3.2.1 :186 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
3.2.1 :187 > arr.slice(5,8)
 => [6, 7, 8, 9] 
 
 array.slice(range)
 3.2.1 :188 > arr.slice(5..8)
 => [6, 7, 8, 9] 
 
 array[start, length]
 3.2.1 :189 > arr[2,3]
 => [3, 4, 5]
 
########## input values in array ###########
3.2.1 :005 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
 
 array[index] = obj
3.2.1 :006 > arr[10]=100
 => 100 
3.2.1 :007 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100] 
3.2.1 :008 > arr<<200
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100, 200] 
 
 array[start, length] = obj or an_array or nil [or]
3.2.1 :009 > arr[3,6]=404
 => 404 
3.2.1 :010 > arr
 => [1, 2, 3, 404, nil, 100, 200] 
 
array[range] = obj or an_array or nil
3.2.1 :011 > arr[0..2]=500
 => 500 
3.2.1 :012 > arr
 => [500, 404, nil, 100, 200] 

########## array.abbrev(pattern = nil) ###########
Calculates the set of unambiguous abbreviations for the strings in self. If passed a pattern or a string, only the strings matching the pattern or starting with the string are considered.

3.2.1 :023 > require 'abbrev'
 => true 
3.2.1 :024 > arr.abbrev
/usr/share/rvm/rubies/ruby-3.2.1/lib/ruby/3.2.0/abbrev.rb:82:in `block in abbrev': undefined method `empty?' for 500:Integer (NoMethodError)

      next if word.empty?
      
3.2.1 :020 > str=['Neeraj','Kumar']
 => ["Neeraj", "Kumar"] 
3.2.1 :021 > str.abbrev
 => 
{"Neeraj"=>"Neeraj",                             
 "Neera"=>"Neeraj",                              
 "Neer"=>"Neeraj",                               
 "Nee"=>"Neeraj",                                
 "Ne"=>"Neeraj",                                 
 "N"=>"Neeraj",                                  
 "Kumar"=>"Kumar",                               
 "Kuma"=>"Kumar",                                
 "Kum"=>"Kumar",                                 
 "Ku"=>"Kumar",                                  
 "K"=>"Kumar"}  

########## array.assoc(obj) ###########
Searches through an array whose elements are also arrays comparing obj with the ﬁrst element of each contained array using obj.==. Returns the ﬁrst contained array that matches or nil if no match is found.
3.2.1 :062 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :063 > arr.assoc(1)
 => [1, 2, 3, 4] 
3.2.1 :064 > arr.assoc(500)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :065 > arr.rassoc(500)
 => nil 
3.2.1 :066 > arr.rassoc(404)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :067 > arr.rassoc(1)
 => nil 
3.2.1 :068 > arr.rassoc(2)
 => [1, 2, 3, 4] 

########## array.clear ###########
Removes all elements from array.
3.2.1 :070 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :071 > arr.clear
 => [] 
3.2.1 :072 > arr
 => [] 


########## array.collect { |item| block } [or]
array.map { |item| block } (return new array) ###########

3.2.1 :087 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :088 > arr.map{|i| 
3.2.1 :089 >   if i%2==0
3.2.1 :090 >     i
3.2.1 :091 >   end
3.2.1 :092 > }
 => 
[nil,                                               
 2,                                                 
 nil,                                               
 4,                                                 
 nil,                                               
 6,                                                 
 nil,                                               
 8,                                                 
 nil,                                           
 10,                                           
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :093 > arr.map{|i| 
3.2.1 :094 >   if i%2==0
3.2.1 :095 >     i
3.2.1 :096 >   end
3.2.1 :097 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 


########## array.collect! { |item| block } [or]
array.map! { |item| block } (it will change the original value of arr #inplace) ###########
3.2.1 :098 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :099 > arr.map!{|i| 
3.2.1 :100 >   if i%2==0
3.2.1 :101 >     i
3.2.1 :102 >   end
3.2.1 :103 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :104 > arr.map!{|i| 
3.2.1 :105 >   if i%2==0
3.2.1 :106 >     i
3.2.1 :107 >   end
3.2.1 :108 > }
(irb):105:in `block in <top (required)>': undefined method `%' for nil:NilClass (NoMethodError)

########## array.compact & array.compact! (inplace)  ###########
array.compact
Returns a copy of self with all nil elements removed.

array.compact!
Removes nil elements from array. Returns nil if no changes were made.

3.2.1 :132 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :133 > arr.map!{|i| 
3.2.1 :134 >   if i%2==0
3.2.1 :135 >     i
3.2.1 :136 >   end
3.2.1 :137 > }.compact
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :138 > arr
 => 
[nil,                                                                 
 2,                                                                   
 nil,                 
 4,                   
 nil,                 
 6,                   
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :139 > arr.compact!
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :140 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18]
 
########## array.concat(other_array) ###########
Appends the elements in other_array to self.
3.2.1 :142 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :143 > arr1= Array(19..25)
 => [19, 20, 21, 22, 23, 24, 25] 
3.2.1 :144 > arr.concat(arr1)
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :145 > 
 
########## array.delete(obj) [or]
array.delete(obj) { block } ###########

Deletes items from self that are equal to obj. If the item is not found,
returns nil. If the optional code block is given, returns the result of block
if the item is not found.

3.2.1 :151 > arr
 => [2, 4, 6, 8, 10, 12, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :152 > arr.delete(12){"not found"}
 => 12 
3.2.1 :153 > arr.delete(12){"not found"}
 => "not found" 
3.2.1 :154 > arr.delete(12)
 => nil 
3.2.1 :155 > arr.delete(16)
 => 16 


array.delete_at(index)
Deletes the element at the speciﬁed index, returning that element, or
nil if the index is out of range.
3.2.1 :156 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :157 > arr.delete_at(10)
 => 23 
3.2.1 :158 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 24, 25] 

array.delete_if { |item| block }

Deletes every element of self for which block evaluates to true.
3.2.1 :161 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :162 > arr.delete_if{|i| i%2==1}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 
########## array.empty?###########
array.empty?
Returns true if the self array contains no elements.

 
########## array.each { |item| block } and array.each_index { |index| block } ###########

array.each { |item| block }
Calls block once for each element in self, passing that element as a
parameter.

array.each_index { |index| block }
Same as Array#each, but passes the index of the element instead of the
element itself.

3.2.1 :170 > arr.each {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :171 > arr.each_index {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 3.2.1 :173 > arr.each_index {|i| print i.to_s + " :"}
0 :1 :2 :3 :4 :5 :6 :7 :8 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :174 > arr.each {|i| print i.to_s + " :"}
2 :4 :6 :8 :10 :12 :14 :16 :18 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
########## array.fetch ###########
array.fetch(index) [or]
array.fetch(index, default) [or]
array.fetch(index) { |index| block }
Tries to return the element at position index. If index lies outside the array, the ﬁrst form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking block, passing in index. Negative values of index count from the end of the array.
 
array.fetch(index) 
3.2.1 :011 > arr.fetch(10)
 => 11 
3.2.1 :012 > arr.fetch(11)
(irb):12:in `fetch': index 11 outside of array bounds: -11...11 (IndexError)         


array.fetch(index, default) 
3.2.1 :013 > arr.fetch(11,404)
 => 404 

array.fetch(index) { |index| block }
3.2.1 :015 > arr.fetch(10){|i| put i}
 => 11 
3.2.1 :016 > arr.fetch(11){|i|}
 => nil 
3.2.1 :017 > arr.fetch(11){|i| i*2}
 => 22 
3.2.1 :018 > arr.fetch(11){|i| i}
 => 11 

########## arr.fill ###########
array.ﬁll(obj) [or]
array.ﬁll(obj, start , length) [or]
array.ﬁll(obj, range) [or]
array.ﬁll { |index| block } [or]
array.ﬁll(start [, length] ) { |index| block } [or]
array.ﬁll(range) { |index| block }
The ﬁrst three forms set the selected elements of self to obj. A start of
nil is equivalent to zero. A length of nil is equivalent to self.length. The
last three forms ﬁll the array with the value of the block. The block is
passed with the absolute index of each element to be ﬁlled.
 
array.ﬁll(obj)
3.2.1 :019 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :020 > arr.fill(404)
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404] 
3.2.1 :021 > arr
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404]
 
 
array.ﬁll(obj, start , length)
3.2.1 :029 > arr.fill(404,3 ,4)
 => [1, 2, 3, 404, 404, 404, 404, 8, 9, 10, 11] 
 
  
array.ﬁll(obj, range)
3.2.1 :031 > arr.fill(404,3..4)
 => [1, 2, 3, 404, 404, 6, 7, 8, 9, 10, 11] 
 

array.ﬁll { |index| block } 
3.2.1 :044 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 

3.2.1 :045 > arr.fill{|i|
3.2.1 :046 >   if i%2==0
3.2.1 :047 >     404
3.2.1 :048 >   else 
3.2.1 :049 >     i
3.2.1 :050 >   end
3.2.1 :051 > }
 => [404, 1, 404, 3, 404, 5, 404, 7, 404, 9, 404] 
 

array.ﬁll(start , length) { |index| block }
3.2.1 :059 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :060 > arr.fill(3,4){|i|
3.2.1 :061 >   if i%2==0
3.2.1 :062 >     404
3.2.1 :063 >   else 
3.2.1 :064 >     i
3.2.1 :065 >   end
3.2.1 :066 > }
 => [1, 2, 3, 3, 404, 5, 404, 8, 9, 10, 11] 


array.ﬁll(range) { |index| block }
3.2.1 :067 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :068 > arr.fill(3..4){|i|
3.2.1 :069 >   if i%2==0
3.2.1 :070 >     404
3.2.1 :071 >   else 
3.2.1 :072 >     i
3.2.1 :073 >   end
3.2.1 :074 > }
 => [1, 2, 3, 3, 404, 6, 7, 8, 9, 10, 11] 
3.2.1 :075 > 

  
########## array.first  ###########
array.ﬁrst [or]
array.ﬁrst(n)
Returns the ﬁrst element, or the ﬁrst n elements, of the array. If the
array is empty, the ﬁrst form returns nil, and the second form returns an
empty array.

array.ﬁrst
3.2.1 :078 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :079 > arr.first
 => 1 

3.2.1 :082 > arr1=[]
 => [] 
3.2.1 :084 > arr1.first
 => nil 

array.ﬁrst(n)
3.2.1 :080 > arr.first(5)
 => [1, 2, 3, 4, 5] 
3.2.1 :085 > arr1.first(5)
 => [] 
 
########## array.last(n) , take(n) , drop(n)  ###########
//last(n)

3.2.1 :026 > arr
 => [1, 2, 3, 4, 5] 
3.2.1 :027 > arr.last
 => 5 
3.2.1 :028 > arr.last(3)
 => [3, 4, 5] 
 
//take(n) 
to return the first n elements of an array, use take

3.2.1 :020 > arr.take(5)
 => [1, 2, 3, 4, 5] 
3.2.1 :021 > arr.take(6)
 => [1, 2, 3, 4, 5] 
3.2.1 :022 > arr.take(10)
 => [1, 2, 3, 4, 5] 

//drop(n)
drop does the opposite of take, by returning the elements after n elements have been dropped:
3.2.1 :024 > arr.drop(1)
 => [2, 3, 4, 5] 
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5]

########## array.ﬂatten ###########
array.ﬂatten
Returns a new array that is a one-dimensional ﬂattening of this array
(recursively).

array.ﬂatten!
Flattens array in place. Returns nil if no modiﬁcations were made. (array
contains no subarrays.)

array.ﬂatten
 3.2.1 :018 > arr=Array(1..5)
 => [1, 2, 3, 4, 5] 
3.2.1 :019 > arr1=Array(6..8)
 => [6, 7, 8] 
3.2.1 :020 > arr[5]=arr1
 => [6, 7, 8] 
3.2.1 :021 > arr
 => [1, 2, 3, 4, 5, [6, 7, 8]] 
3.2.1 :022 > arr.flatten
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :023 > arr
 => [1, 2, 3, 4, 5, [6, 7, 8]] 
 
array.ﬂatten!
3.2.1 :024 > arr.flatten!
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
 
 
########## array.frozen? ###########
array.frozen?
Returns true if array is frozen (or temporarily frozen while being sorted)
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :026 > arr.frozen?
 => false 

 
########## finding ###########
array.include?(obj)
Returns true if obj is present in self, false otherwise.
 
array.include?(obj)
3.2.1 :033 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :034 > arr.include?(7)
 => true 
3.2.1 :035 > arr.include?(10)
 => false 
 
array.index(obj)
Returns the index of t 
 
array.index(obj)
3.2.1 :036 > arr.index(7)
 => 6 
3.2.1 :037 > arr.index(10)
 => nil 
 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########


