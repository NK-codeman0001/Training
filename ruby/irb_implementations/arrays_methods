Arrays
_____________________________________________________________________________________
########## [] ###########
friends = Array[1,2.3,"Ram"]
or
friends = Array.new
friends[0]=1
friends[1]=3.3
friends[2] ="Ram"

########## Array literal ###########
3.2.1 :002 > arr=[1, 'one', :one, [2, 'two', :two]]
 => [1, "one", :one, [2, "two", :two]] 
3.2.1 :003 > arr
 => [1, "one", :one, [2, "two", :two]] 
 
3.2.1 :004 > %w[neeraj kumar, graduate engineer trainee]
 => ["neeraj", "kumar,", "graduate", "engineer", "trainee"] 

3.2.1 :005 > %i[neeraj kumar, graduate engineer trainee]
 => [:neeraj, :"kumar,", :graduate, :engineer, :trainee] 
 
 3.2.1 :006 > Array(key: :value)   
 => [[:key, :value]] 

3.2.1 :008 > Array({:a => "a", :b => "b"})
 => [[:a, "a"], [:b, "b"]] 

3.2.1 :009 > Array(nil) 
 => []

3.2.1 :013 > Array.new 
 => [] 
 
3.2.1 :010 > Array.new(3) 
 => [nil, nil, nil] 
 
3.2.1 :011 > Array.new(4) {Hash.new}
 => [{}, {}, {}, {}] 

3.2.1 :012 > Array.new(3, true) 
 => [true, true, true] 
 
3.2.1 :014 > Array.new(4) {|i| i.to_s }
 => ["0", "1", "2", "3"] 
 
3.2.1 :015 > Array.new(3) {Array.new(3)}
 => [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]] 

########## array information ###########

3.2.1 :001 > arr=Array(1..5)
 => [1, 2, 3, 4, 5]
 3.2.1 :030 > arr.length
 => 5 
3.2.1 :031 > arr.size
 => 5 
3.2.1 :032 > arr.count
 => 5 
3.2.1 :034 > arr.empty?
 => false 
 
 
3.2.1 :035 > arr[6]=nil
 => nil 
3.2.1 :036 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :037 > arr.length
 => 7 
3.2.1 :038 > arr.size
 => 7 
3.2.1 :039 > arr.count
 => 7 
3.2.1 :040 > arr.empty?
 => false 

3.2.1 :041 > arr.include?5
 => true 
3.2.1 :042 > arr.include?(5)
 => true 
 3.2.1 :044 > arr.include?nil
 => true 
 

########## puts ###########
puts friends   	##prints every element of array in new line
puts friends[0]  ##prints 1st element of array in
puts friends[0,2] 	##prints 2 element from 0 index of array in new line

########## methods ###########
friends.length()
friends.include? "Ram"     #case sensitive
friends.reverse()
friends.sort()       ##it will work only when all element have same data types

########## Adding Items to Arrays ###########
3.2.1 :045 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :046 > arr.push(200)
 => [1, 2, 3, 4, 5, nil, nil, 200] 
3.2.1 :047 > arr<<6
 => [1, 2, 3, 4, 5, nil, nil, 200, 6] 

//unshift
unshift will add a new item to the beginning of an array.

3.2.1 :048 > arr.unshift(404)
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6] 
 
//insert
With insert you can add a new element to an array at any position.
If there is already an element at that position then new element will be added at that index only shifting the other elements

3.2.1 :049 > arr.size
 => 10 
3.2.1 :050 > arr.insert(10,'Apple')
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple"] 
3.2.1 :051 > arr.insert(15,'A2')
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A2"] 

3.2.1 :055 > arr
 => [404, 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A3", nil] 
3.2.1 :056 > arr.insert(1,'one')
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "A2", "A3", nil] 
3.2.1 :057 > arr[16]
 => "A2" 
3.2.1 :058 > arr.insert(16,'sixteen') //it will shift the other elements
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen", "A2", "A3", nil] 

3.2.1 :059 > arr.insert(0,'0','1','2')  //adding multiple element at a time.
 => ["0", "1", "2", 404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen", "A2", "A3", nil] 

########## Removing Items from an Array ###########
//pop (remove last element and return it)
The method pop removes the last element in an array and returns it:

3.2.1 :062 > arr.pop
 => "A3" 
3.2.1 :063 > d=arr.pop
 => "A2" 
3.2.1 :064 > d
 => "A2" 
//shift (remove first element and return it)
To retrieve and at the same time remove the first item, use shift:
3.2.1 :065 > d=arr.shift
 => "0" 
3.2.1 :066 > d
 => "0" 

//delete_at(index)  
To delete an element at a particular index:
3.2.1 :067 > d=arr.delete_at(0)
 => "1" 
3.2.1 :068 > d
 => "1" 
 
//delete(value)
To delete a particular element anywhere in an array, use delete
3.2.1 :069 > d=arr.delete(0)
 => nil 
3.2.1 :070 > d=arr.delete('2')
 => "2" 
3.2.1 :071 > d
 => "2" 

//compact and compact! 
A useful method if you need to remove nil values from an array is compact:
3.2.1 :072 > arr.compact
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :073 > arr
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen"] 
3.2.1 :074 > arr.compact!
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :075 > arr
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 

########## Iterating over Arrays ###########
3.2.1 :081 > num=Array(1..5)
 => [1, 2, 3, 4, 5] 
 
//.each
In case of Array’s each, all elements in the Array instance are yielded to the supplied block in sequence.
Note that this operation leaves the array unchanged.

3.2.1 :082 > num.each {|i| print i -= 10, " "}
-9 -8 -7 -6 -5  => [1, 2, 3, 4, 5] 

//.reverse_each
reverse_each which will iterate over the elements in the array in reverse order.

3.2.1 :083 > arr.reverse_each {|i| print i, " "}
sixteen Apple 6 200 5 4 3 2 1 one 404  => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"]                                               
3.2.1 :084 > words=%w[hello world ruby]
 => ["hello", "world", "ruby"] 
3.2.1 :085 > str=""
 => "" 
3.2.1 :086 > words.reverse_each {|i| str += "#{i}"}
 => ["hello", "world", "ruby"] 
3.2.1 :087 > str
 => "rubyworldhello" 
3.2.1 :088 > str=""
 => "" 
3.2.1 :089 > words.reverse_each {|i| str += "#{i} "}
 => ["hello", "world", "ruby"] 
 
//map
The map method can be used to create a new array based on the original array, but with the values modified by the supplied block

3.2.1 :090 > arr.map {|i| i*2}
 => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
3.2.1 :091 > arr
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :092 > arr.map! {|i| i*2}
 => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 
3.2.1 :093 > arr
 => [808, "oneone", 2, 4, 6, 8, 10, 400, 12, "AppleApple", "sixteensixteen"] 

########## Selecting Items from an Array ###########
select! and reject! are the corresponding destructive methods to select and reject

Similar to select vs. reject, delete_if and keep_if have the exact opposite result when supplied with the same block

3.2.1 :094 > num
 => [1, 2, 3, 4, 5] 
 //select
3.2.1 :095 > num.select {|i| i>3}
 => [4, 5] 
 
//reject
3.2.1 :096 > num.reject {|i| i>3}
 => [1, 2, 3]
 
//drop_while  (it is similar to use while loop with drop function)
 
3.2.1 :097 > num.drop_while {|i| i>3}  (the while loop breaks since the initial condition is not meet for first element)
 => [1, 2, 3, 4, 5] 
3.2.1 :101 > num.drop_while { |i| i < 3}
 => [3, 4, 5] 
 
//delete_if
3.2.1 :103 > num.delete_if {|i| i>3}
 => [1, 2, 3] 
3.2.1 :104 > num
 => [1, 2, 3]
 
 //keep_if 
3.2.1 :105 > num.keep_if {|i| i>3}
 => []  
3.2.1 :107 > num
 => [] 

######### Methods for Creating an Array ###########

    ::[]: Returns a new array populated with given objects.

3.2.1 :003 > Array.[](1,'2','three')
 => [1, "2", "three"] 
3.2.1 :004 > Array.[](1..6)
 => [1..6]        
3.2.1 :006 > Array[1..6]
 => [1..6] 
3.2.1 :007 > Array[1,'2','three']
 => [1, "2", "three"] 
3.2.1 :008 > [1..6]
 => [1..6] 
3.2.1 :009 > [1,'2','three']
 => [1, "2", "three"] 


    ::new: Returns a new array.
With no block and a single Array argument array, returns a new Array formed from array:

3.2.1 :017 > a=Array.new([1,:to,'three','5'])
 => [1, :to, "three", "5"] 

3.2.1 :018 > a.class # => Array

3.2.1 :018 > a 
 => [1, :to, "three", "5"] 
 

With no block and a single Integer argument size, returns a new Array of the given size whose elements are all nil:

3.2.1 :018 > Array.new(5)
 => [nil, nil, nil, nil, nil] 


With no block and arguments size and default_value, returns an Array of the given size; each element is that same default_value:

3.2.1 :019 > Array.new(5,404)
 => [404, 404, 404, 404, 404] 


With a block and argument size, returns an Array of the given size; the block is called with each successive integer index; the element for that index is the return value from the block:

3.2.1 :020 > Array.new(5) {|i| "item #{i}"}
 => ["item 0", "item 1", "item 2", "item 3", "item 4"] 


=>>Raises ArgumentError if size is negative.
=>>With a block and no argument, or a single argument 0, ignores the block and returns a new empty Array.


(unable to run)    ::try_convert: Returns a new array created from a given object.
Method: Array.try_convert

.try_convert(object) ⇒ Object?

If object is an Array object, returns object.

Otherwise if object responds to :to_ary, calls object.to_ary and returns the result.

Returns nil if object does not respond to :to_ary

Raises an exception unless object.to_ary returns an Array object.

Returns:

    (Object, nil)

static VALUE
rb_ary_s_try_convert(VALUE dummy, VALUE ary)
{
    return rb_check_array_type(ary);
}

########## Methods for Querying ###########


    length, size: Returns the count of elements.

    include?: Returns whether any element == a given object.

    empty?: Returns whether there are no elements.

    all?: Returns whether all elements meet a given criterion.

    any?: Returns whether any element meets a given criterion.

    none?: Returns whether no element == a given object.

    one?: Returns whether exactly one element == a given object.

    count: Returns the count of elements that meet a given criterion.

    find_index, index: Returns the index of the first element that meets a given criterion.

    rindex: Returns the index of the last element that meets a given criterion.

    hash: Returns the integer hash code.


3.2.1 :001 > arr=Array(1..5)
 => [1, 2, 3, 4, 5]
 
 //length , size, count, empty?, include?
 
 3.2.1 :030 > arr.length
 => 5 
3.2.1 :031 > arr.size
 => 5 
3.2.1 :032 > arr.count
 => 5 
3.2.1 :034 > arr.empty?
 => false 
 
 
3.2.1 :035 > arr[6]=nil
 => nil 
3.2.1 :036 > arr
 => [1, 2, 3, 4, 5, nil, nil] 
3.2.1 :037 > arr.length
 => 7 
3.2.1 :038 > arr.size
 => 7 
3.2.1 :039 > arr.count
 => 7 
3.2.1 :040 > arr.empty?
 => false 

3.2.1 :041 > arr.include?5
 => true 
3.2.1 :042 > arr.include?(5)
 => true 
 3.2.1 :044 > arr.include?nil
 => true 
 
//all?, any?, none?, one?, find_index, index, rindex, hash

#all?
Returns true if all elements of self meet a given criterion.

With no block given and no argument, returns true if self contains only truthy elements, false otherwise:

3.2.1 :034 > [0, 1, :foo].all?
 => true 
3.2.1 :035 > [0, 1, :foo].all?nil
 => false 
3.2.1 :036 > [0, nil, 2].all?
 => false 
3.2.1 :037 > [0, nil, 2].all?nil
 => false 
3.2.1 :038 > [].all?
 => true 
3.2.1 :039 > [].all?nil
 => true 

3.2.1 :041 > num=Array(1..8)
 => [1, 2, 3, 4, 5, 6, 7, 8] 
 
3.2.1 :043 > num.all? {|i| i>0}
 => true 
3.2.1 :044 > num.all? {|i| i<7}
 => false 

If argument obj is given, returns true if obj.=== every element, false otherwise:
3.2.1 :045 > ['food', 'fool', 'foot'].all?(/foo/)
 => true 
3.2.1 :046 > ['food', 'drink'].all?(/bar/)
 => false 
3.2.1 :047 > [].all?(/foo/)
 => true 
3.2.1 :048 > [].all?(/bar/)
 => true 
3.2.1 :049 > [0, 0, 0].all?(0)
 => true 
3.2.1 :050 > [0, 1, 2].all?(1)
 => false 


#any?
Returns true if any element of self meets a given criterion.

With no block given and no argument, returns true if self has any truthy element, false otherwise:

##similar to all?



#none?
Returns true if no element of self meet a given criterion.

With no block given and no argument, returns true if self has no truthy elements, false otherwise:

##similar to all?


#one?
Returns true if exactly one element of self meets a given criterion.

With no block given and no argument, returns true if self has exactly one truthy element, false otherwise:

3.2.1 :062 > num
 => [1, 2, 3, 4, 5, 5, 7, 8] 
3.2.1 :063 > num.one?
 => false 
3.2.1 :064 > [].one?
 => false 

3.2.1 :067 > num.one? {|i| i>0}
 => false 
3.2.1 :068 > num.one? {|i| i>7}
 => true 

3.2.1 :069 > ['food', 'drink'].one?(/bar/)
 => false 
3.2.1 :070 > ['food', 'drink'].one?(/foo/)
 => true 


#find_index or index

array.index(obj)
Returns the index of obj 

arr=[1,2,3,4,5,6,7,7,8]
3.2.1 :036 > arr.index(7)
 => 6 
3.2.1 :037 > arr.index(10)
 => nil 

#rindex
=> similar to index(obj) but it returns the last matching obj

#array.hash
Computes a hash-code for array. Two arrays with the same content will
have the same hash code.

3.2.1 :027 > arr.hash
 => -4241591116995688593 
3.2.1 :028 > arr1.hash
 => 3624524072152072368


########## Methods for Comparing ###########


    <=>: Returns -1, 0, or 1 * as self is less than, equal to, or greater than a given object.
Returns -1 if any result is -1
Returns 1 if any result is 1:
Returns 1 both are equal:

3.2.1 :071 > [0,1,2,3] <=> [0,1,2,3]
 => 0 
3.2.1 :072 > [0,1,2,3] <=> [0,1,2,3,4]
 => -1 
3.2.1 :073 > [0,1,2,3,4] <=> [0,1,2,3]
 => 1 
3.2.1 :074 > [0,1,2,3,5] <=> [0,1,2,3,6]
 => -1 
3.2.1 :075 > [0,1,2,3,5,8] <=> [0,1,2,3,6,7]
 => -1 

    ==: Returns whether each element in self is == to the corresponding element in a given object.
=>check if both array is same
syntax: arr1==arr2

    eql?: Returns whether each element in self is eql? to the corresponding element in a given object.

=>similar to ==
syntax: arr1.eql?(arr2)

########## array & other_array ###########
Returns a new array containing elements common to the two arrays, with no duplicates.

3.2.1 :128 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :129 > arr2=[1,3,6,3,6,7,5]
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :130 > arr & arr2
 => [1, 3, 5] 

########## array * int ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :143 > arr3 = arr*1
 => [1, 2, 3, 4, 5] 
3.2.1 :144 > arr3 = arr*2
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
3.2.1 :145 > arr3 = arr*3
 => [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 
 
 3.2.1 :152 > str * 1
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :153 > str * 2
 => ["Ram", "Shayam", "Radha", "Ram", "Shayam", "Radha"] 

########## array * str ###########
Returns a new array built by concatenating the int copies of self. With a String argument, equivalent to self.join(str).

3.2.1 :146 > str =['Ram','Shayam','Radha']
 => ["Ram", "Shayam", "Radha"] 
3.2.1 :147 > str *,
3.2.1 :148 > 
^C                                      
3.2.1 :147 > str * ","
 => "Ram,Shayam,Radha" 
3.2.1 :148 > str * "R"
 => "RamRShayamRRadha" 
3.2.1 :149 > str * "<+>"
 => "Ram<+>Shayam<+>Radha" 
 
 3.2.1 :150 > arr*","
 => "1,2,3,4,5" 
3.2.1 :151 > arr*"=>"
 => "1=>2=>3=>4=>5" 

 
########## array + other_array ###########
Returns a new array built by concatenating the two arrays together to produce a third array.
3.2.1 :155 > arr3= arr + str
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :156 > arr4 = arr + arr2
 => [1, 2, 3, 4, 5, 1, 3, 6, 3, 6, 7, 5] 


########## array - other_array ###########
Returns a new array that is a copy of the original array, removing any items that also appear in other_array.
3.2.1 :157 > arr3
 => [1, 2, 3, 4, 5, "Ram", "Shayam", "Radha"] 
3.2.1 :158 > arr3-arr
 => ["Ram", "Shayam", "Radha"] 


########## array | other_array ###########
Returns a new array by joining array with other_array, removing
duplicates.
3.2.1 :161 > arr
 => [1, 2, 3, 4, 5] 
3.2.1 :162 > arr2
 => [1, 3, 6, 3, 6, 7, 5] 
3.2.1 :163 > arr | arr2
 => [1, 2, 3, 4, 5, 6, 7] 
3.2.1 :164 > 


########## array << obj ###########
Pushes the given object onto the end of array. This expression returns the array itself, so several appends may be chained together.
//push_back
3.2.1 :175 > arr=[1,2,3,4,5]
 => [1, 2, 3, 4, 5] 
3.2.1 :176 > arr<<404
 => [1, 2, 3, 4, 5, 404] 
 
 //recuring values (bad practice)
 3.2.1 :039 > arr<<arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :040 > arr
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :041 > arr[5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :042 > arr[5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :043 > arr[5][5][5][5]
 => [500, 404, nil, 100, 200, [...]] 
3.2.1 :044 > str
 => ["Neeraj", "Kumar"] 
3.2.1 :045 > str[1]
 => "Kumar" 
3.2.1 :046 > str[1][1]
 => "u" 
3.2.1 :047 > str[1][1][1]
 => nil 

 
########## range,index ###########
array[range]
3.2.1 :180 > arr=Array(1..9)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9]

 array[start, length]
 3.2.1 :189 > arr[2,3]
 => [3, 4, 5]
 
########## input values in array ###########
3.2.1 :005 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
 
 array[index] = obj
3.2.1 :006 > arr[10]=100
 => 100 
3.2.1 :007 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100] 
3.2.1 :008 > arr<<200
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, nil, 100, 200] 
 
 array[start, length] = obj or an_array or nil [or]
3.2.1 :009 > arr[3,6]=404
 => 404 
3.2.1 :010 > arr
 => [1, 2, 3, 404, nil, 100, 200] 
 
array[range] = obj or an_array or nil
3.2.1 :011 > arr[0..2]=500
 => 500 
3.2.1 :012 > arr
 => [500, 404, nil, 100, 200] 

########## array.abbrev(pattern = nil) ###########
Calculates the set of unambiguous abbreviations for the strings in self. If passed a pattern or a string, only the strings matching the pattern or starting with the string are considered.

3.2.1 :023 > require 'abbrev'
 => true 
3.2.1 :024 > arr.abbrev
/usr/share/rvm/rubies/ruby-3.2.1/lib/ruby/3.2.0/abbrev.rb:82:in `block in abbrev': undefined method `empty?' for 500:Integer (NoMethodError)

      next if word.empty?
      
3.2.1 :020 > str=['Neeraj','Kumar']
 => ["Neeraj", "Kumar"] 
3.2.1 :021 > str.abbrev
 => 
{"Neeraj"=>"Neeraj",                             
 "Neera"=>"Neeraj",                              
 "Neer"=>"Neeraj",                               
 "Nee"=>"Neeraj",                                
 "Ne"=>"Neeraj",                                 
 "N"=>"Neeraj",                                  
 "Kumar"=>"Kumar",                               
 "Kuma"=>"Kumar",                                
 "Kum"=>"Kumar",                                 
 "Ku"=>"Kumar",                                  
 "K"=>"Kumar"}  


########## array.clear ###########
Removes all elements from array.
3.2.1 :070 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :071 > arr.clear
 => [] 
3.2.1 :072 > arr
 => [] 


########## array.collect { |item| block } [or]
array.map { |item| block } (return new array) ###########

3.2.1 :087 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :088 > arr.map{|i| 
3.2.1 :089 >   if i%2==0
3.2.1 :090 >     i
3.2.1 :091 >   end
3.2.1 :092 > }
 => 
[nil,                                               
 2,                                                 
 nil,                                               
 4,                                                 
 nil,                                               
 6,                                                 
 nil,                                               
 8,                                                 
 nil,                                           
 10,                                           
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :093 > arr.map{|i| 
3.2.1 :094 >   if i%2==0
3.2.1 :095 >     i
3.2.1 :096 >   end
3.2.1 :097 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 


########## array.collect! { |item| block } [or]
array.map! { |item| block } (it will change the original value of arr #inplace) ###########
3.2.1 :098 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :099 > arr.map!{|i| 
3.2.1 :100 >   if i%2==0
3.2.1 :101 >     i
3.2.1 :102 >   end
3.2.1 :103 > }
 => 
[nil,
 2,
 nil,
 4,
 nil,
 6,
 nil,
 8,
 nil,
 10,
 nil,
 12,
 nil,
 14,
 nil,
 16,
 nil,
 18] 
3.2.1 :104 > arr.map!{|i| 
3.2.1 :105 >   if i%2==0
3.2.1 :106 >     i
3.2.1 :107 >   end
3.2.1 :108 > }
(irb):105:in `block in <top (required)>': undefined method `%' for nil:NilClass (NoMethodError)

########## array.concat(other_array) ###########
Appends the elements in other_array to self.
3.2.1 :142 > arr
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :143 > arr1= Array(19..25)
 => [19, 20, 21, 22, 23, 24, 25] 
3.2.1 :144 > arr.concat(arr1)
 => [2, 4, 6, 8, 10, 12, 14, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :145 > 
 
########## array.delete(obj) [or]
array.delete(obj) { block } ###########

Deletes items from self that are equal to obj. If the item is not found,
returns nil. If the optional code block is given, returns the result of block
if the item is not found.

3.2.1 :151 > arr
 => [2, 4, 6, 8, 10, 12, 16, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :152 > arr.delete(12){"not found"}
 => 12 
3.2.1 :153 > arr.delete(12){"not found"}
 => "not found" 
3.2.1 :154 > arr.delete(12)
 => nil 
3.2.1 :155 > arr.delete(16)
 => 16 


array.delete_at(index)
Deletes the element at the speciﬁed index, returning that element, or
nil if the index is out of range.
3.2.1 :156 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 23, 24, 25] 
3.2.1 :157 > arr.delete_at(10)
 => 23 
3.2.1 :158 > arr
 => [2, 4, 6, 8, 10, 18, 19, 20, 21, 22, 24, 25] 

array.delete_if { |item| block }

Deletes every element of self for which block evaluates to true.
3.2.1 :161 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :162 > arr.delete_if{|i| i%2==1}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 
########## array.empty?###########
array.empty?
Returns true if the self array contains no elements.

 
########## array.each { |item| block } and array.each_index { |index| block } ###########

array.each { |item| block }
Calls block once for each element in self, passing that element as a
parameter.

array.each_index { |index| block }
Same as Array#each, but passes the index of the element instead of the
element itself.

3.2.1 :170 > arr.each {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :171 > arr.each_index {|i|}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 
 3.2.1 :173 > arr.each_index {|i| print i.to_s + " :"}
0 :1 :2 :3 :4 :5 :6 :7 :8 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
3.2.1 :174 > arr.each {|i| print i.to_s + " :"}
2 :4 :6 :8 :10 :12 :14 :16 :18 : => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
 


########## array.ﬂatten ###########
array.ﬂatten
Returns a new array that is a one-dimensional ﬂattening of this array
(recursively).

array.ﬂatten!
Flattens array in place. Returns nil if no modiﬁcations were made. (array
contains no subarrays.)

array.ﬂatten
 3.2.1 :018 > arr=Array(1..5)
 => [1, 2, 3, 4, 5] 
3.2.1 :019 > arr1=Array(6..8)
 => [6, 7, 8] 
3.2.1 :020 > arr[5]=arr1
 => [6, 7, 8] 
3.2.1 :021 > arr
 => [1, 2, 3, 4, 5, [6, 7, 8]] 
3.2.1 :022 > arr.flatten
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :023 > arr
 => [1, 2, 3, 4, 5, [6, 7, 8]] 
 
array.ﬂatten!
3.2.1 :024 > arr.flatten!
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
 
 
########## array.frozen? ###########
array.frozen?
Returns true if array is frozen (or temporarily frozen while being sorted)
3.2.1 :025 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :026 > arr.frozen?
 => false 

 
########## finding ###########
array.include?(obj)
Returns true if obj is present in self, false otherwise.
 
array.include?(obj)
3.2.1 :033 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8] 
3.2.1 :034 > arr.include?(7)
 => true 
3.2.1 :035 > arr.include?(10)
 => false 
 
array.index(obj)
Returns the index of t 
 
array.index(obj)
3.2.1 :036 > arr.index(7)
 => 6 
3.2.1 :037 > arr.index(10)
 => nil 
 
########## Methods for Fetching ###########
These methods do not modify self.

    [] or slice: Returns one or more elements.
    a = [:foo, 'bar', 2]
    a[0] # => :foo
    a[2] # => 2
    a # => [:foo, "bar", 2]

    a[-1] # => 2
    a[-2] # => "bar"

    a[0, 2] # => [:foo, "bar"]
    a[1, 2] # => ["bar", 2]

    If start + length is greater than self.length, returns all elements from offset start to the end:

    a = [:foo, 'bar', 2]
    a[0, 4] # => [:foo, "bar", 2]
    a[1, 3] # => ["bar", 2]
    a[2, 2] # => [2]

    If start + length is greater than self.length, returns all elements from offset start to the end:

    a = [:foo, 'bar', 2]
    a[0, 4] # => [:foo, "bar", 2]
    a[1, 3] # => ["bar", 2]
    a[2, 2] # => [2]

    If start == self.size and length >= 0, returns a new empty Array.

    If length is negative, returns nil.

    When a single Range argument range is given, treats range.min as start above and range.size as length above:

    a = [:foo, 'bar', 2]
    a[0..1] # => [:foo, "bar"]
    a[1..2] # => ["bar", 2]

    Special case: If range.start == a.size, returns a new empty Array.

    If range.end is negative, calculates the end index from the end:

    a = [:foo, 'bar', 2]
    a[0..-1] # => [:foo, "bar", 2]
    a[0..-2] # => [:foo, "bar"]
    a[0..-3] # => [:foo]
    
    If range.start is negative, calculates the start index from the end:
    
    a = [:foo, 'bar', 2]
    a[-1..2] # => [2]
    a[-2..2] # => ["bar", 2]
    a[-3..2] # => [:foo, "bar", 2]
    
    If range.start is larger than the array size, returns nil.
    
    a = [:foo, 'bar', 2]
    a[4..1] # => nil
    a[4..0] # => nil
    a[4..-1] # => nil
    


    fetch: Returns the element at a given offset.
    ########## array.fetch ###########
    array.fetch(index) [or]
    array.fetch(index, default) [or]
    array.fetch(index) { |index| block }
    Tries to return the element at position index. If index lies outside the array, the ﬁrst form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking block, passing in index. Negative values of index count from the end of the array.
     
    array.fetch(index) 
    3.2.1 :011 > arr.fetch(10)
     => 11 
    3.2.1 :012 > arr.fetch(11)
    (irb):12:in `fetch': index 11 outside of array bounds: -11...11 (IndexError)         
    
    
    array.fetch(index, default) 
    3.2.1 :013 > arr.fetch(11,404)
     => 404 
    
    array.fetch(index) { |index| block }
    3.2.1 :015 > arr.fetch(10){|i| put i}
     => 11 
    3.2.1 :016 > arr.fetch(11){|i|}
     => nil 
    3.2.1 :017 > arr.fetch(11){|i| i*2}
     => 22 
    3.2.1 :018 > arr.fetch(11){|i| i}
     => 11 
    

    first: Returns one or more leading elements.
    ########## array.first  ###########
    array.ﬁrst [or]
    array.ﬁrst(n)
    Returns the ﬁrst element, or the ﬁrst n elements, of the array. If the
    array is empty, the ﬁrst form returns nil, and the second form returns an
    empty array.
    
    array.ﬁrst
    3.2.1 :078 > arr
     => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
    3.2.1 :079 > arr.first
     => 1 
    
    3.2.1 :082 > arr1=[]
     => [] 
    3.2.1 :084 > arr1.first
     => nil 
    
    array.ﬁrst(n)
    3.2.1 :080 > arr.first(5)
     => [1, 2, 3, 4, 5] 
    3.2.1 :085 > arr1.first(5)
     => [] 
    
    last: Returns one or more trailing elements.
    ########## array.last(n) ###########
    //last(n)
    
    3.2.1 :026 > arr
     => [1, 2, 3, 4, 5] 
    3.2.1 :027 > arr.last
     => 5 
    3.2.1 :028 > arr.last(3)
     => [3, 4, 5] 


    max: Returns one or more maximum-valued elements, as determined by <=> or a given block.
    irb(main):025:0> arr
    => [:one, "two", "3", 4]
    irb(main):026:0> arr.max
    (irb):26:in `max': comparison of Symbol with String failed (ArgumentError)

    irb(main):027:0> nums=Array(1..6)
    => [1, 2, 3, 4, 5, 6]
    irb(main):028:0> nums.max
    => 6
    irb(main):029:0> nums.max(2)
    => [6, 5]
    irb(main):030:0> nums.max(10)
    => [6, 5, 4, 3, 2, 1]
    irb(main):031:0> arr.max {|a,b| a.size <=> b.size}
    => 4
    irb(main):032:0> 4.size
    => 4
    irb(main):033:0> arr[0].size
    => 3
    irb(main):034:0> arr.max(2) {|a,b| a.size <=> b.size}
    => [4, "two"]
    
    
    min: Returns one or more minimum-valued elements, as determined by <=> or a given block.

=>>similar to max it will return min value


    minmax: Returns the minimum-valued and maximum-valued elements, as determined by <=> or a given block.
    irb(main):040:0> nums
    => [1, 2, 3, 4, 5, 6]
    irb(main):041:0> arr
    => [:one, "two", "3", 4]
    irb(main):042:0> nums.minmax
    => [1, 6]
    irb(main):043:0> arr.minmax { |a,b| a.size <=> b.size }
    => ["3", 4]


    assoc: Returns the first element that is an array whose first element == a given object.
########## array.assoc(obj) ###########
Searches through an array whose elements are also arrays comparing obj with the ﬁrst element of each contained array using obj.==. Returns the ﬁrst contained array that matches or nil if no match is found.
3.2.1 :062 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :063 > arr.assoc(1)
 => [1, 2, 3, 4] 
3.2.1 :064 > arr.assoc(500)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :065 > arr.rassoc(500)
 => nil 
3.2.1 :066 > arr.rassoc(404)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :067 > arr.rassoc(1)
 => nil 
3.2.1 :068 > arr.rassoc(2)
 => [1, 2, 3, 4] 


    rassoc: Returns the first element that is an array whose second element == a given object.
3.2.1 :062 > arr
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :065 > arr.rassoc(500)
 => nil 
3.2.1 :066 > arr.rassoc(404)
 => [500, 404, nil, 100, 200, [...], [1, 2, 3, 4]] 
3.2.1 :067 > arr.rassoc(1)
 => nil 
3.2.1 :068 > arr.rassoc(2)
 => [1, 2, 3, 4] 


    at: Returns the element at a given offset.
 
    irb(main):040:0> nums
    => [1, 2, 3, 4, 5, 6]
    irb(main):041:0> arr
    => [:one, "two", "3", 4]
    irb(main):044:0> arr.at(0)
    => :one
    irb(main):045:0> nums.at(6)
    => nil
    irb(main):046:0> nums.at(3)
    => 4

    values_at: Returns the elements at given offsets.
    irb(main):047:0> nums.at(0..3)
    
    (irb):47:in `at': no implicit conversion of Range into Integer (TypeError)
            
    irb(main):048:0> nums.at(0,3)
    (irb):48:in `at': wrong number of arguments (given 2, expected 1) (ArgumentError)

    irb(main):049:0> nums.values_at(0..3)
    => [1, 2, 3, 4]
    irb(main):050:0> nums.values_at(1,3)
    => [2, 4]
    irb(main):051:0> nums.values_at(3,1,2,0)
    => [4, 2, 3, 1]
    irb(main):052:0> nums
    => [1, 2, 3, 4, 5, 6]
    irb(main):053:0> nums.values_at(-3,-1,-2,-0)
    => [4, 6, 5, 1]

    dig: Returns the object in nested objects that is specified by a given index and additional arguments.
    Finds and returns the object in nested objects that is specified by index and identifiers. The nested objects may be instances of various classes. See Dig Methods.

    Examples:
    
    a = [:foo, [:bar, :baz, [:bat, :bam]]]
    a.dig(1) # => [:bar, :baz, [:bat, :bam]]
    a.dig(1, 2) # => [:bat, :bam]
    a.dig(1, 2, 0) # => :bat
    a.dig(1, 2, 3) # => nil
   

    drop: Returns trailing elements as determined by a given index.

    //drop(n)
    drop does the opposite of take, by returning the elements after n elements have been dropped:
    3.2.1 :024 > arr.drop(1)
     => [2, 3, 4, 5] 
    3.2.1 :025 > arr
     => [1, 2, 3, 4, 5]


    take: Returns leading elements as determined by a given index.

    //take(n) 
    to return the first n elements of an array, use take
    
    3.2.1 :020 > arr.take(5)
     => [1, 2, 3, 4, 5] 
    3.2.1 :021 > arr.take(6)
     => [1, 2, 3, 4, 5] 
    3.2.1 :022 > arr.take(10)
     => [1, 2, 3, 4, 5] 

    drop_while: Returns trailing elements as determined by a given block.

    //drop_while  (it is similar to use while loop with drop function)
 
    3.2.1 :097 > num.drop_while {|i| i>3}  (the while loop breaks since the initial condition is not meet for first element)
     => [1, 2, 3, 4, 5] 
    3.2.1 :101 > num.drop_while { |i| i < 3}
     => [3, 4, 5] 
    
    take_while: Returns leading elements as determined by a given block.
=>> similar to drop_while but it return values which satisgy the condition

    slice & slice!: Returns consecutive elements as determined by a given argument.
    array.slice(index) 
    3.2.1 :186 > arr=Array(1..9)
     => [1, 2, 3, 4, 5, 6, 7, 8, 9] 
    3.2.1 :187 > arr.slice(5,8)
     => [6, 7, 8, 9] 
     
     array.slice(range)
     3.2.1 :188 > arr.slice(5..8)
     => [6, 7, 8, 9] 
     
    
    sort and sort!: Returns all elements in an order determined by <=> or a given block.

    a = 'abcde'.split('').shuffle
    a # => ["e", "b", "d", "a", "c"]
    a1 = a.sort
    a1 # => ["a", "b", "c", "d", "e"]

    a1 = a.sort {|a, b| a <=> b }
    a1 # => ["a", "b", "c", "d", "e"]
    a2 = a.sort {|a, b| b <=> a }
    a2 # => ["e", "d", "c", "b", "a"]

    //sort_by
    a = ['aaaa', 'bbb', 'cc', 'd']
    a.sort_by! {|element| element.size }
    a # => ["d", "cc", "bbb", "aaaa"]

    a = ['aaaa', 'bbb', 'cc', 'd']
    a.sort_by! # => #<Enumerator: ["aaaa", "bbb", "cc", "d"]:sort_by!>

    reverse and reverse!: Returns all elements in reverse order.
    a = ['foo', 'bar', 'two']
    a1 = a.reverse
    a1 # => ["two", "bar", "foo"]

    a = [:foo, 'bar', 2]
    a.reverse_each {|element|  puts "#{element.class} #{element}" }
    Output:

    Integer 2
    String bar
    Symbol foo
    
    a = [:foo, 'bar', 2]
    a.reverse_each {|element| puts element; a.clear if element.to_s.start_with?('b') }
    Output:

    2
    bar
    

    compact: Returns an array containing all non-nil elements.
    ########## array.compact & array.compact! (inplace)  ###########
    array.compact
    Returns a copy of self with all nil elements removed.
    
    array.compact!
    Removes nil elements from array. Returns nil if no changes were made.
    
    3.2.1 :132 > arr=Array(1..18)
     => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
    3.2.1 :133 > arr.map!{|i| 
    3.2.1 :134 >   if i%2==0
    3.2.1 :135 >     i
    3.2.1 :136 >   end
    3.2.1 :137 > }.compact
     => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
    3.2.1 :138 > arr
     => 
    [nil,2,nil,4,nil,6,nil,8,nil,10,nil,12,nil,14,nil,16,nil,18] 
    3.2.1 :139 > arr.compact!
     => [2, 4, 6, 8, 10, 12, 14, 16, 18] 
    3.2.1 :140 > arr
     => [2, 4, 6, 8, 10, 12, 14, 16, 18]
     
//compact and compact! 
A useful method if you need to remove nil values from an array is compact:
3.2.1 :072 > arr.compact
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :073 > arr
 => [404, "one", 1, 2, 3, 4, 5, nil, nil, 200, 6, "Apple", nil, nil, nil, nil, "sixteen"] 
3.2.1 :074 > arr.compact!
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 
3.2.1 :075 > arr
 => [404, "one", 1, 2, 3, 4, 5, 200, 6, "Apple", "sixteen"] 


    select, filter: Returns an array containing elements selected by a given block.
    3.2.1 :094 > num
    => [1, 2, 3, 4, 5] 
    //select
   3.2.1 :095 > num.select {|i| i>3}
    => [4, 5]

    a = [:foo, 'bar', 2, :bam]
    a.select # => #<Enumerator: [:foo, "bar", 2, :bam]:select>

    uniq and uniq! : Returns an array containing non-duplicate elements.
    a = [0, 0, 1, 1, 2, 2]
    a.uniq # => [0, 1, 2]

    a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
    a.uniq {|element| element.size } # => ["a", "aa", "aaa"]


    rotate and rotate!: Returns all elements with some rotated from one end to the other.

    When no argument given, returns a new Array that is like self, except that the first element has been rotated to the last position:

    a = [:foo, 'bar', 2, 'bar']
    a1 = a.rotate
    a1 # => ["bar", 2, "bar", :foo]
    
    When given a non-negative Integer count, returns a new Array with count elements rotated from the beginning to the end:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(2)
    a1 # => [2, :foo, "bar"]
    
    If count is large, uses count % array.size as the count:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(20)
    a1 # => [2, :foo, "bar"]
    
    If count is zero, returns a copy of self, unmodified:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(0)
    a1 # => [:foo, "bar", 2]
    
    When given a negative Integer count, rotates in the opposite direction, from end to beginning:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(-2)
    a1 # => ["bar", 2, :foo]
    
    If count is small (far from zero), uses count % array.size as the count:
    
    a = [:foo, 'bar', 2]
    a1 = a.rotate(-5)
    a1 # => ["bar", 2, :foo]
    

(unable to perform)    bsearch: Returns an element selected via a binary search as determined by a given block.

static VALUE
rb_ary_bsearch(VALUE ary)
{
    VALUE index_result = rb_ary_bsearch_index(ary);

    if (FIXNUM_P(index_result)) {
        return rb_ary_entry(ary, FIX2LONG(index_result));
    }
    return index_result;
}

(unable to perform)    bsearch_index: Returns the index of an element selected via a binary search as determined by a given block.

static VALUE
rb_ary_bsearch_index(VALUE ary)
{
    long low = 0, high = RARRAY_LEN(ary), mid;
    int smaller = 0, satisfied = 0;
    VALUE v, val;

    RETURN_ENUMERATOR(ary, 0, 0);
    while (low < high) {
        mid = low + ((high - low) / 2);
        val = rb_ary_entry(ary, mid);
        v = rb_yield(val);
        if (FIXNUM_P(v)) {
            if (v == INT2FIX(0)) return INT2FIX(mid);
            smaller = (SIGNED_VALUE)v < 0; /* Fixnum preserves its sign-bit */
        }
        else if (v == Qtrue) {
            satisfied = 1;
            smaller = 1;
        }
        else if (!RTEST(v)) {
            smaller = 0;
        }
        else if (rb_obj_is_kind_of(v, rb_cNumeric)) {
            const VALUE zero = INT2FIX(0);
            switch (rb_cmpint(rb_funcallv(v, id_cmp, 1, &zero), v, zero)) {
              case 0: return INT2FIX(mid);
              case 1: smaller = 1; break;
              case -1: smaller = 0;
            }
        }
        else {
            rb_raise(rb_eTypeError, "wrong argument type %"PRIsVALUE
                     " (must be numeric, true, false or nil)",
                     rb_obj_class(v));
        }
        if (smaller) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    if (!satisfied) return Qnil;
    return INT2FIX(low);
}


    sample: Returns one or more random elements.

    Returns random elements from self.

    When no arguments are given, returns a random element from self:
    
    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    a.sample # => 3
    a.sample # => 8
    
    If self is empty, returns nil.
    
    When argument n is given, returns a new Array containing n random elements from self:
    
    a.sample(3) # => [8, 9, 2]
    a.sample(6) # => [9, 6, 10, 3, 1, 4]
    
    Returns no more than a.size elements (because no new duplicates are introduced):
    
    a.sample(a.size * 2) # => [6, 4, 1, 8, 5, 9, 10, 2, 3, 7]
    
    But self may contain duplicates:
    
    a = [1, 1, 1, 2, 2, 3]
    a.sample(a.size * 2) # => [1, 1, 3, 2, 1, 2]
    
    The argument n must be a non-negative numeric value. The order of the result array is unrelated to the order of self. Returns a new empty Array if self is empty.
    
    The optional random argument will be used as the random number generator:
    
    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    a.sample(random: Random.new(1))     #=> 6
    a.sample(4, random: Random.new(1))  #=> [6, 10, 9, 2]
    

    shuffle and shuffle!: Returns elements in a random order.
    a = [1, 2, 3] #=> [1, 2, 3]
    a.shuffle     #=> [2, 3, 1]
    a             #=> [1, 2, 3]

    The optional random argument will be used as the random number generator:

    a.shuffle(random: Random.new(1))  #=> [1, 3, 2]
    
 
########## Methods for Assigning ###########

    []=: Assigns specified elements with a given object.
a = [:foo, 'bar', 2]
a[0] = 'foo' # => "foo"
a # => ["foo", "bar", 2]

If index is greater than self.length, extends the array:

a = [:foo, 'bar', 2]
a[7] = 'foo' # => "foo"
a # => [:foo, "bar", 2, nil, nil, nil, nil, "foo"]

If index is negative, counts backwards from the end of the array:

a = [:foo, 'bar', 2]
a[-1] = 'two' # => "two"
a # => [:foo, "bar", "two"]
    
 a = [:foo, 'bar', 2]  # => [:foo, "bar", 2] 
 a[-2, 0]=200  # => 200 
 a       # => [:foo, 200, "bar", 2] 
 
When Integer arguments start and length are given and object is not an Array, removes length - 1 elements beginning at offset start, and assigns object at offset start:

a = [:foo, 'bar', 2]
a[0, 2] = 'foo' # => "foo"
a # => ["foo", 2]

If start is negative, counts backwards from the end of the array:

a = [:foo, 'bar', 2]
a[-2, 2] = 'foo' # => "foo"
a # => [:foo, "foo"]

If start is non-negative and outside the array ( >= self.size), extends the array with nil, assigns object at offset start, and ignores length:

a = [:foo, 'bar', 2]
a[6, 50] = 'foo' # => "foo"
a # => [:foo, "bar", 2, nil, nil, nil, "foo"]

If length is zero, shifts elements at and following offset start and assigns object at offset start:

a = [:foo, 'bar', 2]
a[1, 0] = 'foo' # => "foo"
a # => [:foo, "foo", "bar", 2]

If length is too large for the existing array, does not extend the array:

a = [:foo, 'bar', 2]
a[1, 5] = 'foo' # => "foo"
a # => [:foo, "foo"]

When Range argument range is given and object is an Array, removes length - 1 elements beginning at offset start, and assigns object at offset start:

a = [:foo, 'bar', 2]
a[0..1] = 'foo' # => "foo"
a # => ["foo", 2]

if range.begin is negative, counts backwards from the end of the array:

a = [:foo, 'bar', 2]
a[-2..2] = 'foo' # => "foo"
a # => [:foo, "foo"]

If the array length is less than range.begin, assigns object at offset range.begin, and ignores length:

a = [:foo, 'bar', 2]
a[6..50] = 'foo' # => "foo"
a # => [:foo, "bar", 2, nil, nil, nil, "foo"]

If range.end is zero, shifts elements at and following offset start and assigns object at offset start:

a = [:foo, 'bar', 2]
a[1..0] = 'foo' # => "foo"
a # => [:foo, "foo", "bar", 2]

If range.end is negative, assigns object at offset start, retains range.end.abs -1 elements past that, and removes those beyond:

a = [:foo, 'bar', 2]
a[1..-1] = 'foo' # => "foo"
a # => [:foo, "foo"]
a = [:foo, 'bar', 2]
a[1..-2] = 'foo' # => "foo"
a # => [:foo, "foo", 2]
a = [:foo, 'bar', 2]
a[1..-3] = 'foo' # => "foo"
a # => [:foo, "foo", "bar", 2]
a = [:foo, 'bar', 2]

If range.end is too large for the existing array, replaces array elements, but does not extend the array with nil values:

a = [:foo, 'bar', 2]
a[1..5] = 'foo' # => "foo"
a # => [:foo, "foo"]



    push, append, <<: Appends trailing elements.

a = [:foo, 'bar', 2]
a.push(:baz, :bat) # => [:foo, "bar", 2, :baz, :bat]

Appends each argument as one element, even if it is another Array:

//push & append
a = [:foo, 'bar', 2]
a1 = a.push([:baz, :bat], [:bam, :bad])
a1 # => [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]

//<<
a = [:foo, 'bar', 2]
a << :baz # => [:foo, "bar", 2, :baz]

a = [:foo, 'bar', 2]	#=> [:foo, "bar", 2] 
a1=a<<[3,4]	# => [:foo, "bar", 2, [3, 4]] 
a	# => [:foo, "bar", 2, [3, 4]] 
a1	# => [:foo, "bar", 2, [3, 4]] 



    unshift, prepend: add obj at start of array.
Prepends the given objects to self:

a = [:foo, 'bar', 2]
a.unshift(:bam, :bat) # => [:bam, :bat, :foo, "bar", 2]



    insert: Inserts given objects at a given offset; does not replace elements.
a = [:foo, 'bar', 2]
a.insert(1, :bat, :bam) # => [:foo, :bat, :bam, "bar", 2]

Extends the array if index is beyond the array (index >= self.size):

a = [:foo, 'bar', 2]
a.insert(5, :bat, :bam)
a # => [:foo, "bar", 2, nil, nil, :bat, :bam]

Does nothing if no objects given:

a = [:foo, 'bar', 2]
a.insert(1)
a.insert(50)
a.insert(-50)
a # => [:foo, "bar", 2]

When index is negative, inserts all given objects after the element at offset index+self.size:

a = [:foo, 'bar', 2]
a.insert(-2, :bat, :bam)
a # => [:foo, "bar", :bat, :bam, 2]

    concat: Appends all elements from given arrays.
a = [0, 1]
a.concat([2, 3], [4, 5]) # => [0, 1, 2, 3, 4, 5]


    fill: Replaces specified elements with specified objects.
########## arr.fill ###########
array.ﬁll(obj) [or]
array.ﬁll(obj, start , length) [or]
array.ﬁll(obj, range) [or]
array.ﬁll { |index| block } [or]
array.ﬁll([start , length] ) { |index| block } [or]
array.ﬁll(range) { |index| block }
The ﬁrst three forms set the selected elements of self to obj. A start of
nil is equivalent to zero. A length of nil is equivalent to self.length. The
last three forms ﬁll the array with the value of the block. The block is
passed with the absolute index of each element to be ﬁlled.
 
array.ﬁll(obj)
3.2.1 :019 > arr
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :020 > arr.fill(404)
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404] 
3.2.1 :021 > arr
 => [404, 404, 404, 404, 404, 404, 404, 404, 404, 404, 404]
 
 
array.ﬁll(obj, start , length)
3.2.1 :029 > arr.fill(404,3 ,4)
 => [1, 2, 3, 404, 404, 404, 404, 8, 9, 10, 11] 
 
  
array.ﬁll(obj, range)
3.2.1 :031 > arr.fill(404,3..4)
 => [1, 2, 3, 404, 404, 6, 7, 8, 9, 10, 11] 
 

array.ﬁll { |index| block } 
3.2.1 :044 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 

3.2.1 :045 > arr.fill{|i|
3.2.1 :046 >   if i%2==0
3.2.1 :047 >     404
3.2.1 :048 >   else 
3.2.1 :049 >     i
3.2.1 :050 >   end
3.2.1 :051 > }
 => [404, 1, 404, 3, 404, 5, 404, 7, 404, 9, 404] 
 

array.ﬁll(start , length) { |index| block }
3.2.1 :059 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :060 > arr.fill(3,4){|i|
3.2.1 :061 >   if i%2==0
3.2.1 :062 >     404
3.2.1 :063 >   else 
3.2.1 :064 >     i
3.2.1 :065 >   end
3.2.1 :066 > }
 => [1, 2, 3, 3, 404, 5, 404, 8, 9, 10, 11] 


array.ﬁll(range) { |index| block }
3.2.1 :067 > arr= Array(1..11)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 
3.2.1 :068 > arr.fill(3..4){|i|
3.2.1 :069 >   if i%2==0
3.2.1 :070 >     404
3.2.1 :071 >   else 
3.2.1 :072 >     i
3.2.1 :073 >   end
3.2.1 :074 > }
 => [1, 2, 3, 3, 404, 6, 7, 8, 9, 10, 11] 
3.2.1 :075 > 
 


    replace: Replaces the content of self with the content of a given array.

a = [:foo, 'bar', 2]
a.replace(['foo', :bar, 3]) # => ["foo", :bar, 3]
a # => ["foo", :bar, 3] 

    reverse!: Replaces self with its elements reversed.
==> inplace version of Replace method

    rotate!: Replaces self with its elements rotated.
==> inplace version of rotate method

    shuffle!: Replaces self with its elements in random order.
==> inplace version of shuffle method

    sort!: Replaces self with its elements sorted, as determined by <=> or a given block.
==> inplace version of sort method

    sort_by!: Replaces self with its elements sorted, as determined by a given block.
==> inplace version of sort_by method

 
 
########## Methods for Deleting ###########


    pop: Removes and returns the last element.
a = [:foo, 'bar', 2]
a.pop # => 2
a # => [:foo, "bar"]

a = [:foo, 'bar', 2]
a.pop(2) # => ["bar", 2]

a = [:foo, 'bar', 2]
a.pop(50) # => [:foo, "bar", 2]

   

    shift: Removes and returns the first element.
a = [:foo, 'bar', 2]
a.shift # => :foo
a # => ['bar', 2]

a = [:foo, 'bar', 2]
a.shift(2) # => [:foo, 'bar']
a # => [2]

a = [:foo, 'bar', 2]	# => [:foo, "bar", 2] 
a.shift(10)	# => [:foo, "bar", 2]  
a	# => [] 
a.shift		# => nil 
a.shift(10)	# => [] 

a = [:foo, 'bar', 2]	# => [:foo, "bar", 2] 
a.shift(0)	# => [] 
a	# => [:foo, "bar", 2] 


    compact!: Removes all nil elements.
==>>in place version of compact method

    delete: Removes elements equal to a given object.
s1 = 'bar'; s2 = 'bar'
a = [:foo, s1, 2, s2]
a.delete('bar') # => "bar"
a # => [:foo, 2]

If any such elements are found, ignores the block and returns the last deleted element:

s1 = 'bar'; s2 = 'bar'
a = [:foo, s1, 2, s2]
deleted_obj = a.delete('bar') {|obj| fail 'Cannot happen' }
a # => [:foo, 2]

If no such elements are found, returns the block’s return value:

a = [:foo, 'bar', 2]
a.delete(:nosuch) {|obj| "#{obj} not found" } # => "nosuch not found"


    delete_at: Removes the element at a given offset.
a = [:foo, 'bar', 2]
a.delete_at(1) # => "bar"
a # => [:foo, 2]

a = [:foo, 'bar', 2]  	# => [:foo, "bar", 2] 
a.delete_at(5)		# => nil 


    delete_if: Removes elements specified by a given block.

3.2.1 :103 > num.delete_if {|i| i>3}
 => [1, 2, 3] 
3.2.1 :104 > num
 => [1, 2, 3]
  
array.delete_if { |item| block }

Deletes every element of self for which block evaluates to true.
3.2.1 :161 > arr=Array(1..18)
 => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18] 
3.2.1 :162 > arr.delete_if{|i| i%2==1}
 => [2, 4, 6, 8, 10, 12, 14, 16, 18] 


    keep_if: Removes elements not specified by a given block.
 
num.keep_if {|i| i>3}	# => []  
num	# => [] 

a = [:foo, 'bar', 2, :bam]
a.keep_if {|element| element.to_s.start_with?('b') } # => ["bar", :bam]

    reject!: Removes elements specified by a given block.
==> inplace version of reject method

    select!, filter!: Removes elements not specified by a given block.
==> inplace version of select method

    slice!: Removes and returns a sequence of elements.
==> inplace version of slice method

    uniq!: Removes duplicates.
==> inplace version of uniq method

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########

 
##########  ###########


